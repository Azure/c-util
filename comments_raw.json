[{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2679289860","pull_request_review_id":3647464252,"id":2679289860,"node_id":"PRRC_kwDODaUZTc6fsrgE","diff_hunk":"@@ -0,0 +1,826 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#include \"paged_sparse_array_ut_pch.h\"\n+\n+/*PAGED_SPARSE_ARRAY with regular types*/\n+PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(uint32_t)\n+\n+THANDLE_TYPE_DECLARE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(uint32_t));\n+THANDLE_TYPE_DEFINE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(uint32_t));\n+\n+PAGED_SPARSE_ARRAY_TYPE_DECLARE(uint32_t);\n+PAGED_SPARSE_ARRAY_TYPE_DEFINE(uint32_t);\n+\n+typedef struct B_TEST_TAG\n+{\n+    int b;\n+} B_TEST;\n+\n+PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(B_TEST)\n+THANDLE_TYPE_DECLARE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(B_TEST));\n+THANDLE_TYPE_DEFINE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(B_TEST));\n+\n+PAGED_SPARSE_ARRAY_TYPE_DECLARE(B_TEST);\n+PAGED_SPARSE_ARRAY_TYPE_DEFINE(B_TEST);\n+\n+typedef struct A_TEST_TAG\n+{\n+    int a;\n+} A_TEST;\n+\n+THANDLE_TYPE_DECLARE(A_TEST);\n+THANDLE_TYPE_DEFINE(A_TEST);\n+\n+PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(THANDLE(A_TEST))\n+THANDLE_TYPE_DECLARE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(THANDLE(A_TEST)));\n+THANDLE_TYPE_DEFINE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(THANDLE(A_TEST)));\n+\n+/*PAGED_SPARSE_ARRAY works with THANDLEs too*/\n+PAGED_SPARSE_ARRAY_TYPE_DECLARE(THANDLE(A_TEST));\n+PAGED_SPARSE_ARRAY_TYPE_DEFINE(THANDLE(A_TEST));\n+\n+MU_DEFINE_ENUM_STRINGS(UMOCK_C_ERROR_CODE, UMOCK_C_ERROR_CODE_VALUES)\n+\n+static void on_umock_c_error(UMOCK_C_ERROR_CODE error_code)\n+{\n+    ASSERT_FAIL(\"umock_c reported error :%\" PRI_MU_ENUM \"\", MU_ENUM_VALUE(UMOCK_C_ERROR_CODE, error_code));\n+}\n+\n+\n+BEGIN_TEST_SUITE(TEST_SUITE_NAME_FROM_CMAKE)\n+\n+TEST_SUITE_INITIALIZE(it_does_something)\n+{\n+    ASSERT_ARE_EQUAL(int, 0, real_gballoc_hl_init(NULL, NULL));\n+\n+    umock_c_init(on_umock_c_error);\n+\n+    REGISTER_GBALLOC_HL_GLOBAL_MOCK_HOOK();\n+}\n+\n+TEST_SUITE_CLEANUP(TestClassCleanup)\n+{\n+    umock_c_deinit();\n+\n+    real_gballoc_hl_deinit();\n+}\n+\n+TEST_FUNCTION_INITIALIZE(f)\n+{\n+    umock_c_negative_tests_init();\n+    umock_c_reset_all_calls();\n+}\n+\n+TEST_FUNCTION_CLEANUP(cleans)\n+{\n+    umock_c_negative_tests_deinit();\n+}\n+\n+/*PAGED_SPARSE_ARRAY_CREATE(T)*/\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_003: [ PAGED_SPARSE_ARRAY_CREATE(T) shall compute the number of pages as (max_size + page_size - 1) / page_size. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_004: [ PAGED_SPARSE_ARRAY_CREATE(T) shall call THANDLE_MALLOC_FLEX to allocate memory for the paged sparse array with the number of pages. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_005: [ PAGED_SPARSE_ARRAY_CREATE(T) shall set all page pointers to NULL. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_006: [ PAGED_SPARSE_ARRAY_CREATE(T) shall store max_size and page_size in the structure. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_008: [ PAGED_SPARSE_ARRAY_CREATE(T) shall succeed and return a non-NULL value. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_CREATE_with_uint32_t_type_succeeds)\n+{\n+    //arrange\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 2, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(uint32_t)*)));\n+\n+    //act\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 64);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(psa);\n+    ASSERT_ARE_EQUAL(uint64_t, 100, psa->max_size);\n+    ASSERT_ARE_EQUAL(uint32_t, 64, psa->page_size);\n+    ASSERT_ARE_EQUAL(uint32_t, 2, psa->page_count);\n+    for (uint32_t i = 0; i < psa->page_count; i++)\n+    {\n+        ASSERT_IS_NULL(psa->pages[i]);\n+    }\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_003: [ PAGED_SPARSE_ARRAY_CREATE(T) shall compute the number of pages as (max_size + page_size - 1) / page_size. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_008: [ PAGED_SPARSE_ARRAY_CREATE(T) shall succeed and return a non-NULL value. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_CREATE_computes_page_count_correctly)\n+{\n+    //arrange\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 1, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(uint32_t)*)));\n+\n+    //act\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(10, 64);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(psa);\n+    ASSERT_ARE_EQUAL(uint32_t, 1, psa->page_count);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_001: [ If max_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_CREATE_fails_when_max_size_is_zero)\n+{\n+    //arrange\n+\n+    //act\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(0, 64);\n+\n+    //assert\n+    ASSERT_IS_NULL(psa);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_002: [ If page_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_CREATE_fails_when_page_size_is_zero)\n+{\n+    //arrange\n+\n+    //act\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 0);\n+\n+    //assert\n+    ASSERT_IS_NULL(psa);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_007: [ If there are any errors, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_CREATE_fails_when_malloc_flex_fails)\n+{\n+    //arrange\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 2, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(uint32_t)*)))\n+        .SetReturn(NULL);\n+\n+    //act\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 64);\n+\n+    //assert\n+    ASSERT_IS_NULL(psa);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_008: [ PAGED_SPARSE_ARRAY_CREATE(T) shall succeed and return a non-NULL value. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_CREATE_with_struct_type_succeeds)\n+{\n+    //arrange\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 1, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(B_TEST)*)));\n+\n+    //act\n+    PAGED_SPARSE_ARRAY(B_TEST) psa = PAGED_SPARSE_ARRAY_CREATE(B_TEST)(10, 16);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(psa);\n+    ASSERT_ARE_EQUAL(uint64_t, 10, psa->max_size);\n+    ASSERT_ARE_EQUAL(uint32_t, 16, psa->page_size);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(B_TEST)(&psa, NULL);\n+}\n+\n+/*PAGED_SPARSE_ARRAY_ALLOCATE(T)*/\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_013: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall compute the page index as index / page_size. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_014: [ If the page is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall allocate memory for the page containing page_size elements and an allocation bitmap, and initialize all elements as not allocated. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_016: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall mark the element at index as allocated. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_017: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall return a pointer to the element at index. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_succeeds_first_element)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 16, sizeof(uint32_t)));\n+    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 0);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(ptr);\n+    ASSERT_IS_NOT_NULL(psa->pages[0]);\n+    ASSERT_ARE_EQUAL(uint32_t, 1, psa->pages[0]->allocated_count);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_014: [ If the page is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall allocate memory for the page containing page_size elements and an allocation bitmap, and initialize all elements as not allocated. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_017: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall return a pointer to the element at index. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_succeeds_second_page)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 16, sizeof(uint32_t)));\n+    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 20);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(ptr);\n+    ASSERT_IS_NULL(psa->pages[0]); // First page should not be allocated\n+    ASSERT_IS_NOT_NULL(psa->pages[1]); // Second page should be allocated\n+    ASSERT_ARE_EQUAL(uint32_t, 1, psa->pages[1]->allocated_count);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_017: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall return a pointer to the element at index. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_multiple_elements_in_same_page)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 16, sizeof(uint32_t)));\n+    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\n+\n+    //act\n+    uint32_t* ptr0 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 0);\n+    uint32_t* ptr5 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+    uint32_t* ptr10 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 10);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(ptr0);\n+    ASSERT_IS_NOT_NULL(ptr5);\n+    ASSERT_IS_NOT_NULL(ptr10);\n+    ASSERT_ARE_EQUAL(uint32_t, 3, psa->pages[0]->allocated_count);\n+    ASSERT_ARE_NOT_EQUAL(void_ptr, ptr0, ptr5);\n+    ASSERT_ARE_NOT_EQUAL(void_ptr, ptr5, ptr10);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_011: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_fails_when_handle_is_null)\n+{\n+    //arrange\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(NULL, 0);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_012: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_fails_when_index_equals_max_size)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 100);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_012: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_fails_when_index_greater_than_max_size)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 150);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_015: [ If the element at index is already allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_fails_when_already_allocated)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    uint32_t* ptr1 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+    ASSERT_IS_NOT_NULL(ptr1);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr2 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr2);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_018: [ If there are any errors, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_fails_when_page_malloc_fails)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 16, sizeof(uint32_t)))\n+        .SetReturn(NULL);\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 0);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_018: [ If there are any errors, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_fails_when_bitmap_malloc_fails)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 16, sizeof(uint32_t)));\n+    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG))\n+        .SetReturn(NULL);\n+    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 0);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/*PAGED_SPARSE_ARRAY_RELEASE(T)*/\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_021: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall compute the page index as index / page_size. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_024: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall mark the element at index as not allocated. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_025: [ If all elements in the page are now not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall free the page and set the page pointer to NULL. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_026: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall return zero on success. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_RELEASE_succeeds_and_frees_page_when_last_element)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+    ASSERT_IS_NOT_NULL(ptr);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // bitmap\n+    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // page\n+\n+    //act\n+    int result = PAGED_SPARSE_ARRAY_RELEASE(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_ARE_EQUAL(int, 0, result);\n+    ASSERT_IS_NULL(psa->pages[0]);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_024: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall mark the element at index as not allocated. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_026: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall return zero on success. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_RELEASE_succeeds_but_keeps_page_when_other_elements_allocated)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    uint32_t* ptr1 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+    uint32_t* ptr2 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 10);\n+    ASSERT_IS_NOT_NULL(ptr1);\n+    ASSERT_IS_NOT_NULL(ptr2);\n+    ASSERT_ARE_EQUAL(uint32_t, 2, psa->pages[0]->allocated_count);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    int result = PAGED_SPARSE_ARRAY_RELEASE(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_ARE_EQUAL(int, 0, result);\n+    ASSERT_IS_NOT_NULL(psa->pages[0]); // Page should still be allocated\n+    ASSERT_ARE_EQUAL(uint32_t, 1, psa->pages[0]->allocated_count);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_019: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_RELEASE_fails_when_handle_is_null)\n+{\n+    //arrange\n+\n+    //act\n+    int result = PAGED_SPARSE_ARRAY_RELEASE(uint32_t)(NULL, 0);\n+\n+    //assert\n+    ASSERT_ARE_NOT_EQUAL(int, 0, result);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_020: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_RELEASE_fails_when_index_out_of_bounds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    int result = PAGED_SPARSE_ARRAY_RELEASE(uint32_t)(psa, 100);\n+\n+    //assert\n+    ASSERT_ARE_NOT_EQUAL(int, 0, result);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_022: [ If the page is not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_RELEASE_fails_when_page_not_allocated)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    int result = PAGED_SPARSE_ARRAY_RELEASE(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_ARE_NOT_EQUAL(int, 0, result);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_023: [ If the element at index is not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_RELEASE_fails_when_element_not_allocated)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+    ASSERT_IS_NOT_NULL(ptr);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    int result = PAGED_SPARSE_ARRAY_RELEASE(uint32_t)(psa, 10); // Different element in same page\n+\n+    //assert\n+    ASSERT_ARE_NOT_EQUAL(int, 0, result);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/*PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T)*/\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_029: [ PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall compute the page index as index / page_size. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_030: [ If the page is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall allocate memory for the page containing page_size elements and an allocation bitmap, and initialize all elements as not allocated. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_031: [ If the element at index is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall mark it as allocated. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_032: [ PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall return a pointer to the element at index. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET_allocates_new_element)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 16, sizeof(uint32_t)));\n+    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(ptr);\n+    ASSERT_IS_NOT_NULL(psa->pages[0]);\n+    ASSERT_ARE_EQUAL(uint32_t, 1, psa->pages[0]->allocated_count);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_032: [ PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall return a pointer to the element at index. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET_returns_existing_element)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    uint32_t* ptr1 = PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(uint32_t)(psa, 5);\n+    ASSERT_IS_NOT_NULL(ptr1);\n+    *ptr1 = 12345;\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr2 = PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(ptr2);\n+    ASSERT_ARE_EQUAL(void_ptr, ptr1, ptr2);\n+    ASSERT_ARE_EQUAL(uint32_t, 12345, *ptr2);\n+    ASSERT_ARE_EQUAL(uint32_t, 1, psa->pages[0]->allocated_count); // Count should not have changed\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_027: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET_fails_when_handle_is_null)\n+{\n+    //arrange\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(uint32_t)(NULL, 0);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_028: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET_fails_when_index_out_of_bounds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(uint32_t)(psa, 100);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_033: [ If there are any errors, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET_fails_when_page_malloc_fails)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 16, sizeof(uint32_t)))\n+        .SetReturn(NULL);\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(uint32_t)(psa, 0);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/*PAGED_SPARSE_ARRAY_GET(T)*/\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_036: [ PAGED_SPARSE_ARRAY_GET(T) shall compute the page index as index / page_size. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_039: [ PAGED_SPARSE_ARRAY_GET(T) shall return a pointer to the element at index. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_GET_succeeds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    uint32_t* ptr1 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+    ASSERT_IS_NOT_NULL(ptr1);\n+    *ptr1 = 42;\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr2 = PAGED_SPARSE_ARRAY_GET(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(ptr2);\n+    ASSERT_ARE_EQUAL(void_ptr, ptr1, ptr2);\n+    ASSERT_ARE_EQUAL(uint32_t, 42, *ptr2);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_034: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_GET(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_GET_fails_when_handle_is_null)\n+{\n+    //arrange\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_GET(uint32_t)(NULL, 0);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_035: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_GET(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_GET_fails_when_index_out_of_bounds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_GET(uint32_t)(psa, 100);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_037: [ If the page is not allocated, PAGED_SPARSE_ARRAY_GET(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_GET_fails_when_page_not_allocated)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_GET(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_038: [ If the element at index is not allocated, PAGED_SPARSE_ARRAY_GET(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_GET_fails_when_element_not_allocated)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+    ASSERT_IS_NOT_NULL(ptr);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* result = PAGED_SPARSE_ARRAY_GET(uint32_t)(psa, 10); // Different element in same page\n+\n+    //assert\n+    ASSERT_IS_NULL(result);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Integration test - allocate and release multiple elements */\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_integration_allocate_release_reallocate)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act - allocate some elements\n+    uint32_t* ptr0 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 0);\n+    uint32_t* ptr5 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+    uint32_t* ptr20 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 20); // second page\n+\n+    ASSERT_IS_NOT_NULL(ptr0);\n+    ASSERT_IS_NOT_NULL(ptr5);\n+    ASSERT_IS_NOT_NULL(ptr20);\n+\n+    // Write values\n+    *ptr0 = 100;\n+    *ptr5 = 500;\n+    *ptr20 = 2000;\n+\n+    // Release one element from first page\n+    int result = PAGED_SPARSE_ARRAY_RELEASE(uint32_t)(psa, 0);\n+    ASSERT_ARE_EQUAL(int, 0, result);\n+    ASSERT_IS_NOT_NULL(psa->pages[0]); // Page should still exist\n+\n+    // Release remaining element from first page - page should be freed\n+    result = PAGED_SPARSE_ARRAY_RELEASE(uint32_t)(psa, 5);\n+    ASSERT_ARE_EQUAL(int, 0, result);\n+    ASSERT_IS_NULL(psa->pages[0]); // Page should now be freed\n+\n+    // Second page should still exist\n+    ASSERT_IS_NOT_NULL(psa->pages[1]);\n+\n+    // Re-allocate element 0 (should allocate new page)\n+    uint32_t* ptr0_new = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 0);\n+    ASSERT_IS_NOT_NULL(ptr0_new);\n+    ASSERT_IS_NOT_NULL(psa->pages[0]);\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Test with THANDLE type */\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_with_THANDLE_type_works)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(THANDLE(A_TEST)) psa = PAGED_SPARSE_ARRAY_CREATE(THANDLE(A_TEST))(50, 10);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    THANDLE(A_TEST)* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(THANDLE(A_TEST))(psa, 0);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(ptr);\n+\n+    // Can use THANDLE operations on the stored value\n+    THANDLE(A_TEST) a = THANDLE_MALLOC(A_TEST)(NULL);\n+    ASSERT_IS_NOT_NULL(a);\n+\n+    THANDLE_INITIALIZE(A_TEST)(ptr, a);\n+    THANDLE_ASSIGN(A_TEST)(ptr, NULL);\n+    THANDLE_ASSIGN(A_TEST)(&a, NULL);\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(THANDLE(A_TEST))(&psa, NULL);\n+}\n+\n+/* Test with struct type */\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_with_struct_type_works)","path":"tests/paged_sparse_array_ut/paged_sparse_array_ut.c","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"fae1babc9fcbab5e561284cfff820db8e488b468","user":{"login":"dcristoloveanu","id":8507399,"node_id":"MDQ6VXNlcjg1MDczOTk=","avatar_url":"https://avatars.githubusercontent.com/u/8507399?v=4","gravatar_id":"","url":"https://api.github.com/users/dcristoloveanu","html_url":"https://github.com/dcristoloveanu","followers_url":"https://api.github.com/users/dcristoloveanu/followers","following_url":"https://api.github.com/users/dcristoloveanu/following{/other_user}","gists_url":"https://api.github.com/users/dcristoloveanu/gists{/gist_id}","starred_url":"https://api.github.com/users/dcristoloveanu/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dcristoloveanu/subscriptions","organizations_url":"https://api.github.com/users/dcristoloveanu/orgs","repos_url":"https://api.github.com/users/dcristoloveanu/repos","events_url":"https://api.github.com/users/dcristoloveanu/events{/privacy}","received_events_url":"https://api.github.com/users/dcristoloveanu/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"We should have a Tests tagged here as this is a unit test. #Resolved","created_at":"2026-01-11T07:03:11Z","updated_at":"2026-01-11T07:11:49Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2679289860","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2679289860"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2679289860"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2679289860/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":792,"original_line":804,"side":"RIGHT","author_association":"MEMBER","original_position":804,"position":792,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2679289985","pull_request_review_id":3647464346,"id":2679289985,"node_id":"PRRC_kwDODaUZTc6fsriB","diff_hunk":"@@ -0,0 +1,826 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#include \"paged_sparse_array_ut_pch.h\"\n+\n+/*PAGED_SPARSE_ARRAY with regular types*/\n+PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(uint32_t)\n+\n+THANDLE_TYPE_DECLARE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(uint32_t));\n+THANDLE_TYPE_DEFINE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(uint32_t));\n+\n+PAGED_SPARSE_ARRAY_TYPE_DECLARE(uint32_t);\n+PAGED_SPARSE_ARRAY_TYPE_DEFINE(uint32_t);\n+\n+typedef struct B_TEST_TAG\n+{\n+    int b;\n+} B_TEST;\n+\n+PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(B_TEST)\n+THANDLE_TYPE_DECLARE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(B_TEST));\n+THANDLE_TYPE_DEFINE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(B_TEST));\n+\n+PAGED_SPARSE_ARRAY_TYPE_DECLARE(B_TEST);\n+PAGED_SPARSE_ARRAY_TYPE_DEFINE(B_TEST);\n+\n+typedef struct A_TEST_TAG\n+{\n+    int a;\n+} A_TEST;\n+\n+THANDLE_TYPE_DECLARE(A_TEST);\n+THANDLE_TYPE_DEFINE(A_TEST);\n+\n+PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(THANDLE(A_TEST))\n+THANDLE_TYPE_DECLARE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(THANDLE(A_TEST)));\n+THANDLE_TYPE_DEFINE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(THANDLE(A_TEST)));\n+\n+/*PAGED_SPARSE_ARRAY works with THANDLEs too*/\n+PAGED_SPARSE_ARRAY_TYPE_DECLARE(THANDLE(A_TEST));\n+PAGED_SPARSE_ARRAY_TYPE_DEFINE(THANDLE(A_TEST));\n+\n+MU_DEFINE_ENUM_STRINGS(UMOCK_C_ERROR_CODE, UMOCK_C_ERROR_CODE_VALUES)\n+\n+static void on_umock_c_error(UMOCK_C_ERROR_CODE error_code)\n+{\n+    ASSERT_FAIL(\"umock_c reported error :%\" PRI_MU_ENUM \"\", MU_ENUM_VALUE(UMOCK_C_ERROR_CODE, error_code));\n+}\n+\n+\n+BEGIN_TEST_SUITE(TEST_SUITE_NAME_FROM_CMAKE)\n+\n+TEST_SUITE_INITIALIZE(it_does_something)\n+{\n+    ASSERT_ARE_EQUAL(int, 0, real_gballoc_hl_init(NULL, NULL));\n+\n+    umock_c_init(on_umock_c_error);\n+\n+    REGISTER_GBALLOC_HL_GLOBAL_MOCK_HOOK();\n+}\n+\n+TEST_SUITE_CLEANUP(TestClassCleanup)\n+{\n+    umock_c_deinit();\n+\n+    real_gballoc_hl_deinit();\n+}\n+\n+TEST_FUNCTION_INITIALIZE(f)\n+{\n+    umock_c_negative_tests_init();\n+    umock_c_reset_all_calls();\n+}\n+\n+TEST_FUNCTION_CLEANUP(cleans)\n+{\n+    umock_c_negative_tests_deinit();\n+}\n+\n+/*PAGED_SPARSE_ARRAY_CREATE(T)*/\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_003: [ PAGED_SPARSE_ARRAY_CREATE(T) shall compute the number of pages as (max_size + page_size - 1) / page_size. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_004: [ PAGED_SPARSE_ARRAY_CREATE(T) shall call THANDLE_MALLOC_FLEX to allocate memory for the paged sparse array with the number of pages. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_005: [ PAGED_SPARSE_ARRAY_CREATE(T) shall set all page pointers to NULL. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_006: [ PAGED_SPARSE_ARRAY_CREATE(T) shall store max_size and page_size in the structure. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_008: [ PAGED_SPARSE_ARRAY_CREATE(T) shall succeed and return a non-NULL value. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_CREATE_with_uint32_t_type_succeeds)\n+{\n+    //arrange\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 2, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(uint32_t)*)));\n+\n+    //act\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 64);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(psa);\n+    ASSERT_ARE_EQUAL(uint64_t, 100, psa->max_size);\n+    ASSERT_ARE_EQUAL(uint32_t, 64, psa->page_size);\n+    ASSERT_ARE_EQUAL(uint32_t, 2, psa->page_count);\n+    for (uint32_t i = 0; i < psa->page_count; i++)\n+    {\n+        ASSERT_IS_NULL(psa->pages[i]);\n+    }\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_003: [ PAGED_SPARSE_ARRAY_CREATE(T) shall compute the number of pages as (max_size + page_size - 1) / page_size. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_008: [ PAGED_SPARSE_ARRAY_CREATE(T) shall succeed and return a non-NULL value. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_CREATE_computes_page_count_correctly)\n+{\n+    //arrange\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 1, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(uint32_t)*)));\n+\n+    //act\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(10, 64);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(psa);\n+    ASSERT_ARE_EQUAL(uint32_t, 1, psa->page_count);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_001: [ If max_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_CREATE_fails_when_max_size_is_zero)\n+{\n+    //arrange\n+\n+    //act\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(0, 64);\n+\n+    //assert\n+    ASSERT_IS_NULL(psa);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_002: [ If page_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_CREATE_fails_when_page_size_is_zero)\n+{\n+    //arrange\n+\n+    //act\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 0);\n+\n+    //assert\n+    ASSERT_IS_NULL(psa);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_007: [ If there are any errors, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_CREATE_fails_when_malloc_flex_fails)\n+{\n+    //arrange\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 2, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(uint32_t)*)))\n+        .SetReturn(NULL);\n+\n+    //act\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 64);\n+\n+    //assert\n+    ASSERT_IS_NULL(psa);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_008: [ PAGED_SPARSE_ARRAY_CREATE(T) shall succeed and return a non-NULL value. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_CREATE_with_struct_type_succeeds)\n+{\n+    //arrange\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 1, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(B_TEST)*)));\n+\n+    //act\n+    PAGED_SPARSE_ARRAY(B_TEST) psa = PAGED_SPARSE_ARRAY_CREATE(B_TEST)(10, 16);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(psa);\n+    ASSERT_ARE_EQUAL(uint64_t, 10, psa->max_size);\n+    ASSERT_ARE_EQUAL(uint32_t, 16, psa->page_size);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(B_TEST)(&psa, NULL);\n+}\n+\n+/*PAGED_SPARSE_ARRAY_ALLOCATE(T)*/\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_013: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall compute the page index as index / page_size. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_014: [ If the page is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall allocate memory for the page containing page_size elements and an allocation bitmap, and initialize all elements as not allocated. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_016: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall mark the element at index as allocated. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_017: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall return a pointer to the element at index. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_succeeds_first_element)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 16, sizeof(uint32_t)));\n+    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 0);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(ptr);\n+    ASSERT_IS_NOT_NULL(psa->pages[0]);\n+    ASSERT_ARE_EQUAL(uint32_t, 1, psa->pages[0]->allocated_count);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_014: [ If the page is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall allocate memory for the page containing page_size elements and an allocation bitmap, and initialize all elements as not allocated. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_017: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall return a pointer to the element at index. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_succeeds_second_page)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 16, sizeof(uint32_t)));\n+    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 20);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(ptr);\n+    ASSERT_IS_NULL(psa->pages[0]); // First page should not be allocated\n+    ASSERT_IS_NOT_NULL(psa->pages[1]); // Second page should be allocated\n+    ASSERT_ARE_EQUAL(uint32_t, 1, psa->pages[1]->allocated_count);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_017: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall return a pointer to the element at index. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_multiple_elements_in_same_page)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 16, sizeof(uint32_t)));\n+    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\n+\n+    //act\n+    uint32_t* ptr0 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 0);\n+    uint32_t* ptr5 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+    uint32_t* ptr10 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 10);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(ptr0);\n+    ASSERT_IS_NOT_NULL(ptr5);\n+    ASSERT_IS_NOT_NULL(ptr10);\n+    ASSERT_ARE_EQUAL(uint32_t, 3, psa->pages[0]->allocated_count);\n+    ASSERT_ARE_NOT_EQUAL(void_ptr, ptr0, ptr5);\n+    ASSERT_ARE_NOT_EQUAL(void_ptr, ptr5, ptr10);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_011: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_fails_when_handle_is_null)\n+{\n+    //arrange\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(NULL, 0);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_012: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_fails_when_index_equals_max_size)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 100);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_012: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_fails_when_index_greater_than_max_size)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 150);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_015: [ If the element at index is already allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_fails_when_already_allocated)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    uint32_t* ptr1 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+    ASSERT_IS_NOT_NULL(ptr1);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr2 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr2);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_018: [ If there are any errors, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_fails_when_page_malloc_fails)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 16, sizeof(uint32_t)))\n+        .SetReturn(NULL);\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 0);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_018: [ If there are any errors, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_fails_when_bitmap_malloc_fails)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 16, sizeof(uint32_t)));\n+    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG))\n+        .SetReturn(NULL);\n+    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 0);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/*PAGED_SPARSE_ARRAY_RELEASE(T)*/\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_021: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall compute the page index as index / page_size. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_024: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall mark the element at index as not allocated. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_025: [ If all elements in the page are now not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall free the page and set the page pointer to NULL. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_026: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall return zero on success. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_RELEASE_succeeds_and_frees_page_when_last_element)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+    ASSERT_IS_NOT_NULL(ptr);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // bitmap\n+    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // page\n+\n+    //act\n+    int result = PAGED_SPARSE_ARRAY_RELEASE(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_ARE_EQUAL(int, 0, result);\n+    ASSERT_IS_NULL(psa->pages[0]);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_024: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall mark the element at index as not allocated. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_026: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall return zero on success. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_RELEASE_succeeds_but_keeps_page_when_other_elements_allocated)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    uint32_t* ptr1 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+    uint32_t* ptr2 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 10);\n+    ASSERT_IS_NOT_NULL(ptr1);\n+    ASSERT_IS_NOT_NULL(ptr2);\n+    ASSERT_ARE_EQUAL(uint32_t, 2, psa->pages[0]->allocated_count);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    int result = PAGED_SPARSE_ARRAY_RELEASE(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_ARE_EQUAL(int, 0, result);\n+    ASSERT_IS_NOT_NULL(psa->pages[0]); // Page should still be allocated\n+    ASSERT_ARE_EQUAL(uint32_t, 1, psa->pages[0]->allocated_count);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_019: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_RELEASE_fails_when_handle_is_null)\n+{\n+    //arrange\n+\n+    //act\n+    int result = PAGED_SPARSE_ARRAY_RELEASE(uint32_t)(NULL, 0);\n+\n+    //assert\n+    ASSERT_ARE_NOT_EQUAL(int, 0, result);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_020: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_RELEASE_fails_when_index_out_of_bounds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    int result = PAGED_SPARSE_ARRAY_RELEASE(uint32_t)(psa, 100);\n+\n+    //assert\n+    ASSERT_ARE_NOT_EQUAL(int, 0, result);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_022: [ If the page is not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_RELEASE_fails_when_page_not_allocated)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    int result = PAGED_SPARSE_ARRAY_RELEASE(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_ARE_NOT_EQUAL(int, 0, result);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_023: [ If the element at index is not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_RELEASE_fails_when_element_not_allocated)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+    ASSERT_IS_NOT_NULL(ptr);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    int result = PAGED_SPARSE_ARRAY_RELEASE(uint32_t)(psa, 10); // Different element in same page\n+\n+    //assert\n+    ASSERT_ARE_NOT_EQUAL(int, 0, result);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/*PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T)*/\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_029: [ PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall compute the page index as index / page_size. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_030: [ If the page is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall allocate memory for the page containing page_size elements and an allocation bitmap, and initialize all elements as not allocated. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_031: [ If the element at index is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall mark it as allocated. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_032: [ PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall return a pointer to the element at index. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET_allocates_new_element)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 16, sizeof(uint32_t)));\n+    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(ptr);\n+    ASSERT_IS_NOT_NULL(psa->pages[0]);\n+    ASSERT_ARE_EQUAL(uint32_t, 1, psa->pages[0]->allocated_count);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_032: [ PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall return a pointer to the element at index. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET_returns_existing_element)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    uint32_t* ptr1 = PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(uint32_t)(psa, 5);\n+    ASSERT_IS_NOT_NULL(ptr1);\n+    *ptr1 = 12345;\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr2 = PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(ptr2);\n+    ASSERT_ARE_EQUAL(void_ptr, ptr1, ptr2);\n+    ASSERT_ARE_EQUAL(uint32_t, 12345, *ptr2);\n+    ASSERT_ARE_EQUAL(uint32_t, 1, psa->pages[0]->allocated_count); // Count should not have changed\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_027: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET_fails_when_handle_is_null)\n+{\n+    //arrange\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(uint32_t)(NULL, 0);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_028: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET_fails_when_index_out_of_bounds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(uint32_t)(psa, 100);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_033: [ If there are any errors, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET_fails_when_page_malloc_fails)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 16, sizeof(uint32_t)))\n+        .SetReturn(NULL);\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(uint32_t)(psa, 0);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/*PAGED_SPARSE_ARRAY_GET(T)*/\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_036: [ PAGED_SPARSE_ARRAY_GET(T) shall compute the page index as index / page_size. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_039: [ PAGED_SPARSE_ARRAY_GET(T) shall return a pointer to the element at index. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_GET_succeeds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    uint32_t* ptr1 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+    ASSERT_IS_NOT_NULL(ptr1);\n+    *ptr1 = 42;\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr2 = PAGED_SPARSE_ARRAY_GET(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(ptr2);\n+    ASSERT_ARE_EQUAL(void_ptr, ptr1, ptr2);\n+    ASSERT_ARE_EQUAL(uint32_t, 42, *ptr2);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_034: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_GET(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_GET_fails_when_handle_is_null)\n+{\n+    //arrange\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_GET(uint32_t)(NULL, 0);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_035: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_GET(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_GET_fails_when_index_out_of_bounds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_GET(uint32_t)(psa, 100);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_037: [ If the page is not allocated, PAGED_SPARSE_ARRAY_GET(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_GET_fails_when_page_not_allocated)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_GET(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_038: [ If the element at index is not allocated, PAGED_SPARSE_ARRAY_GET(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_GET_fails_when_element_not_allocated)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+    ASSERT_IS_NOT_NULL(ptr);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* result = PAGED_SPARSE_ARRAY_GET(uint32_t)(psa, 10); // Different element in same page\n+\n+    //assert\n+    ASSERT_IS_NULL(result);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Integration test - allocate and release multiple elements */\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_integration_allocate_release_reallocate)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act - allocate some elements\n+    uint32_t* ptr0 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 0);\n+    uint32_t* ptr5 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+    uint32_t* ptr20 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 20); // second page\n+\n+    ASSERT_IS_NOT_NULL(ptr0);\n+    ASSERT_IS_NOT_NULL(ptr5);\n+    ASSERT_IS_NOT_NULL(ptr20);\n+\n+    // Write values\n+    *ptr0 = 100;\n+    *ptr5 = 500;\n+    *ptr20 = 2000;\n+\n+    // Release one element from first page\n+    int result = PAGED_SPARSE_ARRAY_RELEASE(uint32_t)(psa, 0);\n+    ASSERT_ARE_EQUAL(int, 0, result);\n+    ASSERT_IS_NOT_NULL(psa->pages[0]); // Page should still exist\n+\n+    // Release remaining element from first page - page should be freed\n+    result = PAGED_SPARSE_ARRAY_RELEASE(uint32_t)(psa, 5);\n+    ASSERT_ARE_EQUAL(int, 0, result);\n+    ASSERT_IS_NULL(psa->pages[0]); // Page should now be freed\n+\n+    // Second page should still exist\n+    ASSERT_IS_NOT_NULL(psa->pages[1]);\n+\n+    // Re-allocate element 0 (should allocate new page)\n+    uint32_t* ptr0_new = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 0);\n+    ASSERT_IS_NOT_NULL(ptr0_new);\n+    ASSERT_IS_NOT_NULL(psa->pages[0]);\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Test with THANDLE type */\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_with_THANDLE_type_works)","path":"tests/paged_sparse_array_ut/paged_sparse_array_ut.c","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"fae1babc9fcbab5e561284cfff820db8e488b468","user":{"login":"dcristoloveanu","id":8507399,"node_id":"MDQ6VXNlcjg1MDczOTk=","avatar_url":"https://avatars.githubusercontent.com/u/8507399?v=4","gravatar_id":"","url":"https://api.github.com/users/dcristoloveanu","html_url":"https://github.com/dcristoloveanu","followers_url":"https://api.github.com/users/dcristoloveanu/followers","following_url":"https://api.github.com/users/dcristoloveanu/following{/other_user}","gists_url":"https://api.github.com/users/dcristoloveanu/gists{/gist_id}","starred_url":"https://api.github.com/users/dcristoloveanu/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dcristoloveanu/subscriptions","organizations_url":"https://api.github.com/users/dcristoloveanu/orgs","repos_url":"https://api.github.com/users/dcristoloveanu/repos","events_url":"https://api.github.com/users/dcristoloveanu/events{/privacy}","received_events_url":"https://api.github.com/users/dcristoloveanu/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"We should have a Tests tagged here as this is a unit test. #Resolved","created_at":"2026-01-11T07:03:29Z","updated_at":"2026-01-11T07:11:51Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2679289985","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2679289985"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2679289985"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2679289985/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":764,"original_line":778,"side":"RIGHT","author_association":"MEMBER","original_position":778,"position":764,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2679290411","pull_request_review_id":3647464667,"id":2679290411,"node_id":"PRRC_kwDODaUZTc6fsror","diff_hunk":"@@ -0,0 +1,826 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#include \"paged_sparse_array_ut_pch.h\"\n+\n+/*PAGED_SPARSE_ARRAY with regular types*/\n+PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(uint32_t)\n+\n+THANDLE_TYPE_DECLARE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(uint32_t));\n+THANDLE_TYPE_DEFINE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(uint32_t));\n+\n+PAGED_SPARSE_ARRAY_TYPE_DECLARE(uint32_t);\n+PAGED_SPARSE_ARRAY_TYPE_DEFINE(uint32_t);\n+\n+typedef struct B_TEST_TAG\n+{\n+    int b;\n+} B_TEST;\n+\n+PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(B_TEST)\n+THANDLE_TYPE_DECLARE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(B_TEST));\n+THANDLE_TYPE_DEFINE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(B_TEST));\n+\n+PAGED_SPARSE_ARRAY_TYPE_DECLARE(B_TEST);\n+PAGED_SPARSE_ARRAY_TYPE_DEFINE(B_TEST);\n+\n+typedef struct A_TEST_TAG\n+{\n+    int a;\n+} A_TEST;\n+\n+THANDLE_TYPE_DECLARE(A_TEST);\n+THANDLE_TYPE_DEFINE(A_TEST);\n+\n+PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(THANDLE(A_TEST))\n+THANDLE_TYPE_DECLARE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(THANDLE(A_TEST)));\n+THANDLE_TYPE_DEFINE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(THANDLE(A_TEST)));\n+\n+/*PAGED_SPARSE_ARRAY works with THANDLEs too*/\n+PAGED_SPARSE_ARRAY_TYPE_DECLARE(THANDLE(A_TEST));\n+PAGED_SPARSE_ARRAY_TYPE_DEFINE(THANDLE(A_TEST));\n+\n+MU_DEFINE_ENUM_STRINGS(UMOCK_C_ERROR_CODE, UMOCK_C_ERROR_CODE_VALUES)\n+\n+static void on_umock_c_error(UMOCK_C_ERROR_CODE error_code)\n+{\n+    ASSERT_FAIL(\"umock_c reported error :%\" PRI_MU_ENUM \"\", MU_ENUM_VALUE(UMOCK_C_ERROR_CODE, error_code));\n+}\n+\n+\n+BEGIN_TEST_SUITE(TEST_SUITE_NAME_FROM_CMAKE)\n+\n+TEST_SUITE_INITIALIZE(it_does_something)\n+{\n+    ASSERT_ARE_EQUAL(int, 0, real_gballoc_hl_init(NULL, NULL));\n+\n+    umock_c_init(on_umock_c_error);\n+\n+    REGISTER_GBALLOC_HL_GLOBAL_MOCK_HOOK();\n+}\n+\n+TEST_SUITE_CLEANUP(TestClassCleanup)\n+{\n+    umock_c_deinit();\n+\n+    real_gballoc_hl_deinit();\n+}\n+\n+TEST_FUNCTION_INITIALIZE(f)\n+{\n+    umock_c_negative_tests_init();\n+    umock_c_reset_all_calls();\n+}\n+\n+TEST_FUNCTION_CLEANUP(cleans)\n+{\n+    umock_c_negative_tests_deinit();\n+}\n+\n+/*PAGED_SPARSE_ARRAY_CREATE(T)*/\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_003: [ PAGED_SPARSE_ARRAY_CREATE(T) shall compute the number of pages as (max_size + page_size - 1) / page_size. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_004: [ PAGED_SPARSE_ARRAY_CREATE(T) shall call THANDLE_MALLOC_FLEX to allocate memory for the paged sparse array with the number of pages. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_005: [ PAGED_SPARSE_ARRAY_CREATE(T) shall set all page pointers to NULL. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_006: [ PAGED_SPARSE_ARRAY_CREATE(T) shall store max_size and page_size in the structure. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_008: [ PAGED_SPARSE_ARRAY_CREATE(T) shall succeed and return a non-NULL value. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_CREATE_with_uint32_t_type_succeeds)\n+{\n+    //arrange\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 2, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(uint32_t)*)));\n+\n+    //act\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 64);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(psa);\n+    ASSERT_ARE_EQUAL(uint64_t, 100, psa->max_size);\n+    ASSERT_ARE_EQUAL(uint32_t, 64, psa->page_size);\n+    ASSERT_ARE_EQUAL(uint32_t, 2, psa->page_count);\n+    for (uint32_t i = 0; i < psa->page_count; i++)\n+    {\n+        ASSERT_IS_NULL(psa->pages[i]);\n+    }\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_003: [ PAGED_SPARSE_ARRAY_CREATE(T) shall compute the number of pages as (max_size + page_size - 1) / page_size. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_008: [ PAGED_SPARSE_ARRAY_CREATE(T) shall succeed and return a non-NULL value. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_CREATE_computes_page_count_correctly)\n+{\n+    //arrange\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 1, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(uint32_t)*)));\n+\n+    //act\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(10, 64);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(psa);\n+    ASSERT_ARE_EQUAL(uint32_t, 1, psa->page_count);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_001: [ If max_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_CREATE_fails_when_max_size_is_zero)\n+{\n+    //arrange\n+\n+    //act\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(0, 64);\n+\n+    //assert\n+    ASSERT_IS_NULL(psa);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_002: [ If page_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_CREATE_fails_when_page_size_is_zero)\n+{\n+    //arrange\n+\n+    //act\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 0);\n+\n+    //assert\n+    ASSERT_IS_NULL(psa);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_007: [ If there are any errors, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_CREATE_fails_when_malloc_flex_fails)\n+{\n+    //arrange\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 2, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(uint32_t)*)))\n+        .SetReturn(NULL);\n+\n+    //act\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 64);\n+\n+    //assert\n+    ASSERT_IS_NULL(psa);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_008: [ PAGED_SPARSE_ARRAY_CREATE(T) shall succeed and return a non-NULL value. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_CREATE_with_struct_type_succeeds)\n+{\n+    //arrange\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 1, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(B_TEST)*)));\n+\n+    //act\n+    PAGED_SPARSE_ARRAY(B_TEST) psa = PAGED_SPARSE_ARRAY_CREATE(B_TEST)(10, 16);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(psa);\n+    ASSERT_ARE_EQUAL(uint64_t, 10, psa->max_size);\n+    ASSERT_ARE_EQUAL(uint32_t, 16, psa->page_size);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(B_TEST)(&psa, NULL);\n+}\n+\n+/*PAGED_SPARSE_ARRAY_ALLOCATE(T)*/\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_013: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall compute the page index as index / page_size. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_014: [ If the page is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall allocate memory for the page containing page_size elements and an allocation bitmap, and initialize all elements as not allocated. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_016: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall mark the element at index as allocated. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_017: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall return a pointer to the element at index. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_succeeds_first_element)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 16, sizeof(uint32_t)));\n+    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 0);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(ptr);\n+    ASSERT_IS_NOT_NULL(psa->pages[0]);\n+    ASSERT_ARE_EQUAL(uint32_t, 1, psa->pages[0]->allocated_count);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_014: [ If the page is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall allocate memory for the page containing page_size elements and an allocation bitmap, and initialize all elements as not allocated. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_017: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall return a pointer to the element at index. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_succeeds_second_page)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 16, sizeof(uint32_t)));\n+    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 20);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(ptr);\n+    ASSERT_IS_NULL(psa->pages[0]); // First page should not be allocated\n+    ASSERT_IS_NOT_NULL(psa->pages[1]); // Second page should be allocated\n+    ASSERT_ARE_EQUAL(uint32_t, 1, psa->pages[1]->allocated_count);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_017: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall return a pointer to the element at index. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_multiple_elements_in_same_page)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 16, sizeof(uint32_t)));\n+    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\n+\n+    //act\n+    uint32_t* ptr0 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 0);\n+    uint32_t* ptr5 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+    uint32_t* ptr10 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 10);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(ptr0);\n+    ASSERT_IS_NOT_NULL(ptr5);\n+    ASSERT_IS_NOT_NULL(ptr10);\n+    ASSERT_ARE_EQUAL(uint32_t, 3, psa->pages[0]->allocated_count);\n+    ASSERT_ARE_NOT_EQUAL(void_ptr, ptr0, ptr5);\n+    ASSERT_ARE_NOT_EQUAL(void_ptr, ptr5, ptr10);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_011: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_fails_when_handle_is_null)\n+{\n+    //arrange\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(NULL, 0);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_012: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_fails_when_index_equals_max_size)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 100);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_012: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_fails_when_index_greater_than_max_size)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 150);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_015: [ If the element at index is already allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_fails_when_already_allocated)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    uint32_t* ptr1 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+    ASSERT_IS_NOT_NULL(ptr1);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr2 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr2);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_018: [ If there are any errors, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_fails_when_page_malloc_fails)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 16, sizeof(uint32_t)))\n+        .SetReturn(NULL);\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 0);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_018: [ If there are any errors, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_fails_when_bitmap_malloc_fails)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 16, sizeof(uint32_t)));\n+    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG))\n+        .SetReturn(NULL);\n+    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 0);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/*PAGED_SPARSE_ARRAY_RELEASE(T)*/\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_021: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall compute the page index as index / page_size. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_024: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall mark the element at index as not allocated. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_025: [ If all elements in the page are now not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall free the page and set the page pointer to NULL. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_026: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall return zero on success. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_RELEASE_succeeds_and_frees_page_when_last_element)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+    ASSERT_IS_NOT_NULL(ptr);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // bitmap\n+    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // page\n+\n+    //act\n+    int result = PAGED_SPARSE_ARRAY_RELEASE(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_ARE_EQUAL(int, 0, result);\n+    ASSERT_IS_NULL(psa->pages[0]);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_024: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall mark the element at index as not allocated. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_026: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall return zero on success. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_RELEASE_succeeds_but_keeps_page_when_other_elements_allocated)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    uint32_t* ptr1 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+    uint32_t* ptr2 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 10);\n+    ASSERT_IS_NOT_NULL(ptr1);\n+    ASSERT_IS_NOT_NULL(ptr2);\n+    ASSERT_ARE_EQUAL(uint32_t, 2, psa->pages[0]->allocated_count);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    int result = PAGED_SPARSE_ARRAY_RELEASE(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_ARE_EQUAL(int, 0, result);\n+    ASSERT_IS_NOT_NULL(psa->pages[0]); // Page should still be allocated\n+    ASSERT_ARE_EQUAL(uint32_t, 1, psa->pages[0]->allocated_count);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_019: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_RELEASE_fails_when_handle_is_null)\n+{\n+    //arrange\n+\n+    //act\n+    int result = PAGED_SPARSE_ARRAY_RELEASE(uint32_t)(NULL, 0);\n+\n+    //assert\n+    ASSERT_ARE_NOT_EQUAL(int, 0, result);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_020: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_RELEASE_fails_when_index_out_of_bounds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    int result = PAGED_SPARSE_ARRAY_RELEASE(uint32_t)(psa, 100);\n+\n+    //assert\n+    ASSERT_ARE_NOT_EQUAL(int, 0, result);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_022: [ If the page is not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_RELEASE_fails_when_page_not_allocated)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    int result = PAGED_SPARSE_ARRAY_RELEASE(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_ARE_NOT_EQUAL(int, 0, result);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_023: [ If the element at index is not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_RELEASE_fails_when_element_not_allocated)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+    ASSERT_IS_NOT_NULL(ptr);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    int result = PAGED_SPARSE_ARRAY_RELEASE(uint32_t)(psa, 10); // Different element in same page\n+\n+    //assert\n+    ASSERT_ARE_NOT_EQUAL(int, 0, result);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/*PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T)*/\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_029: [ PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall compute the page index as index / page_size. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_030: [ If the page is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall allocate memory for the page containing page_size elements and an allocation bitmap, and initialize all elements as not allocated. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_031: [ If the element at index is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall mark it as allocated. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_032: [ PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall return a pointer to the element at index. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET_allocates_new_element)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 16, sizeof(uint32_t)));\n+    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(ptr);\n+    ASSERT_IS_NOT_NULL(psa->pages[0]);\n+    ASSERT_ARE_EQUAL(uint32_t, 1, psa->pages[0]->allocated_count);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_032: [ PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall return a pointer to the element at index. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET_returns_existing_element)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    uint32_t* ptr1 = PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(uint32_t)(psa, 5);\n+    ASSERT_IS_NOT_NULL(ptr1);\n+    *ptr1 = 12345;\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr2 = PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(ptr2);\n+    ASSERT_ARE_EQUAL(void_ptr, ptr1, ptr2);\n+    ASSERT_ARE_EQUAL(uint32_t, 12345, *ptr2);\n+    ASSERT_ARE_EQUAL(uint32_t, 1, psa->pages[0]->allocated_count); // Count should not have changed\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_027: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET_fails_when_handle_is_null)\n+{\n+    //arrange\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(uint32_t)(NULL, 0);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_028: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET_fails_when_index_out_of_bounds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(uint32_t)(psa, 100);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_033: [ If there are any errors, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET_fails_when_page_malloc_fails)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(malloc_flex(IGNORED_ARG, 16, sizeof(uint32_t)))\n+        .SetReturn(NULL);\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(uint32_t)(psa, 0);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/*PAGED_SPARSE_ARRAY_GET(T)*/\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_036: [ PAGED_SPARSE_ARRAY_GET(T) shall compute the page index as index / page_size. ]*/\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_039: [ PAGED_SPARSE_ARRAY_GET(T) shall return a pointer to the element at index. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_GET_succeeds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    uint32_t* ptr1 = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+    ASSERT_IS_NOT_NULL(ptr1);\n+    *ptr1 = 42;\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr2 = PAGED_SPARSE_ARRAY_GET(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(ptr2);\n+    ASSERT_ARE_EQUAL(void_ptr, ptr1, ptr2);\n+    ASSERT_ARE_EQUAL(uint32_t, 42, *ptr2);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_034: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_GET(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_GET_fails_when_handle_is_null)\n+{\n+    //arrange\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_GET(uint32_t)(NULL, 0);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_035: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_GET(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_GET_fails_when_index_out_of_bounds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_GET(uint32_t)(psa, 100);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_037: [ If the page is not allocated, PAGED_SPARSE_ARRAY_GET(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_GET_fails_when_page_not_allocated)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_GET(uint32_t)(psa, 5);\n+\n+    //assert\n+    ASSERT_IS_NULL(ptr);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Tests_SRS_PAGED_SPARSE_ARRAY_88_038: [ If the element at index is not allocated, PAGED_SPARSE_ARRAY_GET(T) shall fail and return NULL. ]*/\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_GET_fails_when_element_not_allocated)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(uint32_t) psa = PAGED_SPARSE_ARRAY_CREATE(uint32_t)(100, 16);\n+    ASSERT_IS_NOT_NULL(psa);\n+    uint32_t* ptr = PAGED_SPARSE_ARRAY_ALLOCATE(uint32_t)(psa, 5);\n+    ASSERT_IS_NOT_NULL(ptr);\n+    umock_c_reset_all_calls();\n+\n+    //act\n+    uint32_t* result = PAGED_SPARSE_ARRAY_GET(uint32_t)(psa, 10); // Different element in same page\n+\n+    //assert\n+    ASSERT_IS_NULL(result);\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    //clean\n+    PAGED_SPARSE_ARRAY_ASSIGN(uint32_t)(&psa, NULL);\n+}\n+\n+/* Integration test - allocate and release multiple elements */","path":"tests/paged_sparse_array_ut/paged_sparse_array_ut.c","commit_id":"fae1babc9fcbab5e561284cfff820db8e488b468","original_commit_id":"fae1babc9fcbab5e561284cfff820db8e488b468","user":{"login":"dcristoloveanu","id":8507399,"node_id":"MDQ6VXNlcjg1MDczOTk=","avatar_url":"https://avatars.githubusercontent.com/u/8507399?v=4","gravatar_id":"","url":"https://api.github.com/users/dcristoloveanu","html_url":"https://github.com/dcristoloveanu","followers_url":"https://api.github.com/users/dcristoloveanu/followers","following_url":"https://api.github.com/users/dcristoloveanu/following{/other_user}","gists_url":"https://api.github.com/users/dcristoloveanu/gists{/gist_id}","starred_url":"https://api.github.com/users/dcristoloveanu/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dcristoloveanu/subscriptions","organizations_url":"https://api.github.com/users/dcristoloveanu/orgs","repos_url":"https://api.github.com/users/dcristoloveanu/repos","events_url":"https://api.github.com/users/dcristoloveanu/events{/privacy}","received_events_url":"https://api.github.com/users/dcristoloveanu/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"This is called to be an integration test, check that an equivalent test exists in the int test suite. If it does this test can be removed. #Resolved","created_at":"2026-01-11T07:04:25Z","updated_at":"2026-01-11T07:12:06Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2679290411","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2679290411"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2679290411"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2679290411/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":733,"side":"RIGHT","author_association":"MEMBER","original_position":733,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2680949604","pull_request_review_id":3649254039,"id":2680949604,"node_id":"PRRC_kwDODaUZTc6fzAtk","diff_hunk":"@@ -0,0 +1,433 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#ifndef PAGED_SPARSE_ARRAY_LL_H\n+#define PAGED_SPARSE_ARRAY_LL_H\n+\n+#ifdef __cplusplus\n+#include <cinttypes>\n+#include <cstdlib>\n+#else // __cplusplus\n+#include <inttypes.h>\n+#include <stdlib.h>\n+#endif // __cplusplus\n+\n+#include \"c_pal/gballoc_hl.h\"\n+#include \"c_pal/gballoc_hl_redirect.h\"\n+\n+#include \"macro_utils/macro_utils.h\"\n+\n+#include \"c_logging/logger.h\"\n+\n+#include \"c_pal/thandle_ll.h\"\n+\n+#include \"umock_c/umock_c_prod.h\"\n+\n+/*PAGED_SPARSE_ARRAY is backed by a THANDLE build on the structure below*/\n+#define PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T), _TAG)\n+\n+#define PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_STRUCT_, T)\n+\n+/*PAGE_STRUCT holds a single page with elements and allocation bitmap*/\n+#define PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T), _TAG)\n+#define PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_STRUCT_, T)\n+\n+/*PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) introduces the base type that holds the paged sparse array*/\n+#define PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(T)                                                                      \\\n+/*define the page structure first*/                                                                                    \\\n+typedef struct PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T)                                                         \\\n+{                                                                                                                      \\\n+    uint32_t allocated_count;                                                                                          \\\n+    uint8_t* allocation_bitmap;                                                                                        \\\n+    T items[];                                                                                                         \\\n+} PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T);                                                                             \\\n+/*forward define the typedef of the PAGED_SPARSE_ARRAY struct so that it can be used for a function pointer definition*/\\\n+typedef struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T);                          \\\n+struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T)                                                                      \\\n+{                                                                                                                      \\\n+    uint64_t max_size;                                                                                                 \\\n+    uint32_t page_size;                                                                                                \\\n+    uint32_t page_count;                                                                                               \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* pages[];                                                                  \\\n+};                                                                                                                     \\\n+\n+/*PAGED_SPARSE_ARRAY is-a THANDLE*/\n+/*given a type \"T\" PAGED_SPARSE_ARRAY_LL(T) expands to the name of the type. */\n+#define PAGED_SPARSE_ARRAY_LL(T) THANDLE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*because PAGED_SPARSE_ARRAY is a THANDLE, all THANDLE's macro APIs are useable with PAGED_SPARSE_ARRAY.*/\n+/*the below are just shortcuts of THANDLE's public ones*/\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE(T) THANDLE_INITIALIZE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_ASSIGN(T) THANDLE_ASSIGN(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_MOVE(T) THANDLE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE_MOVE(T) THANDLE_INITIALIZE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*introduces a new name for a function that returns a PAGED_SPARSE_ARRAY_LL(T)*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_CREATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_CREATE(C) PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C)\n+\n+/*introduces a name for the function that frees a PAGED_SPARSE_ARRAY when its ref count goes to 0*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_FREE_, C)\n+\n+/*introduces a name for the allocate function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C)\n+\n+/*introduces a name for the release function*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_RELEASE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE(C) PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C)\n+\n+/*introduces a name for the allocate_or_get function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C)\n+\n+/*introduces a name for the get function*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_GET(C) PAGED_SPARSE_ARRAY_LL_GET_NAME(C)\n+\n+/*introduces a function declaration for paged_sparse_array_create*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, PAGED_SPARSE_ARRAY_LL(T), PAGED_SPARSE_ARRAY_LL_CREATE(C), uint64_t, max_size, uint32_t, page_size);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint64_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_release*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, int, PAGED_SPARSE_ARRAY_LL_RELEASE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint64_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate_or_get*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint64_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_get*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint64_t, index);\n+\n+/*helper to compute bitmap size in bytes (1 bit per element, rounded up to nearest byte)*/\n+#define PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size) (((page_size) + 7) / 8)\n+\n+/*helper to check if an element is allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_IS_ALLOCATED(bitmap, index_in_page) \\\n+    (((bitmap)[(index_in_page) / 8] & (1 << ((index_in_page) % 8))) != 0)\n+\n+/*helper to set an element as allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_SET_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] |= (1 << ((index_in_page) % 8)))\n+\n+/*helper to clear an element as not allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_CLEAR_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] &= ~(1 << ((index_in_page) % 8)))\n+\n+/*introduces a function definition for freeing the allocated resources for a PAGED_SPARSE_ARRAY*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_DEFINE(C, T)                                                                               \\\n+static void PAGED_SPARSE_ARRAY_LL_FREE_NAME(C)(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* paged_sparse_array)                        \\\n+{                                                                                                                              \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_009: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_FREE(T) shall return. ]*/      \\\n+    if (paged_sparse_array == NULL)                                                                                            \\\n+    {                                                                                                                          \\\n+        LogError(\"invalid arguments \" MU_TOSTRING(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)) \"* paged_sparse_array=%p\",               \\\n+            paged_sparse_array);                                                                                               \\\n+    }                                                                                                                          \\\n+    else                                                                                                                       \\\n+    {                                                                                                                          \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_010: [ PAGED_SPARSE_ARRAY_FREE(T) shall free all pages that are non-NULL. ]*/       \\\n+        for (uint32_t i = 0; i < paged_sparse_array->page_count; i++)                                                          \\\n+        {                                                                                                                      \\\n+            if (paged_sparse_array->pages[i] != NULL)                                                                          \\\n+            {                                                                                                                  \\\n+                free((void*)paged_sparse_array->pages[i]->allocation_bitmap);                                                  \\\n+                free((void*)paged_sparse_array->pages[i]);                                                                     \\\n+            }                                                                                                                  \\\n+        }                                                                                                                      \\\n+    }                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DEFINE(C, T)                                                                                                                        \\\n+PAGED_SPARSE_ARRAY_LL(T) PAGED_SPARSE_ARRAY_LL_CREATE(C)(uint64_t max_size, uint32_t page_size)                                                                          \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* result;                                                                                                                           \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_001: [ If max_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                           \\\n+    if (max_size == 0)                                                                                                                                                    \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint64_t max_size=%\" PRIu64 \"\", max_size);                                                                                           \\\n+    }                                                                                                                                                                     \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_002: [ If page_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                          \\\n+    else if (page_size == 0)                                                                                                                                              \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t page_size=%\" PRIu32 \"\", page_size);                                                                                         \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_003: [ PAGED_SPARSE_ARRAY_CREATE(T) shall compute the number of pages as (max_size + page_size - 1) / page_size. ]*/           \\\n+        uint64_t page_count_64 = (max_size + page_size - 1) / page_size;                                                                                                  \\\n+        if (page_count_64 > UINT32_MAX)                                                                                                                                   \\\n+        {                                                                                                                                                                 \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_007: [ If there are any errors, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                               \\\n+            LogError(\"page_count overflow: uint64_t max_size=%\" PRIu64 \", uint32_t page_size=%\" PRIu32 \"\", max_size, page_size);                                          \\\n+        }                                                                                                                                                                 \\\n+        else                                                                                                                                                              \\\n+        {                                                                                                                                                                 \\\n+            uint32_t page_count = (uint32_t)page_count_64;                                                                                                                \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_004: [ PAGED_SPARSE_ARRAY_CREATE(T) shall call THANDLE_MALLOC_FLEX to allocate memory for the paged sparse array with the number of pages. ]*/ \\\n+            result = THANDLE_MALLOC_FLEX(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(PAGED_SPARSE_ARRAY_LL_FREE_NAME(C), page_count, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)*)); \\\n+            if (result == NULL)                                                                                                                                           \\\n+            {                                                                                                                                                             \\\n+                /* Codes_SRS_PAGED_SPARSE_ARRAY_88_007: [ If there are any errors, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                           \\\n+                LogError(\"failure in THANDLE_MALLOC_FLEX page_count=%\" PRIu32 \", sizeof(PAGED_SPARSE_ARRAY_PAGE*)=%zu\", page_count, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)*)); \\\n+            }                                                                                                                                                             \\\n+            else                                                                                                                                                          \\\n+            {                                                                                                                                                             \\\n+                /* Codes_SRS_PAGED_SPARSE_ARRAY_88_006: [ PAGED_SPARSE_ARRAY_CREATE(T) shall store max_size and page_size in the structure. ]*/                           \\\n+                result->max_size = max_size;                                                                                                                              \\\n+                result->page_size = page_size;                                                                                                                            \\\n+                result->page_count = page_count;                                                                                                                          \\\n+                /* Codes_SRS_PAGED_SPARSE_ARRAY_88_005: [ PAGED_SPARSE_ARRAY_CREATE(T) shall set all page pointers to NULL. ]*/                                           \\\n+                for (uint32_t i = 0; i < page_count; i++)                                                                                                                 \\\n+                {                                                                                                                                                         \\\n+                    result->pages[i] = NULL;                                                                                                                              \\\n+                }                                                                                                                                                         \\\n+                /* Codes_SRS_PAGED_SPARSE_ARRAY_88_008: [ PAGED_SPARSE_ARRAY_CREATE(T) shall succeed and return a non-NULL value. ]*/                                     \\\n+                goto all_ok;                                                                                                                                              \\\n+            }                                                                                                                                                             \\\n+        }                                                                                                                                                                 \\\n+    }                                                                                                                                                                     \\\n+    result = NULL;                                                                                                                                                        \\\n+all_ok:                                                                                                                                                                   \\\n+    return result;                                                                                                                                                        \\\n+}\n+\n+/*internal helper to allocate a page*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_, C)\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_DEFINE(C, T)                                                                                                        \\\n+static PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(uint32_t page_size)                                                 \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* page;                                                                                                                        \\\n+    page = malloc_flex(sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)), page_size, sizeof(T));                                                                            \\\n+    if (page == NULL)                                                                                                                                                     \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"failure in malloc_flex for page, page_size=%\" PRIu32 \", sizeof(\" MU_TOSTRING(T) \")=%zu\", page_size, sizeof(T));                                         \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        size_t bitmap_size = PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size);                                                                                                   \\\n+        page->allocation_bitmap = malloc(bitmap_size);                                                                                                                    \\\n+        if (page->allocation_bitmap == NULL)                                                                                                                              \\\n+        {                                                                                                                                                                 \\\n+            LogError(\"failure in malloc for allocation_bitmap, bitmap_size=%zu\", bitmap_size);                                                                            \\\n+            free(page);                                                                                                                                                   \\\n+            page = NULL;                                                                                                                                                  \\\n+        }                                                                                                                                                                 \\\n+        else                                                                                                                                                              \\\n+        {                                                                                                                                                                 \\\n+            /* Initialize bitmap to all zeros (nothing allocated) */                                                                                                      \\\n+            (void)memset(page->allocation_bitmap, 0, bitmap_size);                                                                                                        \\\n+            page->allocated_count = 0;                                                                                                                                    \\\n+        }                                                                                                                                                                 \\\n+    }                                                                                                                                                                     \\\n+    return page;                                                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DEFINE(C, T)                                                                                                                       \\\n+T* PAGED_SPARSE_ARRAY_LL_ALLOCATE(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint64_t index)                                                                         \\\n+{                                                                                                                                                                          \\\n+    T* result;                                                                                                                                                             \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_011: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                               \\\n+    if (paged_sparse_array == NULL)                                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: PAGED_SPARSE_ARRAY(\" MU_TOSTRING(T) \") paged_sparse_array=%p\", paged_sparse_array);                                                   \\\n+    }                                                                                                                                                                      \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_012: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/               \\\n+    else if (index >= paged_sparse_array->max_size)                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: uint64_t index=%\" PRIu64 \" out of bound, max_size=%\" PRIu64 \"\", index, paged_sparse_array->max_size);                                 \\\n+    }                                                                                                                                                                      \\\n+    else                                                                                                                                                                   \\\n+    {                                                                                                                                                                      \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_013: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall compute the page index as index / page_size. ]*/                                   \\\n+        uint32_t page_index = (uint32_t)(index / paged_sparse_array->page_size);                                                                                           \\\n+        uint32_t index_in_page = (uint32_t)(index % paged_sparse_array->page_size);                                                                                        \\\n+        PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* array = THANDLE_GET_T(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(paged_sparse_array);                                                 \\\n+                                                                                                                                                                           \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_014: [ If the page is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall allocate memory for the page containing page_size elements and an allocation bitmap, and initialize all elements as not allocated. ]*/ \\\n+        if (array->pages[page_index] == NULL)                                                                                                                              \\\n+        {                                                                                                                                                                  \\\n+            array->pages[page_index] = PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(paged_sparse_array->page_size);                                                \\\n+            if (array->pages[page_index] == NULL)                                                                                                                          \\\n+            {                                                                                                                                                              \\\n+                /* Codes_SRS_PAGED_SPARSE_ARRAY_88_018: [ If there are any errors, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                         \\\n+                LogError(\"failure allocating page at page_index=%\" PRIu32 \"\", page_index);                                                                                 \\\n+                goto error;                                                                                                                                                \\\n+            }                                                                                                                                                              \\\n+        }                                                                                                                                                                  \\\n+                                                                                                                                                                           \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_015: [ If the element at index is already allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/            \\\n+        if (PAGED_SPARSE_ARRAY_IS_ALLOCATED(array->pages[page_index]->allocation_bitmap, index_in_page))                                                                   \\\n+        {                                                                                                                                                                  \\\n+            LogError(\"Element at index=%\" PRIu64 \" is already allocated\", index);                                                                                          \\\n+        }                                                                                                                                                                  \\\n+        else                                                                                                                                                               \\\n+        {                                                                                                                                                                  \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_016: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall mark the element at index as allocated. ]*/                                    \\\n+            PAGED_SPARSE_ARRAY_SET_ALLOCATED(array->pages[page_index]->allocation_bitmap, index_in_page);                                                                  \\\n+            array->pages[page_index]->allocated_count++;                                                                                                                   \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_017: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall return a pointer to the element at index. ]*/                                  \\\n+            result = &array->pages[page_index]->items[index_in_page];                                                                                                      \\\n+            goto all_ok;                                                                                                                                                   \\\n+        }                                                                                                                                                                  \\\n+    }                                                                                                                                                                      \\\n+error:                                                                                                                                                                     \\\n+    result = NULL;                                                                                                                                                         \\\n+all_ok:                                                                                                                                                                    \\\n+    return result;                                                                                                                                                         \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DEFINE(C, T)                                                                                                                         \\\n+int PAGED_SPARSE_ARRAY_LL_RELEASE(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint64_t index)                                                                          \\\n+{                                                                                                                                                                           \\\n+    int result;                                                                                                                                                             \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_019: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/                     \\\n+    if (paged_sparse_array == NULL)                                                                                                                                         \\\n+    {                                                                                                                                                                       \\\n+        LogError(\"Invalid arguments: PAGED_SPARSE_ARRAY(\" MU_TOSTRING(T) \") paged_sparse_array=%p\", paged_sparse_array);                                                    \\\n+        result = MU_FAILURE;                                                                                                                                                \\\n+    }                                                                                                                                                                       \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_020: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/     \\\n+    else if (index >= paged_sparse_array->max_size)                                                                                                                         \\\n+    {                                                                                                                                                                       \\\n+        LogError(\"Invalid arguments: uint64_t index=%\" PRIu64 \" out of bound, max_size=%\" PRIu64 \"\", index, paged_sparse_array->max_size);                                  \\\n+        result = MU_FAILURE;                                                                                                                                                \\\n+    }                                                                                                                                                                       \\\n+    else                                                                                                                                                                    \\\n+    {                                                                                                                                                                       \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_021: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall compute the page index as index / page_size. ]*/                                     \\\n+        uint32_t page_index = (uint32_t)(index / paged_sparse_array->page_size);                                                                                            \\\n+        uint32_t index_in_page = (uint32_t)(index % paged_sparse_array->page_size);                                                                                         \\\n+        PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* array = THANDLE_GET_T(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(paged_sparse_array);                                                  \\\n+                                                                                                                                                                            \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_022: [ If the page is not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/                  \\\n+        if (array->pages[page_index] == NULL)                                                                                                                               \\\n+        {                                                                                                                                                                   \\\n+            LogError(\"Page at page_index=%\" PRIu32 \" is not allocated\", page_index);                                                                                        \\\n+            result = MU_FAILURE;                                                                                                                                            \\\n+        }                                                                                                                                                                   \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_023: [ If the element at index is not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/      \\\n+        else if (!PAGED_SPARSE_ARRAY_IS_ALLOCATED(array->pages[page_index]->allocation_bitmap, index_in_page))                                                              \\\n+        {                                                                                                                                                                   \\\n+            LogError(\"Element at index=%\" PRIu64 \" is not allocated\", index);                                                                                               \\\n+            result = MU_FAILURE;                                                                                                                                            \\\n+        }                                                                                                                                                                   \\\n+        else                                                                                                                                                                \\\n+        {                                                                                                                                                                   \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_024: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall mark the element at index as not allocated. ]*/                                  \\\n+            PAGED_SPARSE_ARRAY_CLEAR_ALLOCATED(array->pages[page_index]->allocation_bitmap, index_in_page);                                                                 \\\n+            array->pages[page_index]->allocated_count--;                                                                                                                    \\\n+                                                                                                                                                                            \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_025: [ If all elements in the page are now not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall free the page and set the page pointer to NULL. ]*/ \\\n+            if (array->pages[page_index]->allocated_count == 0)                                                                                                             \\\n+            {                                                                                                                                                               \\\n+                free((void*)array->pages[page_index]->allocation_bitmap);                                                                                                   \\\n+                free((void*)array->pages[page_index]);                                                                                                                      \\\n+                array->pages[page_index] = NULL;                                                                                                                            \\\n+            }                                                                                                                                                               \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_026: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall return zero on success. ]*/                                                       \\\n+            result = 0;                                                                                                                                                     \\\n+        }                                                                                                                                                                   \\\n+    }                                                                                                                                                                       \\\n+    return result;                                                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DEFINE(C, T)                                                                                                                 \\\n+T* PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint64_t index)                                                                   \\\n+{                                                                                                                                                                           \\\n+    T* result;                                                                                                                                                              \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_027: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/                         \\\n+    if (paged_sparse_array == NULL)                                                                                                                                         \\\n+    {                                                                                                                                                                       \\\n+        LogError(\"Invalid arguments: PAGED_SPARSE_ARRAY(\" MU_TOSTRING(T) \") paged_sparse_array=%p\", paged_sparse_array);                                                    \\\n+    }                                                                                                                                                                       \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_028: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/         \\\n+    else if (index >= paged_sparse_array->max_size)                                                                                                                         \\\n+    {                                                                                                                                                                       \\\n+        LogError(\"Invalid arguments: uint64_t index=%\" PRIu64 \" out of bound, max_size=%\" PRIu64 \"\", index, paged_sparse_array->max_size);                                  \\\n+    }                                                                                                                                                                       \\\n+    else                                                                                                                                                                    \\\n+    {                                                                                                                                                                       \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_029: [ PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall compute the page index as index / page_size. ]*/                             \\\n+        uint32_t page_index = (uint32_t)(index / paged_sparse_array->page_size);                                                                                            \\\n+        uint32_t index_in_page = (uint32_t)(index % paged_sparse_array->page_size);                                                                                         \\\n+        PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* array = THANDLE_GET_T(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(paged_sparse_array);                                                  \\\n+                                                                                                                                                                            \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_030: [ If the page is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall allocate memory for the page containing page_size elements and an allocation bitmap, and initialize all elements as not allocated. ]*/ \\\n+        if (array->pages[page_index] == NULL)                                                                                                                               \\\n+        {                                                                                                                                                                   \\\n+            array->pages[page_index] = PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(paged_sparse_array->page_size);                                                 \\\n+            if (array->pages[page_index] == NULL)                                                                                                                           \\\n+            {                                                                                                                                                               \\\n+                /* Codes_SRS_PAGED_SPARSE_ARRAY_88_033: [ If there are any errors, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/                   \\\n+                LogError(\"failure allocating page at page_index=%\" PRIu32 \"\", page_index);                                                                                  \\\n+                goto error;                                                                                                                                                 \\\n+            }                                                                                                                                                               \\\n+        }                                                                                                                                                                   \\\n+                                                                                                                                                                            \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_031: [ If the element at index is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall mark it as allocated. ]*/          \\\n+        if (!PAGED_SPARSE_ARRAY_IS_ALLOCATED(array->pages[page_index]->allocation_bitmap, index_in_page))                                                                   \\\n+        {                                                                                                                                                                   \\\n+            PAGED_SPARSE_ARRAY_SET_ALLOCATED(array->pages[page_index]->allocation_bitmap, index_in_page);                                                                   \\\n+            array->pages[page_index]->allocated_count++;                                                                                                                    \\\n+        }                                                                                                                                                                   \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_032: [ PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall return a pointer to the element at index. ]*/                                \\\n+        result = &array->pages[page_index]->items[index_in_page];                                                                                                           \\\n+        goto all_ok;                                                                                                                                                        \\\n+    }                                                                                                                                                                       \\\n+error:                                                                                                                                                                      \\\n+    result = NULL;                                                                                                                                                          \\\n+all_ok:                                                                                                                                                                     \\\n+    return result;                                                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_GET_DEFINE(C, T)                                                                                                                              \\\n+T* PAGED_SPARSE_ARRAY_LL_GET(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint64_t index)                                                                                \\","path":"inc/c_util/paged_sparse_array_ll.h","commit_id":"1d862a888f8d0679875ed501eee2c38ca591158d","original_commit_id":"5c92197b8815309ecd18156c38b52a5eb594c75b","user":{"login":"dcristoloveanu","id":8507399,"node_id":"MDQ6VXNlcjg1MDczOTk=","avatar_url":"https://avatars.githubusercontent.com/u/8507399?v=4","gravatar_id":"","url":"https://api.github.com/users/dcristoloveanu","html_url":"https://github.com/dcristoloveanu","followers_url":"https://api.github.com/users/dcristoloveanu/followers","following_url":"https://api.github.com/users/dcristoloveanu/following{/other_user}","gists_url":"https://api.github.com/users/dcristoloveanu/gists{/gist_id}","starred_url":"https://api.github.com/users/dcristoloveanu/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dcristoloveanu/subscriptions","organizations_url":"https://api.github.com/users/dcristoloveanu/orgs","repos_url":"https://api.github.com/users/dcristoloveanu/repos","events_url":"https://api.github.com/users/dcristoloveanu/events{/privacy}","received_events_url":"https://api.github.com/users/dcristoloveanu/received_events","type":"User","user_view_type":"public","site_admin":false},"body":">uint64_t [](http://example.com/codeflow?start=77&length=8)\r\n\r\nI think the indexes should be uint32_t. In all APIs #Resolved","created_at":"2026-01-12T05:51:20Z","updated_at":"2026-01-12T06:04:22Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2680949604","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2680949604"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2680949604"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2680949604/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":392,"side":"RIGHT","author_association":"MEMBER","original_position":392,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2680985269","pull_request_review_id":3649292033,"id":2680985269,"node_id":"PRRC_kwDODaUZTc6fzJa1","diff_hunk":"@@ -0,0 +1,424 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#ifndef PAGED_SPARSE_ARRAY_LL_H\n+#define PAGED_SPARSE_ARRAY_LL_H\n+\n+#ifdef __cplusplus\n+#include <cinttypes>\n+#include <cstdlib>\n+#else // __cplusplus\n+#include <inttypes.h>\n+#include <stdlib.h>\n+#endif // __cplusplus\n+\n+#include \"c_pal/gballoc_hl.h\"\n+#include \"c_pal/gballoc_hl_redirect.h\"\n+\n+#include \"macro_utils/macro_utils.h\"\n+\n+#include \"c_logging/logger.h\"\n+\n+#include \"c_pal/thandle_ll.h\"\n+\n+#include \"umock_c/umock_c_prod.h\"\n+\n+/*PAGED_SPARSE_ARRAY is backed by a THANDLE build on the structure below*/\n+#define PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T), _TAG)\n+\n+#define PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_STRUCT_, T)\n+\n+/*PAGE_STRUCT holds a single page with elements and allocation bitmap*/\n+#define PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T), _TAG)\n+#define PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_STRUCT_, T)\n+\n+/*PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) introduces the base type that holds the paged sparse array*/\n+#define PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(T)                                                                      \\\n+/*define the page structure first*/                                                                                    \\\n+typedef struct PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T)                                                         \\\n+{                                                                                                                      \\\n+    uint32_t allocated_count;                                                                                          \\\n+    uint8_t* allocation_bitmap;                                                                                        \\\n+    T items[];                                                                                                         \\\n+} PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T);                                                                             \\\n+/*forward define the typedef of the PAGED_SPARSE_ARRAY struct so that it can be used for a function pointer definition*/\\\n+typedef struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T);                          \\\n+struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T)                                                                      \\\n+{                                                                                                                      \\\n+    uint32_t max_size;                                                                                                 \\\n+    uint32_t page_size;                                                                                                \\\n+    uint32_t page_count;                                                                                               \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* pages[];                                                                  \\\n+};                                                                                                                     \\\n+\n+/*PAGED_SPARSE_ARRAY is-a THANDLE*/\n+/*given a type \"T\" PAGED_SPARSE_ARRAY_LL(T) expands to the name of the type. */\n+#define PAGED_SPARSE_ARRAY_LL(T) THANDLE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*because PAGED_SPARSE_ARRAY is a THANDLE, all THANDLE's macro APIs are useable with PAGED_SPARSE_ARRAY.*/\n+/*the below are just shortcuts of THANDLE's public ones*/\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE(T) THANDLE_INITIALIZE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_ASSIGN(T) THANDLE_ASSIGN(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_MOVE(T) THANDLE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE_MOVE(T) THANDLE_INITIALIZE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*introduces a new name for a function that returns a PAGED_SPARSE_ARRAY_LL(T)*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_CREATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_CREATE(C) PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C)\n+\n+/*introduces a name for the function that frees a PAGED_SPARSE_ARRAY when its ref count goes to 0*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_FREE_, C)\n+\n+/*introduces a name for the allocate function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C)\n+\n+/*introduces a name for the release function*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_RELEASE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE(C) PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C)\n+\n+/*introduces a name for the allocate_or_get function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C)\n+\n+/*introduces a name for the get function*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_GET(C) PAGED_SPARSE_ARRAY_LL_GET_NAME(C)\n+\n+/*introduces a function declaration for paged_sparse_array_create*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, PAGED_SPARSE_ARRAY_LL(T), PAGED_SPARSE_ARRAY_LL_CREATE(C), uint32_t, max_size, uint32_t, page_size);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_release*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, int, PAGED_SPARSE_ARRAY_LL_RELEASE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate_or_get*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_get*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*helper to compute bitmap size in bytes (1 bit per element, rounded up to nearest byte)*/\n+#define PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size) (((page_size) + 7) / 8)\n+\n+/*helper to check if an element is allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_IS_ALLOCATED(bitmap, index_in_page) \\\n+    (((bitmap)[(index_in_page) / 8] & (1 << ((index_in_page) % 8))) != 0)\n+\n+/*helper to set an element as allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_SET_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] |= (1 << ((index_in_page) % 8)))\n+\n+/*helper to clear an element as not allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_CLEAR_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] &= ~(1 << ((index_in_page) % 8)))\n+\n+/*introduces a function definition for freeing the allocated resources for a PAGED_SPARSE_ARRAY*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_DEFINE(C, T)                                                                               \\\n+static void PAGED_SPARSE_ARRAY_LL_FREE_NAME(C)(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* paged_sparse_array)                        \\\n+{                                                                                                                              \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_009: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_FREE(T) shall return. ]*/      \\\n+    if (paged_sparse_array == NULL)                                                                                            \\\n+    {                                                                                                                          \\\n+        LogError(\"invalid arguments \" MU_TOSTRING(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)) \"* paged_sparse_array=%p\",               \\\n+            paged_sparse_array);                                                                                               \\\n+    }                                                                                                                          \\\n+    else                                                                                                                       \\\n+    {                                                                                                                          \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_010: [ PAGED_SPARSE_ARRAY_FREE(T) shall free all pages that are non-NULL. ]*/       \\\n+        for (uint32_t i = 0; i < paged_sparse_array->page_count; i++)                                                          \\\n+        {                                                                                                                      \\\n+            if (paged_sparse_array->pages[i] != NULL)                                                                          \\\n+            {                                                                                                                  \\\n+                free((void*)paged_sparse_array->pages[i]->allocation_bitmap);                                                  \\\n+                free((void*)paged_sparse_array->pages[i]);                                                                     \\\n+            }                                                                                                                  \\\n+        }                                                                                                                      \\\n+    }                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DEFINE(C, T)                                                                                                                        \\\n+PAGED_SPARSE_ARRAY_LL(T) PAGED_SPARSE_ARRAY_LL_CREATE(C)(uint32_t max_size, uint32_t page_size)                                                                          \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* result;                                                                                                                           \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_001: [ If max_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                           \\\n+    if (max_size == 0)                                                                                                                                                    \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t max_size=%\" PRIu32 \"\", max_size);                                                                                           \\\n+    }                                                                                                                                                                     \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_002: [ If page_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                          \\\n+    else if (page_size == 0)                                                                                                                                              \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t page_size=%\" PRIu32 \"\", page_size);                                                                                         \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_003: [ PAGED_SPARSE_ARRAY_CREATE(T) shall compute the number of pages as (max_size + page_size - 1) / page_size. ]*/           \\\n+        uint32_t page_count = (max_size + page_size - 1) / page_size;                                                                                                     \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_004: [ PAGED_SPARSE_ARRAY_CREATE(T) shall call THANDLE_MALLOC_FLEX to allocate memory for the paged sparse array with the number of pages. ]*/ \\\n+        result = THANDLE_MALLOC_FLEX(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(PAGED_SPARSE_ARRAY_LL_FREE_NAME(C), page_count, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)*)); \\\n+        if (result == NULL)                                                                                                                                               \\\n+        {                                                                                                                                                                 \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_007: [ If there are any errors, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                               \\\n+            LogError(\"failure in THANDLE_MALLOC_FLEX page_count=%\" PRIu32 \", sizeof(PAGED_SPARSE_ARRAY_PAGE*)=%zu\", page_count, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)*)); \\\n+        }                                                                                                                                                                 \\\n+        else                                                                                                                                                              \\\n+        {                                                                                                                                                                 \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_006: [ PAGED_SPARSE_ARRAY_CREATE(T) shall store max_size and page_size in the structure. ]*/                               \\\n+            result->max_size = max_size;                                                                                                                                  \\\n+            result->page_size = page_size;                                                                                                                                \\\n+            result->page_count = page_count;                                                                                                                              \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_005: [ PAGED_SPARSE_ARRAY_CREATE(T) shall set all page pointers to NULL. ]*/                                               \\\n+            for (uint32_t i = 0; i < page_count; i++)                                                                                                                     \\\n+            {                                                                                                                                                             \\\n+                result->pages[i] = NULL;                                                                                                                                  \\\n+            }                                                                                                                                                             \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_008: [ PAGED_SPARSE_ARRAY_CREATE(T) shall succeed and return a non-NULL value. ]*/                                         \\\n+            goto all_ok;                                                                                                                                                  \\\n+        }                                                                                                                                                                 \\\n+    }                                                                                                                                                                     \\\n+    result = NULL;                                                                                                                                                        \\\n+all_ok:                                                                                                                                                                   \\\n+    return result;                                                                                                                                                        \\\n+}\n+\n+/*internal helper to allocate a page*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_, C)\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_DEFINE(C, T)                                                                                                        \\\n+static PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(uint32_t page_size)                                                 \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* page;                                                                                                                        \\\n+    page = malloc_flex(sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)), page_size, sizeof(T));                                                                            \\\n+    if (page == NULL)                                                                                                                                                     \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"failure in malloc_flex for page, page_size=%\" PRIu32 \", sizeof(\" MU_TOSTRING(T) \")=%zu\", page_size, sizeof(T));                                         \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        size_t bitmap_size = PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size);                                                                                                   \\\n+        page->allocation_bitmap = malloc(bitmap_size);                                                                                                                    \\\n+        if (page->allocation_bitmap == NULL)                                                                                                                              \\\n+        {                                                                                                                                                                 \\\n+            LogError(\"failure in malloc for allocation_bitmap, bitmap_size=%zu\", bitmap_size);                                                                            \\\n+            free(page);                                                                                                                                                   \\\n+            page = NULL;                                                                                                                                                  \\\n+        }                                                                                                                                                                 \\\n+        else                                                                                                                                                              \\\n+        {                                                                                                                                                                 \\\n+            /* Initialize bitmap to all zeros (nothing allocated) */                                                                                                      \\\n+            (void)memset(page->allocation_bitmap, 0, bitmap_size);                                                                                                        \\\n+            page->allocated_count = 0;                                                                                                                                    \\\n+        }                                                                                                                                                                 \\\n+    }                                                                                                                                                                     \\\n+    return page;                                                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DEFINE(C, T)                                                                                                                       \\\n+T* PAGED_SPARSE_ARRAY_LL_ALLOCATE(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint32_t index)                                                                         \\\n+{                                                                                                                                                                          \\\n+    T* result;                                                                                                                                                             \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_011: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                               \\\n+    if (paged_sparse_array == NULL)                                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: PAGED_SPARSE_ARRAY(\" MU_TOSTRING(T) \") paged_sparse_array=%p\", paged_sparse_array);                                                   \\\n+    }                                                                                                                                                                      \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_012: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/               \\\n+    else if (index >= paged_sparse_array->max_size)                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: uint32_t index=%\" PRIu32 \" out of bound, max_size=%\" PRIu32 \"\", index, paged_sparse_array->max_size);                                 \\\n+    }                                                                                                                                                                      \\\n+    else                                                                                                                                                                   \\\n+    {                                                                                                                                                                      \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_013: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall compute the page index as index / page_size. ]*/                                   \\\n+        uint32_t page_index = index / paged_sparse_array->page_size;                                                                                                       \\\n+        uint32_t index_in_page = index % paged_sparse_array->page_size;                                                                                                    \\\n+        PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* array = THANDLE_GET_T(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(paged_sparse_array);                                                 \\\n+                                                                                                                                                                           \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_014: [ If the page is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall allocate memory for the page containing page_size elements and an allocation bitmap, and initialize all elements as not allocated. ]*/ \\\n+        if (array->pages[page_index] == NULL)                                                                                                                              \\\n+        {                                                                                                                                                                  \\\n+            array->pages[page_index] = PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(paged_sparse_array->page_size);                                                \\\n+            if (array->pages[page_index] == NULL)                                                                                                                          \\\n+            {                                                                                                                                                              \\\n+                /* Codes_SRS_PAGED_SPARSE_ARRAY_88_018: [ If there are any errors, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                         \\\n+                LogError(\"failure allocating page at page_index=%\" PRIu32 \"\", page_index);                                                                                 \\\n+                goto error;                                                                                                                                                \\\n+            }                                                                                                                                                              \\\n+        }                                                                                                                                                                  \\\n+                                                                                                                                                                           \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_015: [ If the element at index is already allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/            \\","path":"inc/c_util/paged_sparse_array_ll.h","commit_id":"cb74967b04daf544db633c5c7ce3467e69e39f5d","original_commit_id":"6aa88d544af34793cb367f0e9a439753a1fe238a","user":{"login":"dcristoloveanu","id":8507399,"node_id":"MDQ6VXNlcjg1MDczOTk=","avatar_url":"https://avatars.githubusercontent.com/u/8507399?v=4","gravatar_id":"","url":"https://api.github.com/users/dcristoloveanu","html_url":"https://github.com/dcristoloveanu","followers_url":"https://api.github.com/users/dcristoloveanu/followers","following_url":"https://api.github.com/users/dcristoloveanu/following{/other_user}","gists_url":"https://api.github.com/users/dcristoloveanu/gists{/gist_id}","starred_url":"https://api.github.com/users/dcristoloveanu/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dcristoloveanu/subscriptions","organizations_url":"https://api.github.com/users/dcristoloveanu/orgs","repos_url":"https://api.github.com/users/dcristoloveanu/repos","events_url":"https://api.github.com/users/dcristoloveanu/events{/privacy}","received_events_url":"https://api.github.com/users/dcristoloveanu/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Can we refactor to avoid the error: label?\r\nSomethng like \r\nif ((array->pages[page_index] == NULL) &&\r\n    ((array->pages[page_index] = PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(paged_sparse_array->page_size) == NULL))\r\n{\r\n} else\r\n{\r\n ...\r\n} #Resolved","created_at":"2026-01-12T06:14:24Z","updated_at":"2026-01-12T06:32:50Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2680985269","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2680985269"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2680985269"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2680985269/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":257,"side":"RIGHT","author_association":"MEMBER","original_position":257,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2680987121","pull_request_review_id":3649294270,"id":2680987121,"node_id":"PRRC_kwDODaUZTc6fzJ3x","diff_hunk":"@@ -0,0 +1,424 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#ifndef PAGED_SPARSE_ARRAY_LL_H\n+#define PAGED_SPARSE_ARRAY_LL_H\n+\n+#ifdef __cplusplus\n+#include <cinttypes>\n+#include <cstdlib>\n+#else // __cplusplus\n+#include <inttypes.h>\n+#include <stdlib.h>\n+#endif // __cplusplus\n+\n+#include \"c_pal/gballoc_hl.h\"\n+#include \"c_pal/gballoc_hl_redirect.h\"\n+\n+#include \"macro_utils/macro_utils.h\"\n+\n+#include \"c_logging/logger.h\"\n+\n+#include \"c_pal/thandle_ll.h\"\n+\n+#include \"umock_c/umock_c_prod.h\"\n+\n+/*PAGED_SPARSE_ARRAY is backed by a THANDLE build on the structure below*/\n+#define PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T), _TAG)\n+\n+#define PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_STRUCT_, T)\n+\n+/*PAGE_STRUCT holds a single page with elements and allocation bitmap*/\n+#define PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T), _TAG)\n+#define PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_STRUCT_, T)\n+\n+/*PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) introduces the base type that holds the paged sparse array*/\n+#define PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(T)                                                                      \\\n+/*define the page structure first*/                                                                                    \\\n+typedef struct PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T)                                                         \\\n+{                                                                                                                      \\\n+    uint32_t allocated_count;                                                                                          \\\n+    uint8_t* allocation_bitmap;                                                                                        \\\n+    T items[];                                                                                                         \\\n+} PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T);                                                                             \\\n+/*forward define the typedef of the PAGED_SPARSE_ARRAY struct so that it can be used for a function pointer definition*/\\\n+typedef struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T);                          \\\n+struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T)                                                                      \\\n+{                                                                                                                      \\\n+    uint32_t max_size;                                                                                                 \\\n+    uint32_t page_size;                                                                                                \\\n+    uint32_t page_count;                                                                                               \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* pages[];                                                                  \\\n+};                                                                                                                     \\\n+\n+/*PAGED_SPARSE_ARRAY is-a THANDLE*/\n+/*given a type \"T\" PAGED_SPARSE_ARRAY_LL(T) expands to the name of the type. */\n+#define PAGED_SPARSE_ARRAY_LL(T) THANDLE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*because PAGED_SPARSE_ARRAY is a THANDLE, all THANDLE's macro APIs are useable with PAGED_SPARSE_ARRAY.*/\n+/*the below are just shortcuts of THANDLE's public ones*/\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE(T) THANDLE_INITIALIZE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_ASSIGN(T) THANDLE_ASSIGN(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_MOVE(T) THANDLE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE_MOVE(T) THANDLE_INITIALIZE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*introduces a new name for a function that returns a PAGED_SPARSE_ARRAY_LL(T)*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_CREATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_CREATE(C) PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C)\n+\n+/*introduces a name for the function that frees a PAGED_SPARSE_ARRAY when its ref count goes to 0*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_FREE_, C)\n+\n+/*introduces a name for the allocate function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C)\n+\n+/*introduces a name for the release function*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_RELEASE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE(C) PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C)\n+\n+/*introduces a name for the allocate_or_get function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C)\n+\n+/*introduces a name for the get function*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_GET(C) PAGED_SPARSE_ARRAY_LL_GET_NAME(C)\n+\n+/*introduces a function declaration for paged_sparse_array_create*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, PAGED_SPARSE_ARRAY_LL(T), PAGED_SPARSE_ARRAY_LL_CREATE(C), uint32_t, max_size, uint32_t, page_size);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_release*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, int, PAGED_SPARSE_ARRAY_LL_RELEASE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate_or_get*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_get*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*helper to compute bitmap size in bytes (1 bit per element, rounded up to nearest byte)*/\n+#define PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size) (((page_size) + 7) / 8)\n+\n+/*helper to check if an element is allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_IS_ALLOCATED(bitmap, index_in_page) \\\n+    (((bitmap)[(index_in_page) / 8] & (1 << ((index_in_page) % 8))) != 0)\n+\n+/*helper to set an element as allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_SET_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] |= (1 << ((index_in_page) % 8)))\n+\n+/*helper to clear an element as not allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_CLEAR_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] &= ~(1 << ((index_in_page) % 8)))\n+\n+/*introduces a function definition for freeing the allocated resources for a PAGED_SPARSE_ARRAY*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_DEFINE(C, T)                                                                               \\\n+static void PAGED_SPARSE_ARRAY_LL_FREE_NAME(C)(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* paged_sparse_array)                        \\\n+{                                                                                                                              \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_009: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_FREE(T) shall return. ]*/      \\\n+    if (paged_sparse_array == NULL)                                                                                            \\\n+    {                                                                                                                          \\\n+        LogError(\"invalid arguments \" MU_TOSTRING(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)) \"* paged_sparse_array=%p\",               \\\n+            paged_sparse_array);                                                                                               \\\n+    }                                                                                                                          \\\n+    else                                                                                                                       \\\n+    {                                                                                                                          \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_010: [ PAGED_SPARSE_ARRAY_FREE(T) shall free all pages that are non-NULL. ]*/       \\\n+        for (uint32_t i = 0; i < paged_sparse_array->page_count; i++)                                                          \\\n+        {                                                                                                                      \\\n+            if (paged_sparse_array->pages[i] != NULL)                                                                          \\\n+            {                                                                                                                  \\\n+                free((void*)paged_sparse_array->pages[i]->allocation_bitmap);                                                  \\\n+                free((void*)paged_sparse_array->pages[i]);                                                                     \\\n+            }                                                                                                                  \\\n+        }                                                                                                                      \\\n+    }                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DEFINE(C, T)                                                                                                                        \\\n+PAGED_SPARSE_ARRAY_LL(T) PAGED_SPARSE_ARRAY_LL_CREATE(C)(uint32_t max_size, uint32_t page_size)                                                                          \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* result;                                                                                                                           \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_001: [ If max_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                           \\\n+    if (max_size == 0)                                                                                                                                                    \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t max_size=%\" PRIu32 \"\", max_size);                                                                                           \\\n+    }                                                                                                                                                                     \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_002: [ If page_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                          \\\n+    else if (page_size == 0)                                                                                                                                              \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t page_size=%\" PRIu32 \"\", page_size);                                                                                         \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_003: [ PAGED_SPARSE_ARRAY_CREATE(T) shall compute the number of pages as (max_size + page_size - 1) / page_size. ]*/           \\\n+        uint32_t page_count = (max_size + page_size - 1) / page_size;                                                                                                     \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_004: [ PAGED_SPARSE_ARRAY_CREATE(T) shall call THANDLE_MALLOC_FLEX to allocate memory for the paged sparse array with the number of pages. ]*/ \\\n+        result = THANDLE_MALLOC_FLEX(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(PAGED_SPARSE_ARRAY_LL_FREE_NAME(C), page_count, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)*)); \\\n+        if (result == NULL)                                                                                                                                               \\\n+        {                                                                                                                                                                 \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_007: [ If there are any errors, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                               \\\n+            LogError(\"failure in THANDLE_MALLOC_FLEX page_count=%\" PRIu32 \", sizeof(PAGED_SPARSE_ARRAY_PAGE*)=%zu\", page_count, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)*)); \\\n+        }                                                                                                                                                                 \\\n+        else                                                                                                                                                              \\\n+        {                                                                                                                                                                 \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_006: [ PAGED_SPARSE_ARRAY_CREATE(T) shall store max_size and page_size in the structure. ]*/                               \\\n+            result->max_size = max_size;                                                                                                                                  \\\n+            result->page_size = page_size;                                                                                                                                \\\n+            result->page_count = page_count;                                                                                                                              \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_005: [ PAGED_SPARSE_ARRAY_CREATE(T) shall set all page pointers to NULL. ]*/                                               \\\n+            for (uint32_t i = 0; i < page_count; i++)                                                                                                                     \\\n+            {                                                                                                                                                             \\\n+                result->pages[i] = NULL;                                                                                                                                  \\\n+            }                                                                                                                                                             \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_008: [ PAGED_SPARSE_ARRAY_CREATE(T) shall succeed and return a non-NULL value. ]*/                                         \\\n+            goto all_ok;                                                                                                                                                  \\\n+        }                                                                                                                                                                 \\\n+    }                                                                                                                                                                     \\\n+    result = NULL;                                                                                                                                                        \\\n+all_ok:                                                                                                                                                                   \\\n+    return result;                                                                                                                                                        \\\n+}\n+\n+/*internal helper to allocate a page*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_, C)\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_DEFINE(C, T)                                                                                                        \\\n+static PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(uint32_t page_size)                                                 \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* page;                                                                                                                        \\\n+    page = malloc_flex(sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)), page_size, sizeof(T));                                                                            \\\n+    if (page == NULL)                                                                                                                                                     \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"failure in malloc_flex for page, page_size=%\" PRIu32 \", sizeof(\" MU_TOSTRING(T) \")=%zu\", page_size, sizeof(T));                                         \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        size_t bitmap_size = PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size);                                                                                                   \\\n+        page->allocation_bitmap = malloc(bitmap_size);                                                                                                                    \\\n+        if (page->allocation_bitmap == NULL)                                                                                                                              \\\n+        {                                                                                                                                                                 \\\n+            LogError(\"failure in malloc for allocation_bitmap, bitmap_size=%zu\", bitmap_size);                                                                            \\\n+            free(page);                                                                                                                                                   \\\n+            page = NULL;                                                                                                                                                  \\\n+        }                                                                                                                                                                 \\\n+        else                                                                                                                                                              \\\n+        {                                                                                                                                                                 \\\n+            /* Initialize bitmap to all zeros (nothing allocated) */                                                                                                      \\\n+            (void)memset(page->allocation_bitmap, 0, bitmap_size);                                                                                                        \\\n+            page->allocated_count = 0;                                                                                                                                    \\\n+        }                                                                                                                                                                 \\\n+    }                                                                                                                                                                     \\\n+    return page;                                                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DEFINE(C, T)                                                                                                                       \\\n+T* PAGED_SPARSE_ARRAY_LL_ALLOCATE(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint32_t index)                                                                         \\\n+{                                                                                                                                                                          \\\n+    T* result;                                                                                                                                                             \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_011: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                               \\\n+    if (paged_sparse_array == NULL)                                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: PAGED_SPARSE_ARRAY(\" MU_TOSTRING(T) \") paged_sparse_array=%p\", paged_sparse_array);                                                   \\\n+    }                                                                                                                                                                      \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_012: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/               \\\n+    else if (index >= paged_sparse_array->max_size)                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: uint32_t index=%\" PRIu32 \" out of bound, max_size=%\" PRIu32 \"\", index, paged_sparse_array->max_size);                                 \\\n+    }                                                                                                                                                                      \\\n+    else                                                                                                                                                                   \\\n+    {                                                                                                                                                                      \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_013: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall compute the page index as index / page_size. ]*/                                   \\\n+        uint32_t page_index = index / paged_sparse_array->page_size;                                                                                                       \\\n+        uint32_t index_in_page = index % paged_sparse_array->page_size;                                                                                                    \\\n+        PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* array = THANDLE_GET_T(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(paged_sparse_array);                                                 \\\n+                                                                                                                                                                           \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_014: [ If the page is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall allocate memory for the page containing page_size elements and an allocation bitmap, and initialize all elements as not allocated. ]*/ \\\n+        if (array->pages[page_index] == NULL)                                                                                                                              \\\n+        {                                                                                                                                                                  \\\n+            array->pages[page_index] = PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(paged_sparse_array->page_size);                                                \\\n+            if (array->pages[page_index] == NULL)                                                                                                                          \\\n+            {                                                                                                                                                              \\\n+                /* Codes_SRS_PAGED_SPARSE_ARRAY_88_018: [ If there are any errors, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                         \\\n+                LogError(\"failure allocating page at page_index=%\" PRIu32 \"\", page_index);                                                                                 \\\n+                goto error;                                                                                                                                                \\\n+            }                                                                                                                                                              \\\n+        }                                                                                                                                                                  \\\n+                                                                                                                                                                           \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_015: [ If the element at index is already allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/            \\","path":"inc/c_util/paged_sparse_array_ll.h","commit_id":"cb74967b04daf544db633c5c7ce3467e69e39f5d","original_commit_id":"6aa88d544af34793cb367f0e9a439753a1fe238a","user":{"login":"dcristoloveanu","id":8507399,"node_id":"MDQ6VXNlcjg1MDczOTk=","avatar_url":"https://avatars.githubusercontent.com/u/8507399?v=4","gravatar_id":"","url":"https://api.github.com/users/dcristoloveanu","html_url":"https://github.com/dcristoloveanu","followers_url":"https://api.github.com/users/dcristoloveanu/followers","following_url":"https://api.github.com/users/dcristoloveanu/following{/other_user}","gists_url":"https://api.github.com/users/dcristoloveanu/gists{/gist_id}","starred_url":"https://api.github.com/users/dcristoloveanu/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dcristoloveanu/subscriptions","organizations_url":"https://api.github.com/users/dcristoloveanu/orgs","repos_url":"https://api.github.com/users/dcristoloveanu/repos","events_url":"https://api.github.com/users/dcristoloveanu/events{/privacy}","received_events_url":"https://api.github.com/users/dcristoloveanu/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Same should be applied for the other cases that have error: label in this file","created_at":"2026-01-12T06:15:34Z","updated_at":"2026-01-12T06:15:34Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2680987121","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2680987121"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2680987121"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2680987121/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":257,"side":"RIGHT","in_reply_to_id":2680985269,"author_association":"MEMBER","original_position":257,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2680988857","pull_request_review_id":3649296274,"id":2680988857,"node_id":"PRRC_kwDODaUZTc6fzKS5","diff_hunk":"@@ -0,0 +1,424 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#ifndef PAGED_SPARSE_ARRAY_LL_H\n+#define PAGED_SPARSE_ARRAY_LL_H\n+\n+#ifdef __cplusplus\n+#include <cinttypes>\n+#include <cstdlib>\n+#else // __cplusplus\n+#include <inttypes.h>\n+#include <stdlib.h>\n+#endif // __cplusplus\n+\n+#include \"c_pal/gballoc_hl.h\"\n+#include \"c_pal/gballoc_hl_redirect.h\"\n+\n+#include \"macro_utils/macro_utils.h\"\n+\n+#include \"c_logging/logger.h\"\n+\n+#include \"c_pal/thandle_ll.h\"\n+\n+#include \"umock_c/umock_c_prod.h\"\n+\n+/*PAGED_SPARSE_ARRAY is backed by a THANDLE build on the structure below*/\n+#define PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T), _TAG)\n+\n+#define PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_STRUCT_, T)\n+\n+/*PAGE_STRUCT holds a single page with elements and allocation bitmap*/\n+#define PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T), _TAG)\n+#define PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_STRUCT_, T)\n+\n+/*PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) introduces the base type that holds the paged sparse array*/\n+#define PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(T)                                                                      \\\n+/*define the page structure first*/                                                                                    \\\n+typedef struct PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T)                                                         \\\n+{                                                                                                                      \\\n+    uint32_t allocated_count;                                                                                          \\\n+    uint8_t* allocation_bitmap;                                                                                        \\\n+    T items[];                                                                                                         \\\n+} PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T);                                                                             \\\n+/*forward define the typedef of the PAGED_SPARSE_ARRAY struct so that it can be used for a function pointer definition*/\\\n+typedef struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T);                          \\\n+struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T)                                                                      \\\n+{                                                                                                                      \\\n+    uint32_t max_size;                                                                                                 \\\n+    uint32_t page_size;                                                                                                \\\n+    uint32_t page_count;                                                                                               \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* pages[];                                                                  \\\n+};                                                                                                                     \\\n+\n+/*PAGED_SPARSE_ARRAY is-a THANDLE*/\n+/*given a type \"T\" PAGED_SPARSE_ARRAY_LL(T) expands to the name of the type. */\n+#define PAGED_SPARSE_ARRAY_LL(T) THANDLE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*because PAGED_SPARSE_ARRAY is a THANDLE, all THANDLE's macro APIs are useable with PAGED_SPARSE_ARRAY.*/\n+/*the below are just shortcuts of THANDLE's public ones*/\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE(T) THANDLE_INITIALIZE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_ASSIGN(T) THANDLE_ASSIGN(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_MOVE(T) THANDLE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE_MOVE(T) THANDLE_INITIALIZE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*introduces a new name for a function that returns a PAGED_SPARSE_ARRAY_LL(T)*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_CREATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_CREATE(C) PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C)\n+\n+/*introduces a name for the function that frees a PAGED_SPARSE_ARRAY when its ref count goes to 0*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_FREE_, C)\n+\n+/*introduces a name for the allocate function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C)\n+\n+/*introduces a name for the release function*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_RELEASE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE(C) PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C)\n+\n+/*introduces a name for the allocate_or_get function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C)\n+\n+/*introduces a name for the get function*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_GET(C) PAGED_SPARSE_ARRAY_LL_GET_NAME(C)\n+\n+/*introduces a function declaration for paged_sparse_array_create*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, PAGED_SPARSE_ARRAY_LL(T), PAGED_SPARSE_ARRAY_LL_CREATE(C), uint32_t, max_size, uint32_t, page_size);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_release*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, int, PAGED_SPARSE_ARRAY_LL_RELEASE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate_or_get*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_get*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*helper to compute bitmap size in bytes (1 bit per element, rounded up to nearest byte)*/\n+#define PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size) (((page_size) + 7) / 8)\n+\n+/*helper to check if an element is allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_IS_ALLOCATED(bitmap, index_in_page) \\\n+    (((bitmap)[(index_in_page) / 8] & (1 << ((index_in_page) % 8))) != 0)\n+\n+/*helper to set an element as allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_SET_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] |= (1 << ((index_in_page) % 8)))\n+\n+/*helper to clear an element as not allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_CLEAR_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] &= ~(1 << ((index_in_page) % 8)))\n+\n+/*introduces a function definition for freeing the allocated resources for a PAGED_SPARSE_ARRAY*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_DEFINE(C, T)                                                                               \\\n+static void PAGED_SPARSE_ARRAY_LL_FREE_NAME(C)(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* paged_sparse_array)                        \\\n+{                                                                                                                              \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_009: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_FREE(T) shall return. ]*/      \\\n+    if (paged_sparse_array == NULL)                                                                                            \\\n+    {                                                                                                                          \\\n+        LogError(\"invalid arguments \" MU_TOSTRING(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)) \"* paged_sparse_array=%p\",               \\\n+            paged_sparse_array);                                                                                               \\\n+    }                                                                                                                          \\\n+    else                                                                                                                       \\\n+    {                                                                                                                          \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_010: [ PAGED_SPARSE_ARRAY_FREE(T) shall free all pages that are non-NULL. ]*/       \\\n+        for (uint32_t i = 0; i < paged_sparse_array->page_count; i++)                                                          \\\n+        {                                                                                                                      \\\n+            if (paged_sparse_array->pages[i] != NULL)                                                                          \\\n+            {                                                                                                                  \\\n+                free((void*)paged_sparse_array->pages[i]->allocation_bitmap);                                                  \\\n+                free((void*)paged_sparse_array->pages[i]);                                                                     \\\n+            }                                                                                                                  \\\n+        }                                                                                                                      \\\n+    }                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DEFINE(C, T)                                                                                                                        \\\n+PAGED_SPARSE_ARRAY_LL(T) PAGED_SPARSE_ARRAY_LL_CREATE(C)(uint32_t max_size, uint32_t page_size)                                                                          \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* result;                                                                                                                           \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_001: [ If max_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                           \\\n+    if (max_size == 0)                                                                                                                                                    \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t max_size=%\" PRIu32 \"\", max_size);                                                                                           \\\n+    }                                                                                                                                                                     \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_002: [ If page_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                          \\\n+    else if (page_size == 0)                                                                                                                                              \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t page_size=%\" PRIu32 \"\", page_size);                                                                                         \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_003: [ PAGED_SPARSE_ARRAY_CREATE(T) shall compute the number of pages as (max_size + page_size - 1) / page_size. ]*/           \\\n+        uint32_t page_count = (max_size + page_size - 1) / page_size;                                                                                                     \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_004: [ PAGED_SPARSE_ARRAY_CREATE(T) shall call THANDLE_MALLOC_FLEX to allocate memory for the paged sparse array with the number of pages. ]*/ \\\n+        result = THANDLE_MALLOC_FLEX(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(PAGED_SPARSE_ARRAY_LL_FREE_NAME(C), page_count, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)*)); \\\n+        if (result == NULL)                                                                                                                                               \\\n+        {                                                                                                                                                                 \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_007: [ If there are any errors, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                               \\\n+            LogError(\"failure in THANDLE_MALLOC_FLEX page_count=%\" PRIu32 \", sizeof(PAGED_SPARSE_ARRAY_PAGE*)=%zu\", page_count, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)*)); \\\n+        }                                                                                                                                                                 \\\n+        else                                                                                                                                                              \\\n+        {                                                                                                                                                                 \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_006: [ PAGED_SPARSE_ARRAY_CREATE(T) shall store max_size and page_size in the structure. ]*/                               \\\n+            result->max_size = max_size;                                                                                                                                  \\\n+            result->page_size = page_size;                                                                                                                                \\\n+            result->page_count = page_count;                                                                                                                              \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_005: [ PAGED_SPARSE_ARRAY_CREATE(T) shall set all page pointers to NULL. ]*/                                               \\\n+            for (uint32_t i = 0; i < page_count; i++)                                                                                                                     \\\n+            {                                                                                                                                                             \\\n+                result->pages[i] = NULL;                                                                                                                                  \\\n+            }                                                                                                                                                             \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_008: [ PAGED_SPARSE_ARRAY_CREATE(T) shall succeed and return a non-NULL value. ]*/                                         \\\n+            goto all_ok;                                                                                                                                                  \\\n+        }                                                                                                                                                                 \\\n+    }                                                                                                                                                                     \\\n+    result = NULL;                                                                                                                                                        \\\n+all_ok:                                                                                                                                                                   \\\n+    return result;                                                                                                                                                        \\\n+}\n+\n+/*internal helper to allocate a page*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_, C)\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_DEFINE(C, T)                                                                                                        \\\n+static PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(uint32_t page_size)                                                 \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* page;                                                                                                                        \\\n+    page = malloc_flex(sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)), page_size, sizeof(T));                                                                            \\\n+    if (page == NULL)                                                                                                                                                     \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"failure in malloc_flex for page, page_size=%\" PRIu32 \", sizeof(\" MU_TOSTRING(T) \")=%zu\", page_size, sizeof(T));                                         \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        size_t bitmap_size = PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size);                                                                                                   \\\n+        page->allocation_bitmap = malloc(bitmap_size);                                                                                                                    \\\n+        if (page->allocation_bitmap == NULL)                                                                                                                              \\\n+        {                                                                                                                                                                 \\\n+            LogError(\"failure in malloc for allocation_bitmap, bitmap_size=%zu\", bitmap_size);                                                                            \\\n+            free(page);                                                                                                                                                   \\\n+            page = NULL;                                                                                                                                                  \\\n+        }                                                                                                                                                                 \\\n+        else                                                                                                                                                              \\\n+        {                                                                                                                                                                 \\\n+            /* Initialize bitmap to all zeros (nothing allocated) */                                                                                                      \\\n+            (void)memset(page->allocation_bitmap, 0, bitmap_size);                                                                                                        \\\n+            page->allocated_count = 0;                                                                                                                                    \\\n+        }                                                                                                                                                                 \\\n+    }                                                                                                                                                                     \\\n+    return page;                                                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DEFINE(C, T)                                                                                                                       \\\n+T* PAGED_SPARSE_ARRAY_LL_ALLOCATE(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint32_t index)                                                                         \\\n+{                                                                                                                                                                          \\\n+    T* result;                                                                                                                                                             \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_011: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                               \\\n+    if (paged_sparse_array == NULL)                                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: PAGED_SPARSE_ARRAY(\" MU_TOSTRING(T) \") paged_sparse_array=%p\", paged_sparse_array);                                                   \\\n+    }                                                                                                                                                                      \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_012: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/               \\\n+    else if (index >= paged_sparse_array->max_size)                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: uint32_t index=%\" PRIu32 \" out of bound, max_size=%\" PRIu32 \"\", index, paged_sparse_array->max_size);                                 \\\n+    }                                                                                                                                                                      \\\n+    else                                                                                                                                                                   \\\n+    {                                                                                                                                                                      \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_013: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall compute the page index as index / page_size. ]*/                                   \\\n+        uint32_t page_index = index / paged_sparse_array->page_size;                                                                                                       \\\n+        uint32_t index_in_page = index % paged_sparse_array->page_size;                                                                                                    \\\n+        PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* array = THANDLE_GET_T(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(paged_sparse_array);                                                 \\\n+                                                                                                                                                                           \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_014: [ If the page is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall allocate memory for the page containing page_size elements and an allocation bitmap, and initialize all elements as not allocated. ]*/ \\\n+        if (array->pages[page_index] == NULL)                                                                                                                              \\\n+        {                                                                                                                                                                  \\\n+            array->pages[page_index] = PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(paged_sparse_array->page_size);                                                \\\n+            if (array->pages[page_index] == NULL)                                                                                                                          \\\n+            {                                                                                                                                                              \\\n+                /* Codes_SRS_PAGED_SPARSE_ARRAY_88_018: [ If there are any errors, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                         \\\n+                LogError(\"failure allocating page at page_index=%\" PRIu32 \"\", page_index);                                                                                 \\\n+                goto error;                                                                                                                                                \\\n+            }                                                                                                                                                              \\\n+        }                                                                                                                                                                  \\\n+                                                                                                                                                                           \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_015: [ If the element at index is already allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/            \\\n+        if (PAGED_SPARSE_ARRAY_IS_ALLOCATED(array->pages[page_index]->allocation_bitmap, index_in_page))                                                                   \\\n+        {                                                                                                                                                                  \\\n+            LogError(\"Element at index=%\" PRIu32 \" is already allocated\", index);                                                                                          \\\n+        }                                                                                                                                                                  \\\n+        else                                                                                                                                                               \\\n+        {                                                                                                                                                                  \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_016: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall mark the element at index as allocated. ]*/                                    \\\n+            PAGED_SPARSE_ARRAY_SET_ALLOCATED(array->pages[page_index]->allocation_bitmap, index_in_page);                                                                  \\\n+            array->pages[page_index]->allocated_count++;                                                                                                                   \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_017: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall return a pointer to the element at index. ]*/                                  \\\n+            result = &array->pages[page_index]->items[index_in_page];                                                                                                      \\\n+            goto all_ok;                                                                                                                                                   \\\n+        }                                                                                                                                                                  \\\n+    }                                                                                                                                                                      \\\n+error:                                                                                                                                                                     \\\n+    result = NULL;                                                                                                                                                         \\\n+all_ok:                                                                                                                                                                    \\\n+    return result;                                                                                                                                                         \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DEFINE(C, T)                                                                                                                         \\\n+int PAGED_SPARSE_ARRAY_LL_RELEASE(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint32_t index)                                                                          \\\n+{                                                                                                                                                                           \\\n+    int result;                                                                                                                                                             \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_019: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/                     \\\n+    if (paged_sparse_array == NULL)                                                                                                                                         \\\n+    {                                                                                                                                                                       \\\n+        LogError(\"Invalid arguments: PAGED_SPARSE_ARRAY(\" MU_TOSTRING(T) \") paged_sparse_array=%p\", paged_sparse_array);                                                    \\\n+        result = MU_FAILURE;                                                                                                                                                \\\n+    }                                                                                                                                                                       \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_020: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/     \\\n+    else if (index >= paged_sparse_array->max_size)                                                                                                                         \\\n+    {                                                                                                                                                                       \\\n+        LogError(\"Invalid arguments: uint32_t index=%\" PRIu32 \" out of bound, max_size=%\" PRIu32 \"\", index, paged_sparse_array->max_size);                                  \\\n+        result = MU_FAILURE;                                                                                                                                                \\\n+    }                                                                                                                                                                       \\\n+    else                                                                                                                                                                    \\\n+    {                                                                                                                                                                       \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_021: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall compute the page index as index / page_size. ]*/                                     \\\n+        uint32_t page_index = index / paged_sparse_array->page_size;                                                                                                        \\\n+        uint32_t index_in_page = index % paged_sparse_array->page_size;                                                                                                     \\\n+        PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* array = THANDLE_GET_T(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(paged_sparse_array);                                                  \\\n+                                                                                                                                                                            \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_022: [ If the page is not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/                  \\\n+        if (array->pages[page_index] == NULL)                                                                                                                               \\\n+        {                                                                                                                                                                   \\\n+            LogError(\"Page at page_index=%\" PRIu32 \" is not allocated\", page_index);                                                                                        \\\n+            result = MU_FAILURE;                                                                                                                                            \\\n+        }                                                                                                                                                                   \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_023: [ If the element at index is not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/      \\\n+        else if (!PAGED_SPARSE_ARRAY_IS_ALLOCATED(array->pages[page_index]->allocation_bitmap, index_in_page))                                                              \\\n+        {                                                                                                                                                                   \\\n+            LogError(\"Element at index=%\" PRIu32 \" is not allocated\", index);                                                                                               \\\n+            result = MU_FAILURE;                                                                                                                                            \\\n+        }                                                                                                                                                                   \\\n+        else                                                                                                                                                                \\\n+        {                                                                                                                                                                   \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_024: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall mark the element at index as not allocated. ]*/                                  \\\n+            PAGED_SPARSE_ARRAY_CLEAR_ALLOCATED(array->pages[page_index]->allocation_bitmap, index_in_page);                                                                 \\\n+            array->pages[page_index]->allocated_count--;                                                                                                                    \\\n+                                                                                                                                                                            \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_025: [ If all elements in the page are now not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall free the page and set the page pointer to NULL. ]*/ \\\n+            if (array->pages[page_index]->allocated_count == 0)                                                                                                             \\\n+            {                                                                                                                                                               \\\n+                free((void*)array->pages[page_index]->allocation_bitmap);                                                                                                   \\\n+                free((void*)array->pages[page_index]);                                                                                                                      \\\n+                array->pages[page_index] = NULL;                                                                                                                            \\\n+            }                                                                                                                                                               \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_026: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall return zero on success. ]*/                                                       \\\n+            result = 0;                                                                                                                                                     \\\n+        }                                                                                                                                                                   \\\n+    }                                                                                                                                                                       \\\n+    return result;                                                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DEFINE(C, T)                                                                                                                 \\\n+T* PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint32_t index)                                                                   \\\n+{                                                                                                                                                                           \\\n+    T* result;                                                                                                                                                              \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_027: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/                         \\\n+    if (paged_sparse_array == NULL)                                                                                                                                         \\\n+    {                                                                                                                                                                       \\\n+        LogError(\"Invalid arguments: PAGED_SPARSE_ARRAY(\" MU_TOSTRING(T) \") paged_sparse_array=%p\", paged_sparse_array);                                                    \\\n+    }                                                                                                                                                                       \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_028: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/         \\\n+    else if (index >= paged_sparse_array->max_size)                                                                                                                         \\\n+    {                                                                                                                                                                       \\\n+        LogError(\"Invalid arguments: uint32_t index=%\" PRIu32 \" out of bound, max_size=%\" PRIu32 \"\", index, paged_sparse_array->max_size);                                  \\\n+    }                                                                                                                                                                       \\\n+    else                                                                                                                                                                    \\\n+    {                                                                                                                                                                       \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_029: [ PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall compute the page index as index / page_size. ]*/                             \\\n+        uint32_t page_index = index / paged_sparse_array->page_size;                                                                                                        \\\n+        uint32_t index_in_page = index % paged_sparse_array->page_size;                                                                                                     \\\n+        PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* array = THANDLE_GET_T(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(paged_sparse_array);                                                  \\\n+                                                                                                                                                                            \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_030: [ If the page is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall allocate memory for the page containing page_size elements and an allocation bitmap, and initialize all elements as not allocated. ]*/ \\\n+        if (array->pages[page_index] == NULL)                                                                                                                               \\\n+        {                                                                                                                                                                   \\\n+            array->pages[page_index] = PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(paged_sparse_array->page_size);                                                 \\\n+            if (array->pages[page_index] == NULL)                                                                                                                           \\\n+            {                                                                                                                                                               \\\n+                /* Codes_SRS_PAGED_SPARSE_ARRAY_88_033: [ If there are any errors, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/                   \\\n+                LogError(\"failure allocating page at page_index=%\" PRIu32 \"\", page_index);                                                                                  \\\n+                goto error;                                                                                                                                                 \\\n+            }                                                                                                                                                               \\\n+        }                                                                                                                                                                   \\\n+                                                                                                                                                                            \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_031: [ If the element at index is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall mark it as allocated. ]*/          \\\n+        if (!PAGED_SPARSE_ARRAY_IS_ALLOCATED(array->pages[page_index]->allocation_bitmap, index_in_page))                                                                   \\\n+        {                                                                                                                                                                   \\\n+            PAGED_SPARSE_ARRAY_SET_ALLOCATED(array->pages[page_index]->allocation_bitmap, index_in_page);                                                                   \\\n+            array->pages[page_index]->allocated_count++;                                                                                                                    \\\n+        }                                                                                                                                                                   \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_032: [ PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall return a pointer to the element at index. ]*/                                \\\n+        result = &array->pages[page_index]->items[index_in_page];                                                                                                           \\\n+        goto all_ok;                                                                                                                                                        \\\n+    }                                                                                                                                                                       \\\n+error:                                                                                                                                                                      \\\n+    result = NULL;                                                                                                                                                          \\\n+all_ok:                                                                                                                                                                     \\\n+    return result;                                                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_GET_DEFINE(C, T)                                                                                                                              \\\n+T* PAGED_SPARSE_ARRAY_LL_GET(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint32_t index)                                                                                \\\n+{                                                                                                                                                                            \\\n+    T* result;                                                                                                                                                               \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_034: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_GET(T) shall fail and return NULL. ]*/                                      \\\n+    if (paged_sparse_array == NULL)                                                                                                                                          \\\n+    {                                                                                                                                                                        \\\n+        LogError(\"Invalid arguments: PAGED_SPARSE_ARRAY(\" MU_TOSTRING(T) \") paged_sparse_array=%p\", paged_sparse_array);                                                     \\\n+    }                                                                                                                                                                        \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_035: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_GET(T) shall fail and return NULL. ]*/                      \\\n+    else if (index >= paged_sparse_array->max_size)                                                                                                                          \\\n+    {                                                                                                                                                                        \\\n+        LogError(\"Invalid arguments: uint32_t index=%\" PRIu32 \" out of bound, max_size=%\" PRIu32 \"\", index, paged_sparse_array->max_size);                                   \\\n+    }                                                                                                                                                                        \\\n+    else                                                                                                                                                                     \\\n+    {                                                                                                                                                                        \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_036: [ PAGED_SPARSE_ARRAY_GET(T) shall compute the page index as index / page_size. ]*/                                          \\","path":"inc/c_util/paged_sparse_array_ll.h","commit_id":"cb74967b04daf544db633c5c7ce3467e69e39f5d","original_commit_id":"6aa88d544af34793cb367f0e9a439753a1fe238a","user":{"login":"dcristoloveanu","id":8507399,"node_id":"MDQ6VXNlcjg1MDczOTk=","avatar_url":"https://avatars.githubusercontent.com/u/8507399?v=4","gravatar_id":"","url":"https://api.github.com/users/dcristoloveanu","html_url":"https://github.com/dcristoloveanu","followers_url":"https://api.github.com/users/dcristoloveanu/followers","following_url":"https://api.github.com/users/dcristoloveanu/following{/other_user}","gists_url":"https://api.github.com/users/dcristoloveanu/gists{/gist_id}","starred_url":"https://api.github.com/users/dcristoloveanu/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dcristoloveanu/subscriptions","organizations_url":"https://api.github.com/users/dcristoloveanu/orgs","repos_url":"https://api.github.com/users/dcristoloveanu/repos","events_url":"https://api.github.com/users/dcristoloveanu/events{/privacy}","received_events_url":"https://api.github.com/users/dcristoloveanu/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"> \\ [](http://example.com/codeflow?start=171&length=2)\r\n\r\nCan we have the \\ aligned at the same column (except if the line text is longer)? #Resolved","created_at":"2026-01-12T06:16:46Z","updated_at":"2026-01-12T06:54:17Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2680988857","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2680988857"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2680988857"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2680988857/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":398,"side":"RIGHT","author_association":"MEMBER","original_position":398,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682210310","pull_request_review_id":3650693058,"id":2682210310,"node_id":"PRRC_kwDODaUZTc6f30gG","diff_hunk":"@@ -0,0 +1,209 @@\n+# `paged_sparse_array` requirements\n+\n+## Overview\n+\n+`PAGED_SPARSE_ARRAY` is a module that provides a templatized paged sparse array data structure. The array has a maximum size and allocates memory in pages (groups of elements) on demand. When all elements in a page are released, the page is automatically freed.\n+\n+`PAGED_SPARSE_ARRAY` is a kind of `THANDLE`, all of the `THANDLE`'s API apply to `PAGED_SPARSE_ARRAY`. The following macros are provided with the same semantics as those of `THANDLE`'s:\n+- `PAGED_SPARSE_ARRAY_INITIALIZE(T)`\n+- `PAGED_SPARSE_ARRAY_ASSIGN(T)`\n+- `PAGED_SPARSE_ARRAY_MOVE(T)`\n+- `PAGED_SPARSE_ARRAY_INITIALIZE_MOVE(T)`\n+\n+## Design\n+\n+The array is organized into pages. Each page contains `page_size` elements. The total number of elements that can be stored is `max_size`. Pages are allocated lazily when an element is first allocated within that page. When all elements in a page are released, the page is automatically freed.\n+\n+Each element has an allocation state (allocated or not allocated). The user can:\n+- Allocate an index for usage (fails if already allocated)\n+- Release an index (when all indexes in a page are released, the page is freed)\n+- Allocate or get an index (allocates if not exists, gets if exists)\n+- Get an index (fails if not allocated)\n+\n+## Exposed API\n+\n+```c\n+/*to be used as the type of handle that wraps T*/\n+#define PAGED_SPARSE_ARRAY(T)\n+\n+/*to be used in a header file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+\n+/*to be used in a .c file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+```\n+\n+The macros expand to these useful APIs:\n+\n+```c\n+PAGED_SPARSE_ARRAY(T) PAGED_SPARSE_ARRAY_CREATE(T)(uint32_t max_size, uint32_t page_size);\n+void PAGED_SPARSE_ARRAY_FREE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array);","path":"devdoc/paged_sparse_array_requirements.md","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":">PAGED_SPARSE_ARRAY_FREE [](http://example.com/codeflow?start=5&length=23)\r\n\r\nwhy do we need a FREE if `PAGED_SPARSE_ARRAY` is a `THANDLE`? Shouldn't an assign NULL be sufficient? #Resolved","created_at":"2026-01-12T13:08:57Z","updated_at":"2026-01-12T19:38:31Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682210310","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682210310"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682210310"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682210310/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":40,"original_line":40,"side":"RIGHT","author_association":"MEMBER","original_position":40,"position":40,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682219494","pull_request_review_id":3650703124,"id":2682219494,"node_id":"PRRC_kwDODaUZTc6f32vm","diff_hunk":"@@ -0,0 +1,209 @@\n+# `paged_sparse_array` requirements\n+\n+## Overview\n+\n+`PAGED_SPARSE_ARRAY` is a module that provides a templatized paged sparse array data structure. The array has a maximum size and allocates memory in pages (groups of elements) on demand. When all elements in a page are released, the page is automatically freed.\n+\n+`PAGED_SPARSE_ARRAY` is a kind of `THANDLE`, all of the `THANDLE`'s API apply to `PAGED_SPARSE_ARRAY`. The following macros are provided with the same semantics as those of `THANDLE`'s:\n+- `PAGED_SPARSE_ARRAY_INITIALIZE(T)`\n+- `PAGED_SPARSE_ARRAY_ASSIGN(T)`\n+- `PAGED_SPARSE_ARRAY_MOVE(T)`\n+- `PAGED_SPARSE_ARRAY_INITIALIZE_MOVE(T)`\n+\n+## Design\n+\n+The array is organized into pages. Each page contains `page_size` elements. The total number of elements that can be stored is `max_size`. Pages are allocated lazily when an element is first allocated within that page. When all elements in a page are released, the page is automatically freed.\n+\n+Each element has an allocation state (allocated or not allocated). The user can:\n+- Allocate an index for usage (fails if already allocated)\n+- Release an index (when all indexes in a page are released, the page is freed)\n+- Allocate or get an index (allocates if not exists, gets if exists)\n+- Get an index (fails if not allocated)\n+\n+## Exposed API\n+\n+```c\n+/*to be used as the type of handle that wraps T*/\n+#define PAGED_SPARSE_ARRAY(T)\n+\n+/*to be used in a header file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+\n+/*to be used in a .c file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+```\n+\n+The macros expand to these useful APIs:\n+\n+```c\n+PAGED_SPARSE_ARRAY(T) PAGED_SPARSE_ARRAY_CREATE(T)(uint32_t max_size, uint32_t page_size);\n+void PAGED_SPARSE_ARRAY_FREE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array);\n+T* PAGED_SPARSE_ARRAY_ALLOCATE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+int PAGED_SPARSE_ARRAY_RELEASE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+T* PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);","path":"devdoc/paged_sparse_array_requirements.md","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":">PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET [](http://example.com/codeflow?start=3&length=34)\r\n\r\nHmmm... weird how this works.\r\n\r\nI am thinking - if I am the user and I have no knowledge about what's at `index` (whether it is allocated or not) ... \r\n\r\nand I get some non-NULL pointer as result - can I dereference that pointer and use the memory content there? How can I tell apart \"this is non-written yet memory\" versus \"this memory has already been initialized\".\r\n","created_at":"2026-01-12T13:11:47Z","updated_at":"2026-01-12T13:11:47Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682219494","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682219494"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682219494"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682219494/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":43,"original_line":43,"side":"RIGHT","author_association":"MEMBER","original_position":43,"position":43,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682223021","pull_request_review_id":3650707059,"id":2682223021,"node_id":"PRRC_kwDODaUZTc6f33mt","diff_hunk":"@@ -0,0 +1,209 @@\n+# `paged_sparse_array` requirements\n+\n+## Overview\n+\n+`PAGED_SPARSE_ARRAY` is a module that provides a templatized paged sparse array data structure. The array has a maximum size and allocates memory in pages (groups of elements) on demand. When all elements in a page are released, the page is automatically freed.\n+\n+`PAGED_SPARSE_ARRAY` is a kind of `THANDLE`, all of the `THANDLE`'s API apply to `PAGED_SPARSE_ARRAY`. The following macros are provided with the same semantics as those of `THANDLE`'s:\n+- `PAGED_SPARSE_ARRAY_INITIALIZE(T)`\n+- `PAGED_SPARSE_ARRAY_ASSIGN(T)`\n+- `PAGED_SPARSE_ARRAY_MOVE(T)`\n+- `PAGED_SPARSE_ARRAY_INITIALIZE_MOVE(T)`\n+\n+## Design\n+\n+The array is organized into pages. Each page contains `page_size` elements. The total number of elements that can be stored is `max_size`. Pages are allocated lazily when an element is first allocated within that page. When all elements in a page are released, the page is automatically freed.\n+\n+Each element has an allocation state (allocated or not allocated). The user can:\n+- Allocate an index for usage (fails if already allocated)\n+- Release an index (when all indexes in a page are released, the page is freed)\n+- Allocate or get an index (allocates if not exists, gets if exists)\n+- Get an index (fails if not allocated)\n+\n+## Exposed API\n+\n+```c\n+/*to be used as the type of handle that wraps T*/\n+#define PAGED_SPARSE_ARRAY(T)\n+\n+/*to be used in a header file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+\n+/*to be used in a .c file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+```\n+\n+The macros expand to these useful APIs:\n+\n+```c\n+PAGED_SPARSE_ARRAY(T) PAGED_SPARSE_ARRAY_CREATE(T)(uint32_t max_size, uint32_t page_size);\n+void PAGED_SPARSE_ARRAY_FREE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array);\n+T* PAGED_SPARSE_ARRAY_ALLOCATE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+int PAGED_SPARSE_ARRAY_RELEASE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);","path":"devdoc/paged_sparse_array_requirements.md","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":">PAGED_SPARSE_ARRAY_RELEASE [](http://example.com/codeflow?start=4&length=26)\r\n\r\nwhy does \"release\" return an `int`? What is the user going to do with it... I think at this time the user already decided he doesn't need that memory anymore. \r\n\r\n`free` is `void`.","created_at":"2026-01-12T13:12:52Z","updated_at":"2026-01-12T13:12:52Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682223021","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682223021"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682223021"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682223021/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":42,"original_line":42,"side":"RIGHT","author_association":"MEMBER","original_position":42,"position":42,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682229087","pull_request_review_id":3650713681,"id":2682229087,"node_id":"PRRC_kwDODaUZTc6f35Ff","diff_hunk":"@@ -0,0 +1,209 @@\n+# `paged_sparse_array` requirements\n+\n+## Overview\n+\n+`PAGED_SPARSE_ARRAY` is a module that provides a templatized paged sparse array data structure. The array has a maximum size and allocates memory in pages (groups of elements) on demand. When all elements in a page are released, the page is automatically freed.\n+\n+`PAGED_SPARSE_ARRAY` is a kind of `THANDLE`, all of the `THANDLE`'s API apply to `PAGED_SPARSE_ARRAY`. The following macros are provided with the same semantics as those of `THANDLE`'s:\n+- `PAGED_SPARSE_ARRAY_INITIALIZE(T)`\n+- `PAGED_SPARSE_ARRAY_ASSIGN(T)`\n+- `PAGED_SPARSE_ARRAY_MOVE(T)`\n+- `PAGED_SPARSE_ARRAY_INITIALIZE_MOVE(T)`\n+\n+## Design\n+\n+The array is organized into pages. Each page contains `page_size` elements. The total number of elements that can be stored is `max_size`. Pages are allocated lazily when an element is first allocated within that page. When all elements in a page are released, the page is automatically freed.\n+\n+Each element has an allocation state (allocated or not allocated). The user can:\n+- Allocate an index for usage (fails if already allocated)\n+- Release an index (when all indexes in a page are released, the page is freed)\n+- Allocate or get an index (allocates if not exists, gets if exists)\n+- Get an index (fails if not allocated)\n+\n+## Exposed API\n+\n+```c\n+/*to be used as the type of handle that wraps T*/\n+#define PAGED_SPARSE_ARRAY(T)\n+\n+/*to be used in a header file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+\n+/*to be used in a .c file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+```\n+\n+The macros expand to these useful APIs:\n+\n+```c\n+PAGED_SPARSE_ARRAY(T) PAGED_SPARSE_ARRAY_CREATE(T)(uint32_t max_size, uint32_t page_size);\n+void PAGED_SPARSE_ARRAY_FREE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array);\n+T* PAGED_SPARSE_ARRAY_ALLOCATE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+int PAGED_SPARSE_ARRAY_RELEASE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+T* PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+T* PAGED_SPARSE_ARRAY_GET(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+```\n+\n+### PAGED_SPARSE_ARRAY(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY(T)` is a `THANDLE`(`PAGED_SPARSE_ARRAY_STRUCT_T`), where `PAGED_SPARSE_ARRAY_STRUCT_T` is a structure that holds the paged sparse array data.\n+\n+### PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)` is a macro to be used in a header declaration.\n+\n+It introduces the APIs (as MOCKABLE_FUNCTIONS) that can be called for a `PAGED_SPARSE_ARRAY`.\n+\n+Example usage:\n+\n+```c\n+PAGED_SPARSE_ARRAY_TYPE_DECLARE(int32_t);","path":"devdoc/paged_sparse_array_requirements.md","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":">int32_t [](http://example.com/codeflow?start=32&length=7)\r\n\r\nwhat's the meaning of this int32_t?\r\n\r\nAll he previous int types were uint32_t (lines 39-44) #Closed","created_at":"2026-01-12T13:14:42Z","updated_at":"2026-01-12T19:38:56Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682229087","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682229087"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682229087"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682229087/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":68,"original_line":68,"side":"RIGHT","author_association":"MEMBER","original_position":68,"position":68,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682233762","pull_request_review_id":3650718665,"id":2682233762,"node_id":"PRRC_kwDODaUZTc6f36Oi","diff_hunk":"@@ -0,0 +1,209 @@\n+# `paged_sparse_array` requirements\n+\n+## Overview\n+\n+`PAGED_SPARSE_ARRAY` is a module that provides a templatized paged sparse array data structure. The array has a maximum size and allocates memory in pages (groups of elements) on demand. When all elements in a page are released, the page is automatically freed.\n+\n+`PAGED_SPARSE_ARRAY` is a kind of `THANDLE`, all of the `THANDLE`'s API apply to `PAGED_SPARSE_ARRAY`. The following macros are provided with the same semantics as those of `THANDLE`'s:\n+- `PAGED_SPARSE_ARRAY_INITIALIZE(T)`\n+- `PAGED_SPARSE_ARRAY_ASSIGN(T)`\n+- `PAGED_SPARSE_ARRAY_MOVE(T)`\n+- `PAGED_SPARSE_ARRAY_INITIALIZE_MOVE(T)`\n+\n+## Design\n+\n+The array is organized into pages. Each page contains `page_size` elements. The total number of elements that can be stored is `max_size`. Pages are allocated lazily when an element is first allocated within that page. When all elements in a page are released, the page is automatically freed.\n+\n+Each element has an allocation state (allocated or not allocated). The user can:\n+- Allocate an index for usage (fails if already allocated)\n+- Release an index (when all indexes in a page are released, the page is freed)\n+- Allocate or get an index (allocates if not exists, gets if exists)\n+- Get an index (fails if not allocated)\n+\n+## Exposed API\n+\n+```c\n+/*to be used as the type of handle that wraps T*/\n+#define PAGED_SPARSE_ARRAY(T)\n+\n+/*to be used in a header file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+\n+/*to be used in a .c file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+```\n+\n+The macros expand to these useful APIs:\n+\n+```c\n+PAGED_SPARSE_ARRAY(T) PAGED_SPARSE_ARRAY_CREATE(T)(uint32_t max_size, uint32_t page_size);\n+void PAGED_SPARSE_ARRAY_FREE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array);\n+T* PAGED_SPARSE_ARRAY_ALLOCATE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+int PAGED_SPARSE_ARRAY_RELEASE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+T* PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+T* PAGED_SPARSE_ARRAY_GET(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+```\n+\n+### PAGED_SPARSE_ARRAY(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY(T)` is a `THANDLE`(`PAGED_SPARSE_ARRAY_STRUCT_T`), where `PAGED_SPARSE_ARRAY_STRUCT_T` is a structure that holds the paged sparse array data.\n+\n+### PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)` is a macro to be used in a header declaration.\n+\n+It introduces the APIs (as MOCKABLE_FUNCTIONS) that can be called for a `PAGED_SPARSE_ARRAY`.\n+\n+Example usage:\n+\n+```c\n+PAGED_SPARSE_ARRAY_TYPE_DECLARE(int32_t);","path":"devdoc/paged_sparse_array_requirements.md","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"aaaah - this introduces the type of array that holds `int32_t`s. Got it. ","created_at":"2026-01-12T13:16:05Z","updated_at":"2026-01-12T13:16:05Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682233762","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682233762"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682233762"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682233762/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":68,"original_line":68,"side":"RIGHT","in_reply_to_id":2682229087,"author_association":"MEMBER","original_position":68,"position":68,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682242523","pull_request_review_id":3650728302,"id":2682242523,"node_id":"PRRC_kwDODaUZTc6f38Xb","diff_hunk":"@@ -0,0 +1,209 @@\n+# `paged_sparse_array` requirements\n+\n+## Overview\n+\n+`PAGED_SPARSE_ARRAY` is a module that provides a templatized paged sparse array data structure. The array has a maximum size and allocates memory in pages (groups of elements) on demand. When all elements in a page are released, the page is automatically freed.\n+\n+`PAGED_SPARSE_ARRAY` is a kind of `THANDLE`, all of the `THANDLE`'s API apply to `PAGED_SPARSE_ARRAY`. The following macros are provided with the same semantics as those of `THANDLE`'s:\n+- `PAGED_SPARSE_ARRAY_INITIALIZE(T)`\n+- `PAGED_SPARSE_ARRAY_ASSIGN(T)`\n+- `PAGED_SPARSE_ARRAY_MOVE(T)`\n+- `PAGED_SPARSE_ARRAY_INITIALIZE_MOVE(T)`\n+\n+## Design","path":"devdoc/paged_sparse_array_requirements.md","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":">Design [](http://example.com/codeflow?start=3&length=6)\r\n\r\nDesign should mention what is the target threading model here.\r\n\r\nWe know (PAGED_SPARSE_ARRAY) is a THANDLE - so ownership of the array is multithreaded.\r\n\r\nBut what about the data inside the array? What are the access patterns and target threading model over the data hosted in the array?","created_at":"2026-01-12T13:18:38Z","updated_at":"2026-01-12T13:18:38Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682242523","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682242523"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682242523"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682242523/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":13,"original_line":13,"side":"RIGHT","author_association":"MEMBER","original_position":13,"position":13,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682259763","pull_request_review_id":3650748108,"id":2682259763,"node_id":"PRRC_kwDODaUZTc6f4Akz","diff_hunk":"@@ -0,0 +1,209 @@\n+# `paged_sparse_array` requirements\n+\n+## Overview\n+\n+`PAGED_SPARSE_ARRAY` is a module that provides a templatized paged sparse array data structure. The array has a maximum size and allocates memory in pages (groups of elements) on demand. When all elements in a page are released, the page is automatically freed.\n+\n+`PAGED_SPARSE_ARRAY` is a kind of `THANDLE`, all of the `THANDLE`'s API apply to `PAGED_SPARSE_ARRAY`. The following macros are provided with the same semantics as those of `THANDLE`'s:\n+- `PAGED_SPARSE_ARRAY_INITIALIZE(T)`\n+- `PAGED_SPARSE_ARRAY_ASSIGN(T)`\n+- `PAGED_SPARSE_ARRAY_MOVE(T)`\n+- `PAGED_SPARSE_ARRAY_INITIALIZE_MOVE(T)`\n+\n+## Design","path":"devdoc/paged_sparse_array_requirements.md","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":">Design [](http://example.com/codeflow?start=3&length=6)\r\n\r\nI am going to say that a nice ascii graphic that would show the array with the pages of the array and the pointers? in different stages of allocation wouild be greatly appreciated here ","created_at":"2026-01-12T13:22:53Z","updated_at":"2026-01-12T13:22:54Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682259763","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682259763"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682259763"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682259763/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":13,"original_line":13,"side":"RIGHT","author_association":"MEMBER","original_position":13,"position":13,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682261859","pull_request_review_id":3650751028,"id":2682261859,"node_id":"PRRC_kwDODaUZTc6f4BFj","diff_hunk":"@@ -0,0 +1,209 @@\n+# `paged_sparse_array` requirements\n+\n+## Overview\n+\n+`PAGED_SPARSE_ARRAY` is a module that provides a templatized paged sparse array data structure. The array has a maximum size and allocates memory in pages (groups of elements) on demand. When all elements in a page are released, the page is automatically freed.\n+\n+`PAGED_SPARSE_ARRAY` is a kind of `THANDLE`, all of the `THANDLE`'s API apply to `PAGED_SPARSE_ARRAY`. The following macros are provided with the same semantics as those of `THANDLE`'s:\n+- `PAGED_SPARSE_ARRAY_INITIALIZE(T)`\n+- `PAGED_SPARSE_ARRAY_ASSIGN(T)`\n+- `PAGED_SPARSE_ARRAY_MOVE(T)`\n+- `PAGED_SPARSE_ARRAY_INITIALIZE_MOVE(T)`\n+\n+## Design\n+\n+The array is organized into pages. Each page contains `page_size` elements. The total number of elements that can be stored is `max_size`. Pages are allocated lazily when an element is first allocated within that page. When all elements in a page are released, the page is automatically freed.\n+\n+Each element has an allocation state (allocated or not allocated). The user can:\n+- Allocate an index for usage (fails if already allocated)\n+- Release an index (when all indexes in a page are released, the page is freed)\n+- Allocate or get an index (allocates if not exists, gets if exists)\n+- Get an index (fails if not allocated)\n+\n+## Exposed API\n+\n+```c\n+/*to be used as the type of handle that wraps T*/\n+#define PAGED_SPARSE_ARRAY(T)\n+\n+/*to be used in a header file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+\n+/*to be used in a .c file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+```\n+\n+The macros expand to these useful APIs:\n+\n+```c\n+PAGED_SPARSE_ARRAY(T) PAGED_SPARSE_ARRAY_CREATE(T)(uint32_t max_size, uint32_t page_size);\n+void PAGED_SPARSE_ARRAY_FREE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array);\n+T* PAGED_SPARSE_ARRAY_ALLOCATE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+int PAGED_SPARSE_ARRAY_RELEASE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+T* PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+T* PAGED_SPARSE_ARRAY_GET(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+```\n+\n+### PAGED_SPARSE_ARRAY(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY(T)` is a `THANDLE`(`PAGED_SPARSE_ARRAY_STRUCT_T`), where `PAGED_SPARSE_ARRAY_STRUCT_T` is a structure that holds the paged sparse array data.\n+\n+### PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)` is a macro to be used in a header declaration.\n+\n+It introduces the APIs (as MOCKABLE_FUNCTIONS) that can be called for a `PAGED_SPARSE_ARRAY`.\n+\n+Example usage:\n+\n+```c\n+PAGED_SPARSE_ARRAY_TYPE_DECLARE(int32_t);\n+```\n+\n+### PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)` is a macro to be used in a .c file to define all the needed functions for `PAGED_SPARSE_ARRAY(T)`.\n+\n+Example usage:\n+\n+```c\n+PAGED_SPARSE_ARRAY_TYPE_DEFINE(int32_t);\n+```\n+\n+### PAGED_SPARSE_ARRAY_CREATE(T)\n+\n+```c\n+PAGED_SPARSE_ARRAY(T) PAGED_SPARSE_ARRAY_CREATE(T)(uint32_t max_size, uint32_t page_size);\n+```\n+\n+`PAGED_SPARSE_ARRAY_CREATE(T)` creates a new paged sparse array with the specified maximum size and page size.\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_001: [** If `max_size` is zero, `PAGED_SPARSE_ARRAY_CREATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_002: [** If `page_size` is zero, `PAGED_SPARSE_ARRAY_CREATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_003: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall compute the number of pages as `(max_size + page_size - 1) / page_size`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_004: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall call `THANDLE_MALLOC_FLEX` to allocate memory for the paged sparse array with the number of pages. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_005: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall set all page pointers to `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_006: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall store `max_size` and `page_size` in the structure. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_007: [** If there are any errors, `PAGED_SPARSE_ARRAY_CREATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_008: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall succeed and return a non-`NULL` value. **]**\n+\n+### PAGED_SPARSE_ARRAY_FREE(T)\n+\n+```c\n+void PAGED_SPARSE_ARRAY_FREE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array);","path":"devdoc/paged_sparse_array_requirements.md","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":">void [](http://example.com/codeflow?start=0&length=4)\r\n\r\naaaah. looks like it should be static.","created_at":"2026-01-12T13:23:23Z","updated_at":"2026-01-12T13:23:23Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682261859","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682261859"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682261859"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682261859/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":112,"original_line":112,"side":"RIGHT","author_association":"MEMBER","original_position":112,"position":112,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682273705","pull_request_review_id":3650765000,"id":2682273705,"node_id":"PRRC_kwDODaUZTc6f4D-p","diff_hunk":"@@ -0,0 +1,209 @@\n+# `paged_sparse_array` requirements\n+\n+## Overview\n+\n+`PAGED_SPARSE_ARRAY` is a module that provides a templatized paged sparse array data structure. The array has a maximum size and allocates memory in pages (groups of elements) on demand. When all elements in a page are released, the page is automatically freed.\n+\n+`PAGED_SPARSE_ARRAY` is a kind of `THANDLE`, all of the `THANDLE`'s API apply to `PAGED_SPARSE_ARRAY`. The following macros are provided with the same semantics as those of `THANDLE`'s:\n+- `PAGED_SPARSE_ARRAY_INITIALIZE(T)`\n+- `PAGED_SPARSE_ARRAY_ASSIGN(T)`\n+- `PAGED_SPARSE_ARRAY_MOVE(T)`\n+- `PAGED_SPARSE_ARRAY_INITIALIZE_MOVE(T)`\n+\n+## Design\n+\n+The array is organized into pages. Each page contains `page_size` elements. The total number of elements that can be stored is `max_size`. Pages are allocated lazily when an element is first allocated within that page. When all elements in a page are released, the page is automatically freed.\n+\n+Each element has an allocation state (allocated or not allocated). The user can:\n+- Allocate an index for usage (fails if already allocated)\n+- Release an index (when all indexes in a page are released, the page is freed)\n+- Allocate or get an index (allocates if not exists, gets if exists)\n+- Get an index (fails if not allocated)\n+\n+## Exposed API\n+\n+```c\n+/*to be used as the type of handle that wraps T*/\n+#define PAGED_SPARSE_ARRAY(T)\n+\n+/*to be used in a header file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+\n+/*to be used in a .c file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+```\n+\n+The macros expand to these useful APIs:\n+\n+```c\n+PAGED_SPARSE_ARRAY(T) PAGED_SPARSE_ARRAY_CREATE(T)(uint32_t max_size, uint32_t page_size);\n+void PAGED_SPARSE_ARRAY_FREE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array);\n+T* PAGED_SPARSE_ARRAY_ALLOCATE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+int PAGED_SPARSE_ARRAY_RELEASE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+T* PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+T* PAGED_SPARSE_ARRAY_GET(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+```\n+\n+### PAGED_SPARSE_ARRAY(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY(T)` is a `THANDLE`(`PAGED_SPARSE_ARRAY_STRUCT_T`), where `PAGED_SPARSE_ARRAY_STRUCT_T` is a structure that holds the paged sparse array data.\n+\n+### PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)` is a macro to be used in a header declaration.\n+\n+It introduces the APIs (as MOCKABLE_FUNCTIONS) that can be called for a `PAGED_SPARSE_ARRAY`.\n+\n+Example usage:\n+\n+```c\n+PAGED_SPARSE_ARRAY_TYPE_DECLARE(int32_t);\n+```\n+\n+### PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)` is a macro to be used in a .c file to define all the needed functions for `PAGED_SPARSE_ARRAY(T)`.\n+\n+Example usage:\n+\n+```c\n+PAGED_SPARSE_ARRAY_TYPE_DEFINE(int32_t);\n+```\n+\n+### PAGED_SPARSE_ARRAY_CREATE(T)\n+\n+```c\n+PAGED_SPARSE_ARRAY(T) PAGED_SPARSE_ARRAY_CREATE(T)(uint32_t max_size, uint32_t page_size);\n+```\n+\n+`PAGED_SPARSE_ARRAY_CREATE(T)` creates a new paged sparse array with the specified maximum size and page size.\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_001: [** If `max_size` is zero, `PAGED_SPARSE_ARRAY_CREATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_002: [** If `page_size` is zero, `PAGED_SPARSE_ARRAY_CREATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_003: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall compute the number of pages as `(max_size + page_size - 1) / page_size`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_004: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall call `THANDLE_MALLOC_FLEX` to allocate memory for the paged sparse array with the number of pages. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_005: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall set all page pointers to `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_006: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall store `max_size` and `page_size` in the structure. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_007: [** If there are any errors, `PAGED_SPARSE_ARRAY_CREATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_008: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall succeed and return a non-`NULL` value. **]**\n+\n+### PAGED_SPARSE_ARRAY_FREE(T)\n+\n+```c\n+void PAGED_SPARSE_ARRAY_FREE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array);\n+```\n+\n+`PAGED_SPARSE_ARRAY_FREE(T)` is called when there are no more references to the paged sparse array and the contents should be disposed of. This is used as the dispose function for THANDLE.\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_009: [** If `paged_sparse_array` is `NULL`, `PAGED_SPARSE_ARRAY_FREE(T)` shall return. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_010: [** `PAGED_SPARSE_ARRAY_FREE(T)` shall free all pages that are non-`NULL`. **]**\n+\n+### PAGED_SPARSE_ARRAY_ALLOCATE(T)\n+\n+```c\n+T* PAGED_SPARSE_ARRAY_ALLOCATE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+```\n+\n+`PAGED_SPARSE_ARRAY_ALLOCATE(T)` allocates an element at the specified index for usage.\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_011: [** If `paged_sparse_array` is `NULL`, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_012: [** If `index` is greater than or equal to `max_size`, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_013: [** `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall compute the page index as `index / page_size`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_014: [** If the page is not allocated, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall allocate memory for the page containing `page_size` elements and an allocation bitmap, and initialize all elements as not allocated. **]**","path":"devdoc/paged_sparse_array_requirements.md","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":">If the page is not allocated, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall allocate memory for the page containing `page_size` elements and an allocation bitmap, and initialize all elements as not allocated. [](http://example.com/codeflow?start=37&length=201)\r\n\r\nmyeah, seeing here that there's no locks taken or other elements of threading involved, Iam going to assume that the data itself is non-threaded. Only ownership is threaded. Interesting.","created_at":"2026-01-12T13:26:29Z","updated_at":"2026-01-12T13:26:29Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682273705","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682273705"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682273705"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682273705/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":135,"original_line":135,"side":"RIGHT","author_association":"MEMBER","original_position":135,"position":135,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682278434","pull_request_review_id":3650770032,"id":2682278434,"node_id":"PRRC_kwDODaUZTc6f4FIi","diff_hunk":"@@ -0,0 +1,209 @@\n+# `paged_sparse_array` requirements\n+\n+## Overview\n+\n+`PAGED_SPARSE_ARRAY` is a module that provides a templatized paged sparse array data structure. The array has a maximum size and allocates memory in pages (groups of elements) on demand. When all elements in a page are released, the page is automatically freed.\n+\n+`PAGED_SPARSE_ARRAY` is a kind of `THANDLE`, all of the `THANDLE`'s API apply to `PAGED_SPARSE_ARRAY`. The following macros are provided with the same semantics as those of `THANDLE`'s:\n+- `PAGED_SPARSE_ARRAY_INITIALIZE(T)`\n+- `PAGED_SPARSE_ARRAY_ASSIGN(T)`\n+- `PAGED_SPARSE_ARRAY_MOVE(T)`\n+- `PAGED_SPARSE_ARRAY_INITIALIZE_MOVE(T)`\n+\n+## Design\n+\n+The array is organized into pages. Each page contains `page_size` elements. The total number of elements that can be stored is `max_size`. Pages are allocated lazily when an element is first allocated within that page. When all elements in a page are released, the page is automatically freed.\n+\n+Each element has an allocation state (allocated or not allocated). The user can:\n+- Allocate an index for usage (fails if already allocated)\n+- Release an index (when all indexes in a page are released, the page is freed)\n+- Allocate or get an index (allocates if not exists, gets if exists)\n+- Get an index (fails if not allocated)\n+\n+## Exposed API\n+\n+```c\n+/*to be used as the type of handle that wraps T*/\n+#define PAGED_SPARSE_ARRAY(T)\n+\n+/*to be used in a header file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+\n+/*to be used in a .c file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+```\n+\n+The macros expand to these useful APIs:\n+\n+```c\n+PAGED_SPARSE_ARRAY(T) PAGED_SPARSE_ARRAY_CREATE(T)(uint32_t max_size, uint32_t page_size);\n+void PAGED_SPARSE_ARRAY_FREE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array);\n+T* PAGED_SPARSE_ARRAY_ALLOCATE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+int PAGED_SPARSE_ARRAY_RELEASE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+T* PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+T* PAGED_SPARSE_ARRAY_GET(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+```\n+\n+### PAGED_SPARSE_ARRAY(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY(T)` is a `THANDLE`(`PAGED_SPARSE_ARRAY_STRUCT_T`), where `PAGED_SPARSE_ARRAY_STRUCT_T` is a structure that holds the paged sparse array data.\n+\n+### PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)` is a macro to be used in a header declaration.\n+\n+It introduces the APIs (as MOCKABLE_FUNCTIONS) that can be called for a `PAGED_SPARSE_ARRAY`.\n+\n+Example usage:\n+\n+```c\n+PAGED_SPARSE_ARRAY_TYPE_DECLARE(int32_t);\n+```\n+\n+### PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)` is a macro to be used in a .c file to define all the needed functions for `PAGED_SPARSE_ARRAY(T)`.\n+\n+Example usage:\n+\n+```c\n+PAGED_SPARSE_ARRAY_TYPE_DEFINE(int32_t);\n+```\n+\n+### PAGED_SPARSE_ARRAY_CREATE(T)\n+\n+```c\n+PAGED_SPARSE_ARRAY(T) PAGED_SPARSE_ARRAY_CREATE(T)(uint32_t max_size, uint32_t page_size);\n+```\n+\n+`PAGED_SPARSE_ARRAY_CREATE(T)` creates a new paged sparse array with the specified maximum size and page size.\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_001: [** If `max_size` is zero, `PAGED_SPARSE_ARRAY_CREATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_002: [** If `page_size` is zero, `PAGED_SPARSE_ARRAY_CREATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_003: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall compute the number of pages as `(max_size + page_size - 1) / page_size`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_004: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall call `THANDLE_MALLOC_FLEX` to allocate memory for the paged sparse array with the number of pages. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_005: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall set all page pointers to `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_006: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall store `max_size` and `page_size` in the structure. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_007: [** If there are any errors, `PAGED_SPARSE_ARRAY_CREATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_008: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall succeed and return a non-`NULL` value. **]**\n+\n+### PAGED_SPARSE_ARRAY_FREE(T)\n+\n+```c\n+void PAGED_SPARSE_ARRAY_FREE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array);\n+```\n+\n+`PAGED_SPARSE_ARRAY_FREE(T)` is called when there are no more references to the paged sparse array and the contents should be disposed of. This is used as the dispose function for THANDLE.\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_009: [** If `paged_sparse_array` is `NULL`, `PAGED_SPARSE_ARRAY_FREE(T)` shall return. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_010: [** `PAGED_SPARSE_ARRAY_FREE(T)` shall free all pages that are non-`NULL`. **]**\n+\n+### PAGED_SPARSE_ARRAY_ALLOCATE(T)\n+\n+```c\n+T* PAGED_SPARSE_ARRAY_ALLOCATE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+```\n+\n+`PAGED_SPARSE_ARRAY_ALLOCATE(T)` allocates an element at the specified index for usage.\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_011: [** If `paged_sparse_array` is `NULL`, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_012: [** If `index` is greater than or equal to `max_size`, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_013: [** `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall compute the page index as `index / page_size`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_014: [** If the page is not allocated, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall allocate memory for the page containing `page_size` elements and an allocation bitmap, and initialize all elements as not allocated. **]**","path":"devdoc/paged_sparse_array_requirements.md","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"> and an allocation bitmap [](http://example.com/codeflow?start=166&length=25)\r\n\r\nThis is a bit mysterious and it is mentioned here the 2nd time - what is this bitmap? Would be nice to know by this time.\r\n\r\nIs is a bit-array? byte array? some other structure?","created_at":"2026-01-12T13:27:46Z","updated_at":"2026-01-12T13:27:46Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682278434","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682278434"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682278434"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682278434/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":135,"original_line":135,"side":"RIGHT","author_association":"MEMBER","original_position":135,"position":135,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682281728","pull_request_review_id":3650773666,"id":2682281728,"node_id":"PRRC_kwDODaUZTc6f4F8A","diff_hunk":"@@ -0,0 +1,209 @@\n+# `paged_sparse_array` requirements\n+\n+## Overview\n+\n+`PAGED_SPARSE_ARRAY` is a module that provides a templatized paged sparse array data structure. The array has a maximum size and allocates memory in pages (groups of elements) on demand. When all elements in a page are released, the page is automatically freed.\n+\n+`PAGED_SPARSE_ARRAY` is a kind of `THANDLE`, all of the `THANDLE`'s API apply to `PAGED_SPARSE_ARRAY`. The following macros are provided with the same semantics as those of `THANDLE`'s:\n+- `PAGED_SPARSE_ARRAY_INITIALIZE(T)`\n+- `PAGED_SPARSE_ARRAY_ASSIGN(T)`\n+- `PAGED_SPARSE_ARRAY_MOVE(T)`\n+- `PAGED_SPARSE_ARRAY_INITIALIZE_MOVE(T)`\n+\n+## Design\n+\n+The array is organized into pages. Each page contains `page_size` elements. The total number of elements that can be stored is `max_size`. Pages are allocated lazily when an element is first allocated within that page. When all elements in a page are released, the page is automatically freed.\n+\n+Each element has an allocation state (allocated or not allocated). The user can:\n+- Allocate an index for usage (fails if already allocated)\n+- Release an index (when all indexes in a page are released, the page is freed)\n+- Allocate or get an index (allocates if not exists, gets if exists)\n+- Get an index (fails if not allocated)\n+\n+## Exposed API\n+\n+```c\n+/*to be used as the type of handle that wraps T*/\n+#define PAGED_SPARSE_ARRAY(T)\n+\n+/*to be used in a header file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+\n+/*to be used in a .c file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+```\n+\n+The macros expand to these useful APIs:\n+\n+```c\n+PAGED_SPARSE_ARRAY(T) PAGED_SPARSE_ARRAY_CREATE(T)(uint32_t max_size, uint32_t page_size);\n+void PAGED_SPARSE_ARRAY_FREE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array);\n+T* PAGED_SPARSE_ARRAY_ALLOCATE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+int PAGED_SPARSE_ARRAY_RELEASE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+T* PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+T* PAGED_SPARSE_ARRAY_GET(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+```\n+\n+### PAGED_SPARSE_ARRAY(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY(T)` is a `THANDLE`(`PAGED_SPARSE_ARRAY_STRUCT_T`), where `PAGED_SPARSE_ARRAY_STRUCT_T` is a structure that holds the paged sparse array data.\n+\n+### PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)` is a macro to be used in a header declaration.\n+\n+It introduces the APIs (as MOCKABLE_FUNCTIONS) that can be called for a `PAGED_SPARSE_ARRAY`.\n+\n+Example usage:\n+\n+```c\n+PAGED_SPARSE_ARRAY_TYPE_DECLARE(int32_t);\n+```\n+\n+### PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)` is a macro to be used in a .c file to define all the needed functions for `PAGED_SPARSE_ARRAY(T)`.\n+\n+Example usage:\n+\n+```c\n+PAGED_SPARSE_ARRAY_TYPE_DEFINE(int32_t);\n+```\n+\n+### PAGED_SPARSE_ARRAY_CREATE(T)\n+\n+```c\n+PAGED_SPARSE_ARRAY(T) PAGED_SPARSE_ARRAY_CREATE(T)(uint32_t max_size, uint32_t page_size);\n+```\n+\n+`PAGED_SPARSE_ARRAY_CREATE(T)` creates a new paged sparse array with the specified maximum size and page size.\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_001: [** If `max_size` is zero, `PAGED_SPARSE_ARRAY_CREATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_002: [** If `page_size` is zero, `PAGED_SPARSE_ARRAY_CREATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_003: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall compute the number of pages as `(max_size + page_size - 1) / page_size`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_004: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall call `THANDLE_MALLOC_FLEX` to allocate memory for the paged sparse array with the number of pages. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_005: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall set all page pointers to `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_006: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall store `max_size` and `page_size` in the structure. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_007: [** If there are any errors, `PAGED_SPARSE_ARRAY_CREATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_008: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall succeed and return a non-`NULL` value. **]**\n+\n+### PAGED_SPARSE_ARRAY_FREE(T)\n+\n+```c\n+void PAGED_SPARSE_ARRAY_FREE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array);\n+```\n+\n+`PAGED_SPARSE_ARRAY_FREE(T)` is called when there are no more references to the paged sparse array and the contents should be disposed of. This is used as the dispose function for THANDLE.\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_009: [** If `paged_sparse_array` is `NULL`, `PAGED_SPARSE_ARRAY_FREE(T)` shall return. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_010: [** `PAGED_SPARSE_ARRAY_FREE(T)` shall free all pages that are non-`NULL`. **]**\n+\n+### PAGED_SPARSE_ARRAY_ALLOCATE(T)\n+\n+```c\n+T* PAGED_SPARSE_ARRAY_ALLOCATE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+```\n+\n+`PAGED_SPARSE_ARRAY_ALLOCATE(T)` allocates an element at the specified index for usage.\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_011: [** If `paged_sparse_array` is `NULL`, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_012: [** If `index` is greater than or equal to `max_size`, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_013: [** `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall compute the page index as `index / page_size`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_014: [** If the page is not allocated, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall allocate memory for the page containing `page_size` elements and an allocation bitmap, and initialize all elements as not allocated. **]**","path":"devdoc/paged_sparse_array_requirements.md","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":">shall allocate memory [](http://example.com/codeflow?start=100&length=21)\r\n\r\nwould be nice to know about how much memory is going to allocate and by which memory call function.\r\n\r\nNotice how line 99 for example lists the memory API that is used... ","created_at":"2026-01-12T13:28:43Z","updated_at":"2026-01-12T13:28:43Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682281728","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682281728"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682281728"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682281728/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":135,"original_line":135,"side":"RIGHT","author_association":"MEMBER","original_position":135,"position":135,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682286882","pull_request_review_id":3650779527,"id":2682286882,"node_id":"PRRC_kwDODaUZTc6f4HMi","diff_hunk":"@@ -0,0 +1,209 @@\n+# `paged_sparse_array` requirements\n+\n+## Overview\n+\n+`PAGED_SPARSE_ARRAY` is a module that provides a templatized paged sparse array data structure. The array has a maximum size and allocates memory in pages (groups of elements) on demand. When all elements in a page are released, the page is automatically freed.\n+\n+`PAGED_SPARSE_ARRAY` is a kind of `THANDLE`, all of the `THANDLE`'s API apply to `PAGED_SPARSE_ARRAY`. The following macros are provided with the same semantics as those of `THANDLE`'s:\n+- `PAGED_SPARSE_ARRAY_INITIALIZE(T)`\n+- `PAGED_SPARSE_ARRAY_ASSIGN(T)`\n+- `PAGED_SPARSE_ARRAY_MOVE(T)`\n+- `PAGED_SPARSE_ARRAY_INITIALIZE_MOVE(T)`\n+\n+## Design\n+\n+The array is organized into pages. Each page contains `page_size` elements. The total number of elements that can be stored is `max_size`. Pages are allocated lazily when an element is first allocated within that page. When all elements in a page are released, the page is automatically freed.\n+\n+Each element has an allocation state (allocated or not allocated). The user can:\n+- Allocate an index for usage (fails if already allocated)\n+- Release an index (when all indexes in a page are released, the page is freed)\n+- Allocate or get an index (allocates if not exists, gets if exists)\n+- Get an index (fails if not allocated)\n+\n+## Exposed API\n+\n+```c\n+/*to be used as the type of handle that wraps T*/\n+#define PAGED_SPARSE_ARRAY(T)\n+\n+/*to be used in a header file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+\n+/*to be used in a .c file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+```\n+\n+The macros expand to these useful APIs:\n+\n+```c\n+PAGED_SPARSE_ARRAY(T) PAGED_SPARSE_ARRAY_CREATE(T)(uint32_t max_size, uint32_t page_size);\n+void PAGED_SPARSE_ARRAY_FREE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array);\n+T* PAGED_SPARSE_ARRAY_ALLOCATE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+int PAGED_SPARSE_ARRAY_RELEASE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+T* PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+T* PAGED_SPARSE_ARRAY_GET(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+```\n+\n+### PAGED_SPARSE_ARRAY(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY(T)` is a `THANDLE`(`PAGED_SPARSE_ARRAY_STRUCT_T`), where `PAGED_SPARSE_ARRAY_STRUCT_T` is a structure that holds the paged sparse array data.\n+\n+### PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)` is a macro to be used in a header declaration.\n+\n+It introduces the APIs (as MOCKABLE_FUNCTIONS) that can be called for a `PAGED_SPARSE_ARRAY`.\n+\n+Example usage:\n+\n+```c\n+PAGED_SPARSE_ARRAY_TYPE_DECLARE(int32_t);\n+```\n+\n+### PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)` is a macro to be used in a .c file to define all the needed functions for `PAGED_SPARSE_ARRAY(T)`.\n+\n+Example usage:\n+\n+```c\n+PAGED_SPARSE_ARRAY_TYPE_DEFINE(int32_t);\n+```\n+\n+### PAGED_SPARSE_ARRAY_CREATE(T)\n+\n+```c\n+PAGED_SPARSE_ARRAY(T) PAGED_SPARSE_ARRAY_CREATE(T)(uint32_t max_size, uint32_t page_size);\n+```\n+\n+`PAGED_SPARSE_ARRAY_CREATE(T)` creates a new paged sparse array with the specified maximum size and page size.\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_001: [** If `max_size` is zero, `PAGED_SPARSE_ARRAY_CREATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_002: [** If `page_size` is zero, `PAGED_SPARSE_ARRAY_CREATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_003: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall compute the number of pages as `(max_size + page_size - 1) / page_size`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_004: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall call `THANDLE_MALLOC_FLEX` to allocate memory for the paged sparse array with the number of pages. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_005: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall set all page pointers to `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_006: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall store `max_size` and `page_size` in the structure. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_007: [** If there are any errors, `PAGED_SPARSE_ARRAY_CREATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_008: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall succeed and return a non-`NULL` value. **]**\n+\n+### PAGED_SPARSE_ARRAY_FREE(T)\n+\n+```c\n+void PAGED_SPARSE_ARRAY_FREE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array);\n+```\n+\n+`PAGED_SPARSE_ARRAY_FREE(T)` is called when there are no more references to the paged sparse array and the contents should be disposed of. This is used as the dispose function for THANDLE.\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_009: [** If `paged_sparse_array` is `NULL`, `PAGED_SPARSE_ARRAY_FREE(T)` shall return. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_010: [** `PAGED_SPARSE_ARRAY_FREE(T)` shall free all pages that are non-`NULL`. **]**\n+\n+### PAGED_SPARSE_ARRAY_ALLOCATE(T)\n+\n+```c\n+T* PAGED_SPARSE_ARRAY_ALLOCATE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+```\n+\n+`PAGED_SPARSE_ARRAY_ALLOCATE(T)` allocates an element at the specified index for usage.\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_011: [** If `paged_sparse_array` is `NULL`, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_012: [** If `index` is greater than or equal to `max_size`, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_013: [** `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall compute the page index as `index / page_size`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_014: [** If the page is not allocated, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall allocate memory for the page containing `page_size` elements and an allocation bitmap, and initialize all elements as not allocated. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_015: [** If the element at `index` is already allocated, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall fail and return `NULL`. **]**","path":"devdoc/paged_sparse_array_requirements.md","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":">shall fail and return `NULL` [](http://example.com/codeflow?start=118&length=28)\r\n\r\nthis and line 143 are a bit conflating different root causes under the same umbrella of `something went wrong`.\r\n\r\nBut the causes are different.\r\n\r\ncause 1 is \"not enough memory\"\r\ncause 2 is \"probably user error and the array already has the element\"","created_at":"2026-01-12T13:30:11Z","updated_at":"2026-01-12T13:30:11Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682286882","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682286882"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682286882"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682286882/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":137,"original_line":137,"side":"RIGHT","author_association":"MEMBER","original_position":137,"position":137,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682293632","pull_request_review_id":3650787091,"id":2682293632,"node_id":"PRRC_kwDODaUZTc6f4I2A","diff_hunk":"@@ -0,0 +1,209 @@\n+# `paged_sparse_array` requirements\n+\n+## Overview\n+\n+`PAGED_SPARSE_ARRAY` is a module that provides a templatized paged sparse array data structure. The array has a maximum size and allocates memory in pages (groups of elements) on demand. When all elements in a page are released, the page is automatically freed.\n+\n+`PAGED_SPARSE_ARRAY` is a kind of `THANDLE`, all of the `THANDLE`'s API apply to `PAGED_SPARSE_ARRAY`. The following macros are provided with the same semantics as those of `THANDLE`'s:\n+- `PAGED_SPARSE_ARRAY_INITIALIZE(T)`\n+- `PAGED_SPARSE_ARRAY_ASSIGN(T)`\n+- `PAGED_SPARSE_ARRAY_MOVE(T)`\n+- `PAGED_SPARSE_ARRAY_INITIALIZE_MOVE(T)`\n+\n+## Design","path":"devdoc/paged_sparse_array_requirements.md","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":">Design [](http://example.com/codeflow?start=3&length=6)\r\n\r\nprobably design should mention if regular pointer arithmetic will not work/will not work with this data structure.\r\n\r\nFor example:\r\n\r\nT* first_element = PAGED_SPARSE_ARRAY_GET(T)(0);\r\nT* second_element = PAGED_SPARSE_ARRAY_GET(T)(1);\r\n\r\nMight not satisfy first_element+1 == second_element.","created_at":"2026-01-12T13:32:12Z","updated_at":"2026-01-12T13:32:12Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682293632","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682293632"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682293632"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682293632/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":13,"original_line":13,"side":"RIGHT","author_association":"MEMBER","original_position":13,"position":13,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682301633","pull_request_review_id":3650796304,"id":2682301633,"node_id":"PRRC_kwDODaUZTc6f4KzB","diff_hunk":"@@ -0,0 +1,209 @@\n+# `paged_sparse_array` requirements\n+\n+## Overview\n+\n+`PAGED_SPARSE_ARRAY` is a module that provides a templatized paged sparse array data structure. The array has a maximum size and allocates memory in pages (groups of elements) on demand. When all elements in a page are released, the page is automatically freed.\n+\n+`PAGED_SPARSE_ARRAY` is a kind of `THANDLE`, all of the `THANDLE`'s API apply to `PAGED_SPARSE_ARRAY`. The following macros are provided with the same semantics as those of `THANDLE`'s:\n+- `PAGED_SPARSE_ARRAY_INITIALIZE(T)`\n+- `PAGED_SPARSE_ARRAY_ASSIGN(T)`\n+- `PAGED_SPARSE_ARRAY_MOVE(T)`\n+- `PAGED_SPARSE_ARRAY_INITIALIZE_MOVE(T)`\n+\n+## Design\n+\n+The array is organized into pages. Each page contains `page_size` elements. The total number of elements that can be stored is `max_size`. Pages are allocated lazily when an element is first allocated within that page. When all elements in a page are released, the page is automatically freed.\n+\n+Each element has an allocation state (allocated or not allocated). The user can:\n+- Allocate an index for usage (fails if already allocated)\n+- Release an index (when all indexes in a page are released, the page is freed)\n+- Allocate or get an index (allocates if not exists, gets if exists)\n+- Get an index (fails if not allocated)\n+\n+## Exposed API\n+\n+```c\n+/*to be used as the type of handle that wraps T*/\n+#define PAGED_SPARSE_ARRAY(T)\n+\n+/*to be used in a header file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+\n+/*to be used in a .c file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+```\n+\n+The macros expand to these useful APIs:\n+\n+```c\n+PAGED_SPARSE_ARRAY(T) PAGED_SPARSE_ARRAY_CREATE(T)(uint32_t max_size, uint32_t page_size);\n+void PAGED_SPARSE_ARRAY_FREE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array);\n+T* PAGED_SPARSE_ARRAY_ALLOCATE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+int PAGED_SPARSE_ARRAY_RELEASE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+T* PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+T* PAGED_SPARSE_ARRAY_GET(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+```\n+\n+### PAGED_SPARSE_ARRAY(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY(T)` is a `THANDLE`(`PAGED_SPARSE_ARRAY_STRUCT_T`), where `PAGED_SPARSE_ARRAY_STRUCT_T` is a structure that holds the paged sparse array data.\n+\n+### PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)` is a macro to be used in a header declaration.\n+\n+It introduces the APIs (as MOCKABLE_FUNCTIONS) that can be called for a `PAGED_SPARSE_ARRAY`.\n+\n+Example usage:\n+\n+```c\n+PAGED_SPARSE_ARRAY_TYPE_DECLARE(int32_t);\n+```\n+\n+### PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)` is a macro to be used in a .c file to define all the needed functions for `PAGED_SPARSE_ARRAY(T)`.\n+\n+Example usage:\n+\n+```c\n+PAGED_SPARSE_ARRAY_TYPE_DEFINE(int32_t);\n+```\n+\n+### PAGED_SPARSE_ARRAY_CREATE(T)\n+\n+```c\n+PAGED_SPARSE_ARRAY(T) PAGED_SPARSE_ARRAY_CREATE(T)(uint32_t max_size, uint32_t page_size);\n+```\n+\n+`PAGED_SPARSE_ARRAY_CREATE(T)` creates a new paged sparse array with the specified maximum size and page size.\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_001: [** If `max_size` is zero, `PAGED_SPARSE_ARRAY_CREATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_002: [** If `page_size` is zero, `PAGED_SPARSE_ARRAY_CREATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_003: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall compute the number of pages as `(max_size + page_size - 1) / page_size`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_004: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall call `THANDLE_MALLOC_FLEX` to allocate memory for the paged sparse array with the number of pages. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_005: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall set all page pointers to `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_006: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall store `max_size` and `page_size` in the structure. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_007: [** If there are any errors, `PAGED_SPARSE_ARRAY_CREATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_008: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall succeed and return a non-`NULL` value. **]**\n+\n+### PAGED_SPARSE_ARRAY_FREE(T)\n+\n+```c\n+void PAGED_SPARSE_ARRAY_FREE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array);\n+```\n+\n+`PAGED_SPARSE_ARRAY_FREE(T)` is called when there are no more references to the paged sparse array and the contents should be disposed of. This is used as the dispose function for THANDLE.\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_009: [** If `paged_sparse_array` is `NULL`, `PAGED_SPARSE_ARRAY_FREE(T)` shall return. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_010: [** `PAGED_SPARSE_ARRAY_FREE(T)` shall free all pages that are non-`NULL`. **]**\n+\n+### PAGED_SPARSE_ARRAY_ALLOCATE(T)\n+\n+```c\n+T* PAGED_SPARSE_ARRAY_ALLOCATE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+```\n+\n+`PAGED_SPARSE_ARRAY_ALLOCATE(T)` allocates an element at the specified index for usage.\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_011: [** If `paged_sparse_array` is `NULL`, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_012: [** If `index` is greater than or equal to `max_size`, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_013: [** `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall compute the page index as `index / page_size`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_014: [** If the page is not allocated, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall allocate memory for the page containing `page_size` elements and an allocation bitmap, and initialize all elements as not allocated. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_015: [** If the element at `index` is already allocated, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_016: [** `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall mark the element at `index` as allocated. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_017: [** `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall return a pointer to the element at `index`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_018: [** If there are any errors, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall fail and return `NULL`. **]**\n+\n+### PAGED_SPARSE_ARRAY_RELEASE(T)\n+\n+```c\n+int PAGED_SPARSE_ARRAY_RELEASE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+```\n+\n+`PAGED_SPARSE_ARRAY_RELEASE(T)` releases the element at the specified index.\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_019: [** If `paged_sparse_array` is `NULL`, `PAGED_SPARSE_ARRAY_RELEASE(T)` shall fail and return a non-zero value. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_020: [** If `index` is greater than or equal to `max_size`, `PAGED_SPARSE_ARRAY_RELEASE(T)` shall fail and return a non-zero value. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_021: [** `PAGED_SPARSE_ARRAY_RELEASE(T)` shall compute the page index as `index / page_size`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_022: [** If the page is not allocated, `PAGED_SPARSE_ARRAY_RELEASE(T)` shall fail and return a non-zero value. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_023: [** If the element at `index` is not allocated, `PAGED_SPARSE_ARRAY_RELEASE(T)` shall fail and return a non-zero value. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_024: [** `PAGED_SPARSE_ARRAY_RELEASE(T)` shall mark the element at `index` as not allocated. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_025: [** If all elements in the page are now not allocated, `PAGED_SPARSE_ARRAY_RELEASE(T)` shall free the page and set the page pointer to `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_026: [** `PAGED_SPARSE_ARRAY_RELEASE(T)` shall return zero on success. **]**","path":"devdoc/paged_sparse_array_requirements.md","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":">zero [](http://example.com/codeflow?start=82&length=4)\r\n\r\nAs a user, I still don't know what to do with this value.","created_at":"2026-01-12T13:34:29Z","updated_at":"2026-01-12T13:34:29Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682301633","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682301633"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682301633"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682301633/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":167,"original_line":167,"side":"RIGHT","author_association":"MEMBER","original_position":167,"position":167,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682314707","pull_request_review_id":3650810401,"id":2682314707,"node_id":"PRRC_kwDODaUZTc6f4N_T","diff_hunk":"@@ -0,0 +1,209 @@\n+# `paged_sparse_array` requirements\n+\n+## Overview\n+\n+`PAGED_SPARSE_ARRAY` is a module that provides a templatized paged sparse array data structure. The array has a maximum size and allocates memory in pages (groups of elements) on demand. When all elements in a page are released, the page is automatically freed.\n+\n+`PAGED_SPARSE_ARRAY` is a kind of `THANDLE`, all of the `THANDLE`'s API apply to `PAGED_SPARSE_ARRAY`. The following macros are provided with the same semantics as those of `THANDLE`'s:\n+- `PAGED_SPARSE_ARRAY_INITIALIZE(T)`\n+- `PAGED_SPARSE_ARRAY_ASSIGN(T)`\n+- `PAGED_SPARSE_ARRAY_MOVE(T)`\n+- `PAGED_SPARSE_ARRAY_INITIALIZE_MOVE(T)`\n+\n+## Design\n+\n+The array is organized into pages. Each page contains `page_size` elements. The total number of elements that can be stored is `max_size`. Pages are allocated lazily when an element is first allocated within that page. When all elements in a page are released, the page is automatically freed.\n+\n+Each element has an allocation state (allocated or not allocated). The user can:\n+- Allocate an index for usage (fails if already allocated)\n+- Release an index (when all indexes in a page are released, the page is freed)\n+- Allocate or get an index (allocates if not exists, gets if exists)\n+- Get an index (fails if not allocated)\n+\n+## Exposed API\n+\n+```c\n+/*to be used as the type of handle that wraps T*/\n+#define PAGED_SPARSE_ARRAY(T)\n+\n+/*to be used in a header file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+\n+/*to be used in a .c file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+```\n+\n+The macros expand to these useful APIs:\n+\n+```c\n+PAGED_SPARSE_ARRAY(T) PAGED_SPARSE_ARRAY_CREATE(T)(uint32_t max_size, uint32_t page_size);\n+void PAGED_SPARSE_ARRAY_FREE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array);\n+T* PAGED_SPARSE_ARRAY_ALLOCATE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+int PAGED_SPARSE_ARRAY_RELEASE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+T* PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+T* PAGED_SPARSE_ARRAY_GET(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+```\n+\n+### PAGED_SPARSE_ARRAY(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY(T)` is a `THANDLE`(`PAGED_SPARSE_ARRAY_STRUCT_T`), where `PAGED_SPARSE_ARRAY_STRUCT_T` is a structure that holds the paged sparse array data.\n+\n+### PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)` is a macro to be used in a header declaration.\n+\n+It introduces the APIs (as MOCKABLE_FUNCTIONS) that can be called for a `PAGED_SPARSE_ARRAY`.\n+\n+Example usage:\n+\n+```c\n+PAGED_SPARSE_ARRAY_TYPE_DECLARE(int32_t);\n+```\n+\n+### PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+\n+```c\n+#define PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+```\n+\n+`PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)` is a macro to be used in a .c file to define all the needed functions for `PAGED_SPARSE_ARRAY(T)`.\n+\n+Example usage:\n+\n+```c\n+PAGED_SPARSE_ARRAY_TYPE_DEFINE(int32_t);\n+```\n+\n+### PAGED_SPARSE_ARRAY_CREATE(T)\n+\n+```c\n+PAGED_SPARSE_ARRAY(T) PAGED_SPARSE_ARRAY_CREATE(T)(uint32_t max_size, uint32_t page_size);\n+```\n+\n+`PAGED_SPARSE_ARRAY_CREATE(T)` creates a new paged sparse array with the specified maximum size and page size.\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_001: [** If `max_size` is zero, `PAGED_SPARSE_ARRAY_CREATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_002: [** If `page_size` is zero, `PAGED_SPARSE_ARRAY_CREATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_003: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall compute the number of pages as `(max_size + page_size - 1) / page_size`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_004: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall call `THANDLE_MALLOC_FLEX` to allocate memory for the paged sparse array with the number of pages. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_005: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall set all page pointers to `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_006: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall store `max_size` and `page_size` in the structure. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_007: [** If there are any errors, `PAGED_SPARSE_ARRAY_CREATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_008: [** `PAGED_SPARSE_ARRAY_CREATE(T)` shall succeed and return a non-`NULL` value. **]**\n+\n+### PAGED_SPARSE_ARRAY_FREE(T)\n+\n+```c\n+void PAGED_SPARSE_ARRAY_FREE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array);\n+```\n+\n+`PAGED_SPARSE_ARRAY_FREE(T)` is called when there are no more references to the paged sparse array and the contents should be disposed of. This is used as the dispose function for THANDLE.\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_009: [** If `paged_sparse_array` is `NULL`, `PAGED_SPARSE_ARRAY_FREE(T)` shall return. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_010: [** `PAGED_SPARSE_ARRAY_FREE(T)` shall free all pages that are non-`NULL`. **]**\n+\n+### PAGED_SPARSE_ARRAY_ALLOCATE(T)\n+\n+```c\n+T* PAGED_SPARSE_ARRAY_ALLOCATE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+```\n+\n+`PAGED_SPARSE_ARRAY_ALLOCATE(T)` allocates an element at the specified index for usage.\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_011: [** If `paged_sparse_array` is `NULL`, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_012: [** If `index` is greater than or equal to `max_size`, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_013: [** `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall compute the page index as `index / page_size`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_014: [** If the page is not allocated, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall allocate memory for the page containing `page_size` elements and an allocation bitmap, and initialize all elements as not allocated. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_015: [** If the element at `index` is already allocated, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall fail and return `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_016: [** `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall mark the element at `index` as allocated. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_017: [** `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall return a pointer to the element at `index`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_018: [** If there are any errors, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall fail and return `NULL`. **]**\n+\n+### PAGED_SPARSE_ARRAY_RELEASE(T)\n+\n+```c\n+int PAGED_SPARSE_ARRAY_RELEASE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+```\n+\n+`PAGED_SPARSE_ARRAY_RELEASE(T)` releases the element at the specified index.\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_019: [** If `paged_sparse_array` is `NULL`, `PAGED_SPARSE_ARRAY_RELEASE(T)` shall fail and return a non-zero value. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_020: [** If `index` is greater than or equal to `max_size`, `PAGED_SPARSE_ARRAY_RELEASE(T)` shall fail and return a non-zero value. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_021: [** `PAGED_SPARSE_ARRAY_RELEASE(T)` shall compute the page index as `index / page_size`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_022: [** If the page is not allocated, `PAGED_SPARSE_ARRAY_RELEASE(T)` shall fail and return a non-zero value. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_023: [** If the element at `index` is not allocated, `PAGED_SPARSE_ARRAY_RELEASE(T)` shall fail and return a non-zero value. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_024: [** `PAGED_SPARSE_ARRAY_RELEASE(T)` shall mark the element at `index` as not allocated. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_025: [** If all elements in the page are now not allocated, `PAGED_SPARSE_ARRAY_RELEASE(T)` shall free the page and set the page pointer to `NULL`. **]**\n+\n+**SRS_PAGED_SPARSE_ARRAY_88_026: [** `PAGED_SPARSE_ARRAY_RELEASE(T)` shall return zero on success. **]**\n+\n+### PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T)\n+\n+```c\n+T* PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+```\n+\n+`PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T)` allocates the element at the specified index if not already allocated, or gets it if it exists.","path":"devdoc/paged_sparse_array_requirements.md","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":">if not already allocated, or gets it if it exists. [](http://example.com/codeflow?start=85&length=50)\r\n\r\nwhat's the use case here? As a user I feel that I might use this when I don't care about what was stored before in the index and overwrite it? So this is intended to be write-only element?\r\n\r\nI am very much on the side of deterministic access","created_at":"2026-01-12T13:38:00Z","updated_at":"2026-01-12T13:38:00Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682314707","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682314707"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682314707"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682314707/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":175,"original_line":175,"side":"RIGHT","author_association":"MEMBER","original_position":175,"position":175,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682346268","pull_request_review_id":3650847617,"id":2682346268,"node_id":"PRRC_kwDODaUZTc6f4Vsc","diff_hunk":"@@ -0,0 +1,209 @@\n+# `paged_sparse_array` requirements\n+\n+## Overview\n+\n+`PAGED_SPARSE_ARRAY` is a module that provides a templatized paged sparse array data structure. The array has a maximum size and allocates memory in pages (groups of elements) on demand. When all elements in a page are released, the page is automatically freed.\n+\n+`PAGED_SPARSE_ARRAY` is a kind of `THANDLE`, all of the `THANDLE`'s API apply to `PAGED_SPARSE_ARRAY`. The following macros are provided with the same semantics as those of `THANDLE`'s:\n+- `PAGED_SPARSE_ARRAY_INITIALIZE(T)`\n+- `PAGED_SPARSE_ARRAY_ASSIGN(T)`\n+- `PAGED_SPARSE_ARRAY_MOVE(T)`\n+- `PAGED_SPARSE_ARRAY_INITIALIZE_MOVE(T)`\n+\n+## Design\n+\n+The array is organized into pages. Each page contains `page_size` elements. The total number of elements that can be stored is `max_size`. Pages are allocated lazily when an element is first allocated within that page. When all elements in a page are released, the page is automatically freed.\n+\n+Each element has an allocation state (allocated or not allocated). The user can:\n+- Allocate an index for usage (fails if already allocated)\n+- Release an index (when all indexes in a page are released, the page is freed)\n+- Allocate or get an index (allocates if not exists, gets if exists)\n+- Get an index (fails if not allocated)","path":"devdoc/paged_sparse_array_requirements.md","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"This does have some similarities with a hash table, with the hasing function set to index/page_size => page_number.\r\n\r\nAnd inside the page (bucket) it goes to index%page_size.\r\n\r\nbuckets are either empty/non-empty. \r\n\r\nbut I like this more than the hash table","created_at":"2026-01-12T13:46:08Z","updated_at":"2026-01-12T13:46:08Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682346268","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682346268"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682346268"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682346268/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":21,"original_line":21,"side":"RIGHT","author_association":"MEMBER","original_position":21,"position":21,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682360768","pull_request_review_id":3650863459,"id":2682360768,"node_id":"PRRC_kwDODaUZTc6f4ZPA","diff_hunk":"@@ -0,0 +1,414 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#ifndef PAGED_SPARSE_ARRAY_LL_H\n+#define PAGED_SPARSE_ARRAY_LL_H\n+\n+#ifdef __cplusplus\n+#include <cinttypes>\n+#include <cstdlib>\n+#else // __cplusplus\n+#include <inttypes.h>\n+#include <stdlib.h>\n+#endif // __cplusplus\n+\n+#include \"c_pal/gballoc_hl.h\"\n+#include \"c_pal/gballoc_hl_redirect.h\"\n+\n+#include \"macro_utils/macro_utils.h\"\n+\n+#include \"c_logging/logger.h\"\n+\n+#include \"c_pal/thandle_ll.h\"\n+\n+#include \"umock_c/umock_c_prod.h\"\n+\n+/*PAGED_SPARSE_ARRAY is backed by a THANDLE build on the structure below*/\n+#define PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T), _TAG)\n+\n+#define PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_STRUCT_, T)\n+\n+/*PAGE_STRUCT holds a single page with elements and allocation bitmap*/\n+#define PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T), _TAG)\n+#define PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_STRUCT_, T)\n+\n+/*PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) introduces the base type that holds the paged sparse array*/\n+#define PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(T)                                                                        \\\n+/*define the page structure first - bitmap is embedded after items[] in the same allocation*/                          \\\n+typedef struct PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T)                                                          \\\n+{                                                                                                                       \\\n+    uint32_t allocated_count;                                                                                           \\\n+    T items[];  /*followed by bitmap bytes at offset page_size * sizeof(T)*/                                            \\\n+} PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T);                                                                              \\\n+/*forward define the typedef of the PAGED_SPARSE_ARRAY struct so that it can be used for a function pointer definition*/\\\n+typedef struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T);                           \\\n+struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T)                                                                       \\\n+{                                                                                                                       \\\n+    uint32_t max_size;                                                                                                  \\\n+    uint32_t page_size;                                                                                                 \\\n+    uint32_t page_count;                                                                                                \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* pages[];                                                                   \\\n+};                                                                                                                      \\\n+\n+/*PAGED_SPARSE_ARRAY is-a THANDLE*/\n+/*given a type \"T\" PAGED_SPARSE_ARRAY_LL(T) expands to the name of the type. */\n+#define PAGED_SPARSE_ARRAY_LL(T) THANDLE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*because PAGED_SPARSE_ARRAY is a THANDLE, all THANDLE's macro APIs are useable with PAGED_SPARSE_ARRAY.*/\n+/*the below are just shortcuts of THANDLE's public ones*/\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE(T) THANDLE_INITIALIZE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_ASSIGN(T) THANDLE_ASSIGN(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_MOVE(T) THANDLE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE_MOVE(T) THANDLE_INITIALIZE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*introduces a new name for a function that returns a PAGED_SPARSE_ARRAY_LL(T)*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_CREATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_CREATE(C) PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C)\n+\n+/*introduces a name for the function that frees a PAGED_SPARSE_ARRAY when its ref count goes to 0*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_FREE_, C)\n+\n+/*introduces a name for the allocate function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C)\n+\n+/*introduces a name for the release function*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_RELEASE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE(C) PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C)\n+\n+/*introduces a name for the allocate_or_get function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C)\n+\n+/*introduces a name for the get function*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_GET(C) PAGED_SPARSE_ARRAY_LL_GET_NAME(C)\n+\n+/*introduces a function declaration for paged_sparse_array_create*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, PAGED_SPARSE_ARRAY_LL(T), PAGED_SPARSE_ARRAY_LL_CREATE(C), uint32_t, max_size, uint32_t, page_size);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_release*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, int, PAGED_SPARSE_ARRAY_LL_RELEASE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate_or_get*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_get*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*helper to compute bitmap size in bytes (1 bit per element, rounded up to nearest byte)*/\n+#define PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size) (((page_size) + 7) / 8)\n+\n+/*helper to get the allocation bitmap from a page - bitmap is stored after items[] in the same allocation*/\n+#define PAGED_SPARSE_ARRAY_GET_BITMAP(page, page_size, T) ((uint8_t*)((page)->items + (page_size)))","path":"inc/c_util/paged_sparse_array_ll.h","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":">T [](http://example.com/codeflow?start=55&length=1)\r\n\r\nweird, why is `T` not used in the macro expansion?","created_at":"2026-01-12T13:50:04Z","updated_at":"2026-01-12T13:50:04Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682360768","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682360768"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682360768"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682360768/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":111,"original_line":111,"side":"RIGHT","author_association":"MEMBER","original_position":111,"position":111,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682363313","pull_request_review_id":3650866053,"id":2682363313,"node_id":"PRRC_kwDODaUZTc6f4Z2x","diff_hunk":"@@ -0,0 +1,414 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#ifndef PAGED_SPARSE_ARRAY_LL_H\n+#define PAGED_SPARSE_ARRAY_LL_H\n+\n+#ifdef __cplusplus\n+#include <cinttypes>\n+#include <cstdlib>\n+#else // __cplusplus\n+#include <inttypes.h>\n+#include <stdlib.h>\n+#endif // __cplusplus\n+\n+#include \"c_pal/gballoc_hl.h\"\n+#include \"c_pal/gballoc_hl_redirect.h\"\n+\n+#include \"macro_utils/macro_utils.h\"\n+\n+#include \"c_logging/logger.h\"\n+\n+#include \"c_pal/thandle_ll.h\"\n+\n+#include \"umock_c/umock_c_prod.h\"\n+\n+/*PAGED_SPARSE_ARRAY is backed by a THANDLE build on the structure below*/\n+#define PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T), _TAG)\n+\n+#define PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_STRUCT_, T)\n+\n+/*PAGE_STRUCT holds a single page with elements and allocation bitmap*/\n+#define PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T), _TAG)\n+#define PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_STRUCT_, T)\n+\n+/*PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) introduces the base type that holds the paged sparse array*/\n+#define PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(T)                                                                        \\\n+/*define the page structure first - bitmap is embedded after items[] in the same allocation*/                          \\\n+typedef struct PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T)                                                          \\\n+{                                                                                                                       \\\n+    uint32_t allocated_count;                                                                                           \\\n+    T items[];  /*followed by bitmap bytes at offset page_size * sizeof(T)*/                                            \\\n+} PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T);                                                                              \\\n+/*forward define the typedef of the PAGED_SPARSE_ARRAY struct so that it can be used for a function pointer definition*/\\\n+typedef struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T);                           \\\n+struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T)                                                                       \\\n+{                                                                                                                       \\\n+    uint32_t max_size;                                                                                                  \\\n+    uint32_t page_size;                                                                                                 \\\n+    uint32_t page_count;                                                                                                \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* pages[];                                                                   \\\n+};                                                                                                                      \\\n+\n+/*PAGED_SPARSE_ARRAY is-a THANDLE*/\n+/*given a type \"T\" PAGED_SPARSE_ARRAY_LL(T) expands to the name of the type. */\n+#define PAGED_SPARSE_ARRAY_LL(T) THANDLE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*because PAGED_SPARSE_ARRAY is a THANDLE, all THANDLE's macro APIs are useable with PAGED_SPARSE_ARRAY.*/\n+/*the below are just shortcuts of THANDLE's public ones*/\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE(T) THANDLE_INITIALIZE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_ASSIGN(T) THANDLE_ASSIGN(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_MOVE(T) THANDLE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE_MOVE(T) THANDLE_INITIALIZE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*introduces a new name for a function that returns a PAGED_SPARSE_ARRAY_LL(T)*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_CREATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_CREATE(C) PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C)\n+\n+/*introduces a name for the function that frees a PAGED_SPARSE_ARRAY when its ref count goes to 0*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_FREE_, C)\n+\n+/*introduces a name for the allocate function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C)\n+\n+/*introduces a name for the release function*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_RELEASE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE(C) PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C)\n+\n+/*introduces a name for the allocate_or_get function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C)\n+\n+/*introduces a name for the get function*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_GET(C) PAGED_SPARSE_ARRAY_LL_GET_NAME(C)\n+\n+/*introduces a function declaration for paged_sparse_array_create*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, PAGED_SPARSE_ARRAY_LL(T), PAGED_SPARSE_ARRAY_LL_CREATE(C), uint32_t, max_size, uint32_t, page_size);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_release*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, int, PAGED_SPARSE_ARRAY_LL_RELEASE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate_or_get*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_get*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*helper to compute bitmap size in bytes (1 bit per element, rounded up to nearest byte)*/\n+#define PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size) (((page_size) + 7) / 8)\n+\n+/*helper to get the allocation bitmap from a page - bitmap is stored after items[] in the same allocation*/\n+#define PAGED_SPARSE_ARRAY_GET_BITMAP(page, page_size, T) ((uint8_t*)((page)->items + (page_size)))","path":"inc/c_util/paged_sparse_array_ll.h","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"shouldn't this be dependent on sizeof(T)?","created_at":"2026-01-12T13:50:39Z","updated_at":"2026-01-12T13:50:39Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682363313","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682363313"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682363313"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682363313/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":111,"original_line":111,"side":"RIGHT","in_reply_to_id":2682360768,"author_association":"MEMBER","original_position":111,"position":111,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682388780","pull_request_review_id":3650895030,"id":2682388780,"node_id":"PRRC_kwDODaUZTc6f4gEs","diff_hunk":"@@ -0,0 +1,414 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#ifndef PAGED_SPARSE_ARRAY_LL_H\n+#define PAGED_SPARSE_ARRAY_LL_H\n+\n+#ifdef __cplusplus\n+#include <cinttypes>\n+#include <cstdlib>\n+#else // __cplusplus\n+#include <inttypes.h>\n+#include <stdlib.h>\n+#endif // __cplusplus\n+\n+#include \"c_pal/gballoc_hl.h\"\n+#include \"c_pal/gballoc_hl_redirect.h\"\n+\n+#include \"macro_utils/macro_utils.h\"\n+\n+#include \"c_logging/logger.h\"\n+\n+#include \"c_pal/thandle_ll.h\"\n+\n+#include \"umock_c/umock_c_prod.h\"\n+\n+/*PAGED_SPARSE_ARRAY is backed by a THANDLE build on the structure below*/\n+#define PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T), _TAG)\n+\n+#define PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_STRUCT_, T)\n+\n+/*PAGE_STRUCT holds a single page with elements and allocation bitmap*/\n+#define PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T), _TAG)\n+#define PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_STRUCT_, T)\n+\n+/*PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) introduces the base type that holds the paged sparse array*/\n+#define PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(T)                                                                        \\\n+/*define the page structure first - bitmap is embedded after items[] in the same allocation*/                          \\\n+typedef struct PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T)                                                          \\\n+{                                                                                                                       \\\n+    uint32_t allocated_count;                                                                                           \\\n+    T items[];  /*followed by bitmap bytes at offset page_size * sizeof(T)*/                                            \\\n+} PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T);                                                                              \\\n+/*forward define the typedef of the PAGED_SPARSE_ARRAY struct so that it can be used for a function pointer definition*/\\\n+typedef struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T);                           \\\n+struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T)                                                                       \\\n+{                                                                                                                       \\\n+    uint32_t max_size;                                                                                                  \\\n+    uint32_t page_size;                                                                                                 \\\n+    uint32_t page_count;                                                                                                \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* pages[];                                                                   \\\n+};                                                                                                                      \\\n+\n+/*PAGED_SPARSE_ARRAY is-a THANDLE*/\n+/*given a type \"T\" PAGED_SPARSE_ARRAY_LL(T) expands to the name of the type. */\n+#define PAGED_SPARSE_ARRAY_LL(T) THANDLE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*because PAGED_SPARSE_ARRAY is a THANDLE, all THANDLE's macro APIs are useable with PAGED_SPARSE_ARRAY.*/\n+/*the below are just shortcuts of THANDLE's public ones*/\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE(T) THANDLE_INITIALIZE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_ASSIGN(T) THANDLE_ASSIGN(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_MOVE(T) THANDLE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE_MOVE(T) THANDLE_INITIALIZE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*introduces a new name for a function that returns a PAGED_SPARSE_ARRAY_LL(T)*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_CREATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_CREATE(C) PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C)\n+\n+/*introduces a name for the function that frees a PAGED_SPARSE_ARRAY when its ref count goes to 0*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_FREE_, C)\n+\n+/*introduces a name for the allocate function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C)\n+\n+/*introduces a name for the release function*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_RELEASE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE(C) PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C)\n+\n+/*introduces a name for the allocate_or_get function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C)\n+\n+/*introduces a name for the get function*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_GET(C) PAGED_SPARSE_ARRAY_LL_GET_NAME(C)\n+\n+/*introduces a function declaration for paged_sparse_array_create*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, PAGED_SPARSE_ARRAY_LL(T), PAGED_SPARSE_ARRAY_LL_CREATE(C), uint32_t, max_size, uint32_t, page_size);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_release*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, int, PAGED_SPARSE_ARRAY_LL_RELEASE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate_or_get*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_get*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*helper to compute bitmap size in bytes (1 bit per element, rounded up to nearest byte)*/\n+#define PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size) (((page_size) + 7) / 8)\n+\n+/*helper to get the allocation bitmap from a page - bitmap is stored after items[] in the same allocation*/\n+#define PAGED_SPARSE_ARRAY_GET_BITMAP(page, page_size, T) ((uint8_t*)((page)->items + (page_size)))\n+\n+/*helper to check if an element is allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_IS_ALLOCATED(bitmap, index_in_page) \\\n+    (((bitmap)[(index_in_page) / 8] & (1 << ((index_in_page) % 8))) != 0)","path":"inc/c_util/paged_sparse_array_ll.h","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":">!= 0 [](http://example.com/codeflow?start=68&length=4)\r\n\r\nwhat happens is you remove this comparison?","created_at":"2026-01-12T13:56:39Z","updated_at":"2026-01-12T13:56:39Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682388780","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682388780"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682388780"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682388780/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":115,"original_line":115,"side":"RIGHT","author_association":"MEMBER","original_position":115,"position":115,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682400474","pull_request_review_id":3650909548,"id":2682400474,"node_id":"PRRC_kwDODaUZTc6f4i7a","diff_hunk":"@@ -0,0 +1,414 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#ifndef PAGED_SPARSE_ARRAY_LL_H\n+#define PAGED_SPARSE_ARRAY_LL_H\n+\n+#ifdef __cplusplus\n+#include <cinttypes>\n+#include <cstdlib>\n+#else // __cplusplus\n+#include <inttypes.h>\n+#include <stdlib.h>\n+#endif // __cplusplus\n+\n+#include \"c_pal/gballoc_hl.h\"\n+#include \"c_pal/gballoc_hl_redirect.h\"\n+\n+#include \"macro_utils/macro_utils.h\"\n+\n+#include \"c_logging/logger.h\"\n+\n+#include \"c_pal/thandle_ll.h\"\n+\n+#include \"umock_c/umock_c_prod.h\"\n+\n+/*PAGED_SPARSE_ARRAY is backed by a THANDLE build on the structure below*/\n+#define PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T), _TAG)\n+\n+#define PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_STRUCT_, T)\n+\n+/*PAGE_STRUCT holds a single page with elements and allocation bitmap*/\n+#define PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T), _TAG)\n+#define PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_STRUCT_, T)\n+\n+/*PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) introduces the base type that holds the paged sparse array*/\n+#define PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(T)                                                                        \\\n+/*define the page structure first - bitmap is embedded after items[] in the same allocation*/                          \\\n+typedef struct PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T)                                                          \\\n+{                                                                                                                       \\\n+    uint32_t allocated_count;                                                                                           \\\n+    T items[];  /*followed by bitmap bytes at offset page_size * sizeof(T)*/                                            \\\n+} PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T);                                                                              \\\n+/*forward define the typedef of the PAGED_SPARSE_ARRAY struct so that it can be used for a function pointer definition*/\\\n+typedef struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T);                           \\\n+struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T)                                                                       \\\n+{                                                                                                                       \\\n+    uint32_t max_size;                                                                                                  \\\n+    uint32_t page_size;                                                                                                 \\\n+    uint32_t page_count;                                                                                                \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* pages[];                                                                   \\\n+};                                                                                                                      \\\n+\n+/*PAGED_SPARSE_ARRAY is-a THANDLE*/\n+/*given a type \"T\" PAGED_SPARSE_ARRAY_LL(T) expands to the name of the type. */\n+#define PAGED_SPARSE_ARRAY_LL(T) THANDLE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*because PAGED_SPARSE_ARRAY is a THANDLE, all THANDLE's macro APIs are useable with PAGED_SPARSE_ARRAY.*/\n+/*the below are just shortcuts of THANDLE's public ones*/\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE(T) THANDLE_INITIALIZE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_ASSIGN(T) THANDLE_ASSIGN(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_MOVE(T) THANDLE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE_MOVE(T) THANDLE_INITIALIZE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*introduces a new name for a function that returns a PAGED_SPARSE_ARRAY_LL(T)*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_CREATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_CREATE(C) PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C)\n+\n+/*introduces a name for the function that frees a PAGED_SPARSE_ARRAY when its ref count goes to 0*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_FREE_, C)\n+\n+/*introduces a name for the allocate function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C)\n+\n+/*introduces a name for the release function*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_RELEASE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE(C) PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C)\n+\n+/*introduces a name for the allocate_or_get function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C)\n+\n+/*introduces a name for the get function*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_GET(C) PAGED_SPARSE_ARRAY_LL_GET_NAME(C)\n+\n+/*introduces a function declaration for paged_sparse_array_create*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, PAGED_SPARSE_ARRAY_LL(T), PAGED_SPARSE_ARRAY_LL_CREATE(C), uint32_t, max_size, uint32_t, page_size);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_release*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, int, PAGED_SPARSE_ARRAY_LL_RELEASE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate_or_get*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_get*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*helper to compute bitmap size in bytes (1 bit per element, rounded up to nearest byte)*/\n+#define PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size) (((page_size) + 7) / 8)\n+\n+/*helper to get the allocation bitmap from a page - bitmap is stored after items[] in the same allocation*/\n+#define PAGED_SPARSE_ARRAY_GET_BITMAP(page, page_size, T) ((uint8_t*)((page)->items + (page_size)))\n+\n+/*helper to check if an element is allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_IS_ALLOCATED(bitmap, index_in_page) \\\n+    (((bitmap)[(index_in_page) / 8] & (1 << ((index_in_page) % 8))) != 0)\n+\n+/*helper to set an element as allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_SET_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] |= (1 << ((index_in_page) % 8)))\n+\n+/*helper to clear an element as not allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_CLEAR_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] &= ~(1 << ((index_in_page) % 8)))\n+\n+/*introduces a function definition for freeing the allocated resources for a PAGED_SPARSE_ARRAY*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_DEFINE(C, T)                                                                                \\\n+static void PAGED_SPARSE_ARRAY_LL_FREE_NAME(C)(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* paged_sparse_array)                         \\\n+{                                                                                                                              \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_009: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_FREE(T) shall return. ]*/      \\\n+    if (paged_sparse_array == NULL)                                                                                            \\\n+    {                                                                                                                          \\\n+        LogError(\"invalid arguments \" MU_TOSTRING(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)) \"* paged_sparse_array=%p\",               \\\n+            paged_sparse_array);                                                                                               \\\n+    }                                                                                                                          \\\n+    else                                                                                                                       \\\n+    {                                                                                                                          \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_010: [ PAGED_SPARSE_ARRAY_FREE(T) shall free all pages that are non-NULL. ]*/       \\\n+        for (uint32_t i = 0; i < paged_sparse_array->page_count; i++)                                                          \\\n+        {                                                                                                                      \\\n+            if (paged_sparse_array->pages[i] != NULL)                                                                          \\\n+            {                                                                                                                  \\\n+                /* bitmap is embedded in same allocation as page, so only one free needed */                                  \\\n+                free((void*)paged_sparse_array->pages[i]);                                                                     \\\n+            }                                                                                                                  \\\n+        }                                                                                                                      \\\n+    }                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DEFINE(C, T)                                                                                                                         \\\n+PAGED_SPARSE_ARRAY_LL(T) PAGED_SPARSE_ARRAY_LL_CREATE(C)(uint32_t max_size, uint32_t page_size)                                                                           \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* result;                                                                                                                           \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_001: [ If max_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                           \\\n+    if (max_size == 0)                                                                                                                                                    \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t max_size=%\" PRIu32 \"\", max_size);                                                                                           \\\n+    }                                                                                                                                                                     \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_002: [ If page_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                          \\\n+    else if (page_size == 0)                                                                                                                                              \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t page_size=%\" PRIu32 \"\", page_size);                                                                                         \\\n+    }                                                                                                                                                                     \\","path":"inc/c_util/paged_sparse_array_ll.h","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"we regularly just have 1x `if` statement that dumps all arguments with their values. \r\n\r\nI do see some extra value here, where explicitly the wrong parameter is spelled out, as opposed to \"dump all and then let the user analyze\". That was not a problem in the last X years.\r\n\r\nAlso it is nice to see all arguments. Just because sometimes the other arguments are interesting too. Maybe a correlation_id here and there.","created_at":"2026-01-12T13:59:30Z","updated_at":"2026-01-12T13:59:30Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682400474","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682400474"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682400474"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682400474/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":162,"original_line":162,"side":"RIGHT","author_association":"MEMBER","original_position":162,"position":162,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682403206","pull_request_review_id":3650912763,"id":2682403206,"node_id":"PRRC_kwDODaUZTc6f4jmG","diff_hunk":"@@ -0,0 +1,414 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#ifndef PAGED_SPARSE_ARRAY_LL_H\n+#define PAGED_SPARSE_ARRAY_LL_H\n+\n+#ifdef __cplusplus\n+#include <cinttypes>\n+#include <cstdlib>\n+#else // __cplusplus\n+#include <inttypes.h>\n+#include <stdlib.h>\n+#endif // __cplusplus\n+\n+#include \"c_pal/gballoc_hl.h\"\n+#include \"c_pal/gballoc_hl_redirect.h\"\n+\n+#include \"macro_utils/macro_utils.h\"\n+\n+#include \"c_logging/logger.h\"\n+\n+#include \"c_pal/thandle_ll.h\"\n+\n+#include \"umock_c/umock_c_prod.h\"\n+\n+/*PAGED_SPARSE_ARRAY is backed by a THANDLE build on the structure below*/\n+#define PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T), _TAG)\n+\n+#define PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_STRUCT_, T)\n+\n+/*PAGE_STRUCT holds a single page with elements and allocation bitmap*/\n+#define PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T), _TAG)\n+#define PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_STRUCT_, T)\n+\n+/*PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) introduces the base type that holds the paged sparse array*/\n+#define PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(T)                                                                        \\\n+/*define the page structure first - bitmap is embedded after items[] in the same allocation*/                          \\\n+typedef struct PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T)                                                          \\\n+{                                                                                                                       \\\n+    uint32_t allocated_count;                                                                                           \\\n+    T items[];  /*followed by bitmap bytes at offset page_size * sizeof(T)*/                                            \\\n+} PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T);                                                                              \\\n+/*forward define the typedef of the PAGED_SPARSE_ARRAY struct so that it can be used for a function pointer definition*/\\\n+typedef struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T);                           \\\n+struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T)                                                                       \\\n+{                                                                                                                       \\\n+    uint32_t max_size;                                                                                                  \\\n+    uint32_t page_size;                                                                                                 \\\n+    uint32_t page_count;                                                                                                \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* pages[];                                                                   \\\n+};                                                                                                                      \\\n+\n+/*PAGED_SPARSE_ARRAY is-a THANDLE*/\n+/*given a type \"T\" PAGED_SPARSE_ARRAY_LL(T) expands to the name of the type. */\n+#define PAGED_SPARSE_ARRAY_LL(T) THANDLE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*because PAGED_SPARSE_ARRAY is a THANDLE, all THANDLE's macro APIs are useable with PAGED_SPARSE_ARRAY.*/\n+/*the below are just shortcuts of THANDLE's public ones*/\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE(T) THANDLE_INITIALIZE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_ASSIGN(T) THANDLE_ASSIGN(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_MOVE(T) THANDLE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE_MOVE(T) THANDLE_INITIALIZE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*introduces a new name for a function that returns a PAGED_SPARSE_ARRAY_LL(T)*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_CREATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_CREATE(C) PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C)\n+\n+/*introduces a name for the function that frees a PAGED_SPARSE_ARRAY when its ref count goes to 0*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_FREE_, C)\n+\n+/*introduces a name for the allocate function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C)\n+\n+/*introduces a name for the release function*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_RELEASE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE(C) PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C)\n+\n+/*introduces a name for the allocate_or_get function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C)\n+\n+/*introduces a name for the get function*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_GET(C) PAGED_SPARSE_ARRAY_LL_GET_NAME(C)\n+\n+/*introduces a function declaration for paged_sparse_array_create*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, PAGED_SPARSE_ARRAY_LL(T), PAGED_SPARSE_ARRAY_LL_CREATE(C), uint32_t, max_size, uint32_t, page_size);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_release*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, int, PAGED_SPARSE_ARRAY_LL_RELEASE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate_or_get*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_get*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*helper to compute bitmap size in bytes (1 bit per element, rounded up to nearest byte)*/\n+#define PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size) (((page_size) + 7) / 8)\n+\n+/*helper to get the allocation bitmap from a page - bitmap is stored after items[] in the same allocation*/\n+#define PAGED_SPARSE_ARRAY_GET_BITMAP(page, page_size, T) ((uint8_t*)((page)->items + (page_size)))\n+\n+/*helper to check if an element is allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_IS_ALLOCATED(bitmap, index_in_page) \\\n+    (((bitmap)[(index_in_page) / 8] & (1 << ((index_in_page) % 8))) != 0)\n+\n+/*helper to set an element as allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_SET_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] |= (1 << ((index_in_page) % 8)))\n+\n+/*helper to clear an element as not allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_CLEAR_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] &= ~(1 << ((index_in_page) % 8)))\n+\n+/*introduces a function definition for freeing the allocated resources for a PAGED_SPARSE_ARRAY*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_DEFINE(C, T)                                                                                \\\n+static void PAGED_SPARSE_ARRAY_LL_FREE_NAME(C)(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* paged_sparse_array)                         \\\n+{                                                                                                                              \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_009: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_FREE(T) shall return. ]*/      \\\n+    if (paged_sparse_array == NULL)                                                                                            \\\n+    {                                                                                                                          \\\n+        LogError(\"invalid arguments \" MU_TOSTRING(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)) \"* paged_sparse_array=%p\",               \\\n+            paged_sparse_array);                                                                                               \\\n+    }                                                                                                                          \\\n+    else                                                                                                                       \\\n+    {                                                                                                                          \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_010: [ PAGED_SPARSE_ARRAY_FREE(T) shall free all pages that are non-NULL. ]*/       \\\n+        for (uint32_t i = 0; i < paged_sparse_array->page_count; i++)                                                          \\\n+        {                                                                                                                      \\\n+            if (paged_sparse_array->pages[i] != NULL)                                                                          \\\n+            {                                                                                                                  \\\n+                /* bitmap is embedded in same allocation as page, so only one free needed */                                  \\\n+                free((void*)paged_sparse_array->pages[i]);                                                                     \\\n+            }                                                                                                                  \\\n+        }                                                                                                                      \\\n+    }                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DEFINE(C, T)                                                                                                                         \\\n+PAGED_SPARSE_ARRAY_LL(T) PAGED_SPARSE_ARRAY_LL_CREATE(C)(uint32_t max_size, uint32_t page_size)                                                                           \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* result;                                                                                                                           \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_001: [ If max_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                           \\\n+    if (max_size == 0)                                                                                                                                                    \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t max_size=%\" PRIu32 \"\", max_size);                                                                                           \\\n+    }                                                                                                                                                                     \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_002: [ If page_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                          \\\n+    else if (page_size == 0)                                                                                                                                              \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t page_size=%\" PRIu32 \"\", page_size);                                                                                         \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_003: [ PAGED_SPARSE_ARRAY_CREATE(T) shall compute the number of pages as (max_size + page_size - 1) / page_size. ]*/           \\\n+        uint32_t page_count = (max_size + page_size - 1) / page_size;                                                                                                     \\","path":"inc/c_util/paged_sparse_array_ll.h","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":">max_size + page_size [](http://example.com/codeflow?start=31&length=20)\r\n\r\nprobably a mischievous user can easily concoct some arguments that would overflow here.","created_at":"2026-01-12T14:00:08Z","updated_at":"2026-01-12T14:00:08Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682403206","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682403206"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682403206"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682403206/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":166,"original_line":166,"side":"RIGHT","author_association":"MEMBER","original_position":166,"position":166,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682417988","pull_request_review_id":3650930814,"id":2682417988,"node_id":"PRRC_kwDODaUZTc6f4nNE","diff_hunk":"@@ -0,0 +1,414 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#ifndef PAGED_SPARSE_ARRAY_LL_H\n+#define PAGED_SPARSE_ARRAY_LL_H\n+\n+#ifdef __cplusplus\n+#include <cinttypes>\n+#include <cstdlib>\n+#else // __cplusplus\n+#include <inttypes.h>\n+#include <stdlib.h>\n+#endif // __cplusplus\n+\n+#include \"c_pal/gballoc_hl.h\"\n+#include \"c_pal/gballoc_hl_redirect.h\"\n+\n+#include \"macro_utils/macro_utils.h\"\n+\n+#include \"c_logging/logger.h\"\n+\n+#include \"c_pal/thandle_ll.h\"\n+\n+#include \"umock_c/umock_c_prod.h\"\n+\n+/*PAGED_SPARSE_ARRAY is backed by a THANDLE build on the structure below*/\n+#define PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T), _TAG)\n+\n+#define PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_STRUCT_, T)\n+\n+/*PAGE_STRUCT holds a single page with elements and allocation bitmap*/\n+#define PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T), _TAG)\n+#define PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_STRUCT_, T)\n+\n+/*PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) introduces the base type that holds the paged sparse array*/\n+#define PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(T)                                                                        \\\n+/*define the page structure first - bitmap is embedded after items[] in the same allocation*/                          \\\n+typedef struct PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T)                                                          \\\n+{                                                                                                                       \\\n+    uint32_t allocated_count;                                                                                           \\\n+    T items[];  /*followed by bitmap bytes at offset page_size * sizeof(T)*/                                            \\\n+} PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T);                                                                              \\\n+/*forward define the typedef of the PAGED_SPARSE_ARRAY struct so that it can be used for a function pointer definition*/\\\n+typedef struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T);                           \\\n+struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T)                                                                       \\\n+{                                                                                                                       \\\n+    uint32_t max_size;                                                                                                  \\\n+    uint32_t page_size;                                                                                                 \\\n+    uint32_t page_count;                                                                                                \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* pages[];                                                                   \\\n+};                                                                                                                      \\\n+\n+/*PAGED_SPARSE_ARRAY is-a THANDLE*/\n+/*given a type \"T\" PAGED_SPARSE_ARRAY_LL(T) expands to the name of the type. */\n+#define PAGED_SPARSE_ARRAY_LL(T) THANDLE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*because PAGED_SPARSE_ARRAY is a THANDLE, all THANDLE's macro APIs are useable with PAGED_SPARSE_ARRAY.*/\n+/*the below are just shortcuts of THANDLE's public ones*/\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE(T) THANDLE_INITIALIZE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_ASSIGN(T) THANDLE_ASSIGN(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_MOVE(T) THANDLE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE_MOVE(T) THANDLE_INITIALIZE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*introduces a new name for a function that returns a PAGED_SPARSE_ARRAY_LL(T)*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_CREATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_CREATE(C) PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C)\n+\n+/*introduces a name for the function that frees a PAGED_SPARSE_ARRAY when its ref count goes to 0*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_FREE_, C)\n+\n+/*introduces a name for the allocate function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C)\n+\n+/*introduces a name for the release function*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_RELEASE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE(C) PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C)\n+\n+/*introduces a name for the allocate_or_get function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C)\n+\n+/*introduces a name for the get function*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_GET(C) PAGED_SPARSE_ARRAY_LL_GET_NAME(C)\n+\n+/*introduces a function declaration for paged_sparse_array_create*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, PAGED_SPARSE_ARRAY_LL(T), PAGED_SPARSE_ARRAY_LL_CREATE(C), uint32_t, max_size, uint32_t, page_size);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_release*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, int, PAGED_SPARSE_ARRAY_LL_RELEASE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate_or_get*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_get*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*helper to compute bitmap size in bytes (1 bit per element, rounded up to nearest byte)*/\n+#define PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size) (((page_size) + 7) / 8)\n+\n+/*helper to get the allocation bitmap from a page - bitmap is stored after items[] in the same allocation*/\n+#define PAGED_SPARSE_ARRAY_GET_BITMAP(page, page_size, T) ((uint8_t*)((page)->items + (page_size)))\n+\n+/*helper to check if an element is allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_IS_ALLOCATED(bitmap, index_in_page) \\\n+    (((bitmap)[(index_in_page) / 8] & (1 << ((index_in_page) % 8))) != 0)\n+\n+/*helper to set an element as allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_SET_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] |= (1 << ((index_in_page) % 8)))\n+\n+/*helper to clear an element as not allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_CLEAR_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] &= ~(1 << ((index_in_page) % 8)))\n+\n+/*introduces a function definition for freeing the allocated resources for a PAGED_SPARSE_ARRAY*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_DEFINE(C, T)                                                                                \\\n+static void PAGED_SPARSE_ARRAY_LL_FREE_NAME(C)(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* paged_sparse_array)                         \\\n+{                                                                                                                              \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_009: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_FREE(T) shall return. ]*/      \\\n+    if (paged_sparse_array == NULL)                                                                                            \\\n+    {                                                                                                                          \\\n+        LogError(\"invalid arguments \" MU_TOSTRING(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)) \"* paged_sparse_array=%p\",               \\\n+            paged_sparse_array);                                                                                               \\\n+    }                                                                                                                          \\\n+    else                                                                                                                       \\\n+    {                                                                                                                          \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_010: [ PAGED_SPARSE_ARRAY_FREE(T) shall free all pages that are non-NULL. ]*/       \\\n+        for (uint32_t i = 0; i < paged_sparse_array->page_count; i++)                                                          \\\n+        {                                                                                                                      \\\n+            if (paged_sparse_array->pages[i] != NULL)                                                                          \\\n+            {                                                                                                                  \\\n+                /* bitmap is embedded in same allocation as page, so only one free needed */                                  \\\n+                free((void*)paged_sparse_array->pages[i]);                                                                     \\\n+            }                                                                                                                  \\\n+        }                                                                                                                      \\\n+    }                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DEFINE(C, T)                                                                                                                         \\\n+PAGED_SPARSE_ARRAY_LL(T) PAGED_SPARSE_ARRAY_LL_CREATE(C)(uint32_t max_size, uint32_t page_size)                                                                           \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* result;                                                                                                                           \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_001: [ If max_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                           \\\n+    if (max_size == 0)                                                                                                                                                    \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t max_size=%\" PRIu32 \"\", max_size);                                                                                           \\\n+    }                                                                                                                                                                     \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_002: [ If page_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                          \\\n+    else if (page_size == 0)                                                                                                                                              \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t page_size=%\" PRIu32 \"\", page_size);                                                                                         \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_003: [ PAGED_SPARSE_ARRAY_CREATE(T) shall compute the number of pages as (max_size + page_size - 1) / page_size. ]*/           \\\n+        uint32_t page_count = (max_size + page_size - 1) / page_size;                                                                                                     \\","path":"inc/c_util/paged_sparse_array_ll.h","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":">page_count [](http://example.com/codeflow?start=17&length=10)\r\n\r\npage_count cannot result in UINT32_MAX.","created_at":"2026-01-12T14:03:30Z","updated_at":"2026-01-12T14:03:30Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682417988","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682417988"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682417988"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682417988/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":166,"original_line":166,"side":"RIGHT","author_association":"MEMBER","original_position":166,"position":166,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682451795","pull_request_review_id":3650970278,"id":2682451795,"node_id":"PRRC_kwDODaUZTc6f4vdT","diff_hunk":"@@ -0,0 +1,414 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#ifndef PAGED_SPARSE_ARRAY_LL_H\n+#define PAGED_SPARSE_ARRAY_LL_H\n+\n+#ifdef __cplusplus\n+#include <cinttypes>\n+#include <cstdlib>\n+#else // __cplusplus\n+#include <inttypes.h>\n+#include <stdlib.h>\n+#endif // __cplusplus\n+\n+#include \"c_pal/gballoc_hl.h\"\n+#include \"c_pal/gballoc_hl_redirect.h\"\n+\n+#include \"macro_utils/macro_utils.h\"\n+\n+#include \"c_logging/logger.h\"\n+\n+#include \"c_pal/thandle_ll.h\"\n+\n+#include \"umock_c/umock_c_prod.h\"\n+\n+/*PAGED_SPARSE_ARRAY is backed by a THANDLE build on the structure below*/\n+#define PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T), _TAG)\n+\n+#define PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_STRUCT_, T)\n+\n+/*PAGE_STRUCT holds a single page with elements and allocation bitmap*/\n+#define PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T), _TAG)\n+#define PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_STRUCT_, T)\n+\n+/*PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) introduces the base type that holds the paged sparse array*/\n+#define PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(T)                                                                        \\\n+/*define the page structure first - bitmap is embedded after items[] in the same allocation*/                          \\\n+typedef struct PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T)                                                          \\\n+{                                                                                                                       \\\n+    uint32_t allocated_count;                                                                                           \\\n+    T items[];  /*followed by bitmap bytes at offset page_size * sizeof(T)*/                                            \\\n+} PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T);                                                                              \\\n+/*forward define the typedef of the PAGED_SPARSE_ARRAY struct so that it can be used for a function pointer definition*/\\\n+typedef struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T);                           \\\n+struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T)                                                                       \\\n+{                                                                                                                       \\\n+    uint32_t max_size;                                                                                                  \\\n+    uint32_t page_size;                                                                                                 \\\n+    uint32_t page_count;                                                                                                \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* pages[];                                                                   \\\n+};                                                                                                                      \\\n+\n+/*PAGED_SPARSE_ARRAY is-a THANDLE*/\n+/*given a type \"T\" PAGED_SPARSE_ARRAY_LL(T) expands to the name of the type. */\n+#define PAGED_SPARSE_ARRAY_LL(T) THANDLE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*because PAGED_SPARSE_ARRAY is a THANDLE, all THANDLE's macro APIs are useable with PAGED_SPARSE_ARRAY.*/\n+/*the below are just shortcuts of THANDLE's public ones*/\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE(T) THANDLE_INITIALIZE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_ASSIGN(T) THANDLE_ASSIGN(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_MOVE(T) THANDLE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE_MOVE(T) THANDLE_INITIALIZE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*introduces a new name for a function that returns a PAGED_SPARSE_ARRAY_LL(T)*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_CREATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_CREATE(C) PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C)\n+\n+/*introduces a name for the function that frees a PAGED_SPARSE_ARRAY when its ref count goes to 0*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_FREE_, C)\n+\n+/*introduces a name for the allocate function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C)\n+\n+/*introduces a name for the release function*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_RELEASE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE(C) PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C)\n+\n+/*introduces a name for the allocate_or_get function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C)\n+\n+/*introduces a name for the get function*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_GET(C) PAGED_SPARSE_ARRAY_LL_GET_NAME(C)\n+\n+/*introduces a function declaration for paged_sparse_array_create*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, PAGED_SPARSE_ARRAY_LL(T), PAGED_SPARSE_ARRAY_LL_CREATE(C), uint32_t, max_size, uint32_t, page_size);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_release*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, int, PAGED_SPARSE_ARRAY_LL_RELEASE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate_or_get*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_get*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*helper to compute bitmap size in bytes (1 bit per element, rounded up to nearest byte)*/\n+#define PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size) (((page_size) + 7) / 8)\n+\n+/*helper to get the allocation bitmap from a page - bitmap is stored after items[] in the same allocation*/\n+#define PAGED_SPARSE_ARRAY_GET_BITMAP(page, page_size, T) ((uint8_t*)((page)->items + (page_size)))\n+\n+/*helper to check if an element is allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_IS_ALLOCATED(bitmap, index_in_page) \\\n+    (((bitmap)[(index_in_page) / 8] & (1 << ((index_in_page) % 8))) != 0)\n+\n+/*helper to set an element as allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_SET_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] |= (1 << ((index_in_page) % 8)))\n+\n+/*helper to clear an element as not allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_CLEAR_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] &= ~(1 << ((index_in_page) % 8)))\n+\n+/*introduces a function definition for freeing the allocated resources for a PAGED_SPARSE_ARRAY*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_DEFINE(C, T)                                                                                \\\n+static void PAGED_SPARSE_ARRAY_LL_FREE_NAME(C)(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* paged_sparse_array)                         \\\n+{                                                                                                                              \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_009: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_FREE(T) shall return. ]*/      \\\n+    if (paged_sparse_array == NULL)                                                                                            \\\n+    {                                                                                                                          \\\n+        LogError(\"invalid arguments \" MU_TOSTRING(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)) \"* paged_sparse_array=%p\",               \\\n+            paged_sparse_array);                                                                                               \\\n+    }                                                                                                                          \\\n+    else                                                                                                                       \\\n+    {                                                                                                                          \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_010: [ PAGED_SPARSE_ARRAY_FREE(T) shall free all pages that are non-NULL. ]*/       \\\n+        for (uint32_t i = 0; i < paged_sparse_array->page_count; i++)                                                          \\\n+        {                                                                                                                      \\\n+            if (paged_sparse_array->pages[i] != NULL)                                                                          \\\n+            {                                                                                                                  \\\n+                /* bitmap is embedded in same allocation as page, so only one free needed */                                  \\\n+                free((void*)paged_sparse_array->pages[i]);                                                                     \\\n+            }                                                                                                                  \\\n+        }                                                                                                                      \\\n+    }                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DEFINE(C, T)                                                                                                                         \\\n+PAGED_SPARSE_ARRAY_LL(T) PAGED_SPARSE_ARRAY_LL_CREATE(C)(uint32_t max_size, uint32_t page_size)                                                                           \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* result;                                                                                                                           \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_001: [ If max_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                           \\\n+    if (max_size == 0)                                                                                                                                                    \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t max_size=%\" PRIu32 \"\", max_size);                                                                                           \\\n+    }                                                                                                                                                                     \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_002: [ If page_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                          \\\n+    else if (page_size == 0)                                                                                                                                              \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t page_size=%\" PRIu32 \"\", page_size);                                                                                         \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_003: [ PAGED_SPARSE_ARRAY_CREATE(T) shall compute the number of pages as (max_size + page_size - 1) / page_size. ]*/           \\\n+        uint32_t page_count = (max_size + page_size - 1) / page_size;                                                                                                     \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_004: [ PAGED_SPARSE_ARRAY_CREATE(T) shall call THANDLE_MALLOC_FLEX to allocate memory for the paged sparse array with the number of pages. ]*/ \\\n+        result = THANDLE_MALLOC_FLEX(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(PAGED_SPARSE_ARRAY_LL_FREE_NAME(C), page_count, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)*)); \\\n+        if (result == NULL)                                                                                                                                               \\\n+        {                                                                                                                                                                 \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_007: [ If there are any errors, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                               \\\n+            LogError(\"failure in THANDLE_MALLOC_FLEX page_count=%\" PRIu32 \", sizeof(PAGED_SPARSE_ARRAY_PAGE*)=%zu\", page_count, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)*)); \\\n+        }                                                                                                                                                                 \\\n+        else                                                                                                                                                              \\\n+        {                                                                                                                                                                 \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_006: [ PAGED_SPARSE_ARRAY_CREATE(T) shall store max_size and page_size in the structure. ]*/                               \\\n+            result->max_size = max_size;                                                                                                                                  \\\n+            result->page_size = page_size;                                                                                                                                \\\n+            result->page_count = page_count;                                                                                                                              \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_005: [ PAGED_SPARSE_ARRAY_CREATE(T) shall set all page pointers to NULL. ]*/                                               \\\n+            for (uint32_t i = 0; i < page_count; i++)                                                                                                                     \\\n+            {                                                                                                                                                             \\\n+                result->pages[i] = NULL;                                                                                                                                  \\\n+            }                                                                                                                                                             \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_008: [ PAGED_SPARSE_ARRAY_CREATE(T) shall succeed and return a non-NULL value. ]*/                                         \\\n+            goto all_ok;                                                                                                                                                  \\\n+        }                                                                                                                                                                 \\\n+    }                                                                                                                                                                     \\\n+    result = NULL;                                                                                                                                                        \\\n+all_ok:                                                                                                                                                                   \\\n+    return result;                                                                                                                                                        \\\n+}\n+\n+/*internal helper to allocate a page*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_, C)\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_DEFINE(C, T)                                                                                                         \\\n+static PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(uint32_t page_size)                                                  \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* page;                                                                                                                        \\\n+    /* Allocate page struct + items array + bitmap in a single allocation */                                                                                             \\\n+    size_t bitmap_size = PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size);                                                                                                       \\\n+    size_t items_and_bitmap_size = (size_t)page_size * sizeof(T) + bitmap_size;                                                                                           \\\n+    page = malloc_flex(sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)), items_and_bitmap_size, 1);                                                                        \\\n+    if (page == NULL)                                                                                                                                                     \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"failure in malloc_flex for page, page_size=%\" PRIu32 \", sizeof(\" MU_TOSTRING(T) \")=%zu, bitmap_size=%zu\", page_size, sizeof(T), bitmap_size);          \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        /* Initialize bitmap to all zeros (nothing allocated) - bitmap is at end of items array */                                                                       \\\n+        uint8_t* bitmap = PAGED_SPARSE_ARRAY_GET_BITMAP(page, page_size, T);                                                                                              \\","path":"inc/c_util/paged_sparse_array_ll.h","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":">PAGED_SPARSE_ARRAY_GET_BITMAP [](http://example.com/codeflow?start=26&length=29)\r\n\r\nhmmmm","created_at":"2026-01-12T14:12:15Z","updated_at":"2026-01-12T14:12:15Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682451795","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682451795"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682451795"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682451795/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":212,"original_line":212,"side":"RIGHT","author_association":"MEMBER","original_position":212,"position":212,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682454897","pull_request_review_id":3650974040,"id":2682454897,"node_id":"PRRC_kwDODaUZTc6f4wNx","diff_hunk":"@@ -0,0 +1,414 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#ifndef PAGED_SPARSE_ARRAY_LL_H\n+#define PAGED_SPARSE_ARRAY_LL_H\n+\n+#ifdef __cplusplus\n+#include <cinttypes>\n+#include <cstdlib>\n+#else // __cplusplus\n+#include <inttypes.h>\n+#include <stdlib.h>\n+#endif // __cplusplus\n+\n+#include \"c_pal/gballoc_hl.h\"\n+#include \"c_pal/gballoc_hl_redirect.h\"\n+\n+#include \"macro_utils/macro_utils.h\"\n+\n+#include \"c_logging/logger.h\"\n+\n+#include \"c_pal/thandle_ll.h\"\n+\n+#include \"umock_c/umock_c_prod.h\"\n+\n+/*PAGED_SPARSE_ARRAY is backed by a THANDLE build on the structure below*/\n+#define PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T), _TAG)\n+\n+#define PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_STRUCT_, T)\n+\n+/*PAGE_STRUCT holds a single page with elements and allocation bitmap*/\n+#define PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T), _TAG)\n+#define PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_STRUCT_, T)\n+\n+/*PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) introduces the base type that holds the paged sparse array*/\n+#define PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(T)                                                                        \\\n+/*define the page structure first - bitmap is embedded after items[] in the same allocation*/                          \\\n+typedef struct PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T)                                                          \\\n+{                                                                                                                       \\\n+    uint32_t allocated_count;                                                                                           \\\n+    T items[];  /*followed by bitmap bytes at offset page_size * sizeof(T)*/                                            \\\n+} PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T);                                                                              \\\n+/*forward define the typedef of the PAGED_SPARSE_ARRAY struct so that it can be used for a function pointer definition*/\\\n+typedef struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T);                           \\\n+struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T)                                                                       \\\n+{                                                                                                                       \\\n+    uint32_t max_size;                                                                                                  \\\n+    uint32_t page_size;                                                                                                 \\\n+    uint32_t page_count;                                                                                                \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* pages[];                                                                   \\\n+};                                                                                                                      \\\n+\n+/*PAGED_SPARSE_ARRAY is-a THANDLE*/\n+/*given a type \"T\" PAGED_SPARSE_ARRAY_LL(T) expands to the name of the type. */\n+#define PAGED_SPARSE_ARRAY_LL(T) THANDLE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*because PAGED_SPARSE_ARRAY is a THANDLE, all THANDLE's macro APIs are useable with PAGED_SPARSE_ARRAY.*/\n+/*the below are just shortcuts of THANDLE's public ones*/\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE(T) THANDLE_INITIALIZE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_ASSIGN(T) THANDLE_ASSIGN(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_MOVE(T) THANDLE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE_MOVE(T) THANDLE_INITIALIZE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*introduces a new name for a function that returns a PAGED_SPARSE_ARRAY_LL(T)*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_CREATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_CREATE(C) PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C)\n+\n+/*introduces a name for the function that frees a PAGED_SPARSE_ARRAY when its ref count goes to 0*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_FREE_, C)\n+\n+/*introduces a name for the allocate function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C)\n+\n+/*introduces a name for the release function*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_RELEASE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE(C) PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C)\n+\n+/*introduces a name for the allocate_or_get function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C)\n+\n+/*introduces a name for the get function*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_GET(C) PAGED_SPARSE_ARRAY_LL_GET_NAME(C)\n+\n+/*introduces a function declaration for paged_sparse_array_create*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, PAGED_SPARSE_ARRAY_LL(T), PAGED_SPARSE_ARRAY_LL_CREATE(C), uint32_t, max_size, uint32_t, page_size);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_release*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, int, PAGED_SPARSE_ARRAY_LL_RELEASE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate_or_get*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_get*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*helper to compute bitmap size in bytes (1 bit per element, rounded up to nearest byte)*/\n+#define PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size) (((page_size) + 7) / 8)\n+\n+/*helper to get the allocation bitmap from a page - bitmap is stored after items[] in the same allocation*/\n+#define PAGED_SPARSE_ARRAY_GET_BITMAP(page, page_size, T) ((uint8_t*)((page)->items + (page_size)))\n+\n+/*helper to check if an element is allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_IS_ALLOCATED(bitmap, index_in_page) \\\n+    (((bitmap)[(index_in_page) / 8] & (1 << ((index_in_page) % 8))) != 0)\n+\n+/*helper to set an element as allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_SET_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] |= (1 << ((index_in_page) % 8)))\n+\n+/*helper to clear an element as not allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_CLEAR_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] &= ~(1 << ((index_in_page) % 8)))\n+\n+/*introduces a function definition for freeing the allocated resources for a PAGED_SPARSE_ARRAY*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_DEFINE(C, T)                                                                                \\\n+static void PAGED_SPARSE_ARRAY_LL_FREE_NAME(C)(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* paged_sparse_array)                         \\\n+{                                                                                                                              \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_009: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_FREE(T) shall return. ]*/      \\\n+    if (paged_sparse_array == NULL)                                                                                            \\\n+    {                                                                                                                          \\\n+        LogError(\"invalid arguments \" MU_TOSTRING(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)) \"* paged_sparse_array=%p\",               \\\n+            paged_sparse_array);                                                                                               \\\n+    }                                                                                                                          \\\n+    else                                                                                                                       \\\n+    {                                                                                                                          \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_010: [ PAGED_SPARSE_ARRAY_FREE(T) shall free all pages that are non-NULL. ]*/       \\\n+        for (uint32_t i = 0; i < paged_sparse_array->page_count; i++)                                                          \\\n+        {                                                                                                                      \\\n+            if (paged_sparse_array->pages[i] != NULL)                                                                          \\\n+            {                                                                                                                  \\\n+                /* bitmap is embedded in same allocation as page, so only one free needed */                                  \\\n+                free((void*)paged_sparse_array->pages[i]);                                                                     \\\n+            }                                                                                                                  \\\n+        }                                                                                                                      \\\n+    }                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DEFINE(C, T)                                                                                                                         \\\n+PAGED_SPARSE_ARRAY_LL(T) PAGED_SPARSE_ARRAY_LL_CREATE(C)(uint32_t max_size, uint32_t page_size)                                                                           \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* result;                                                                                                                           \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_001: [ If max_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                           \\\n+    if (max_size == 0)                                                                                                                                                    \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t max_size=%\" PRIu32 \"\", max_size);                                                                                           \\\n+    }                                                                                                                                                                     \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_002: [ If page_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                          \\\n+    else if (page_size == 0)                                                                                                                                              \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t page_size=%\" PRIu32 \"\", page_size);                                                                                         \\\n+    }                                                                                                                                                                     \\","path":"inc/c_util/paged_sparse_array_ll.h","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Seems a \"here and everywhere\" comment","created_at":"2026-01-12T14:13:05Z","updated_at":"2026-01-12T14:13:05Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682454897","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682454897"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682454897"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682454897/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":162,"original_line":162,"side":"RIGHT","in_reply_to_id":2682400474,"author_association":"MEMBER","original_position":162,"position":162,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682470436","pull_request_review_id":3650994592,"id":2682470436,"node_id":"PRRC_kwDODaUZTc6f40Ak","diff_hunk":"@@ -0,0 +1,414 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#ifndef PAGED_SPARSE_ARRAY_LL_H\n+#define PAGED_SPARSE_ARRAY_LL_H\n+\n+#ifdef __cplusplus\n+#include <cinttypes>\n+#include <cstdlib>\n+#else // __cplusplus\n+#include <inttypes.h>\n+#include <stdlib.h>\n+#endif // __cplusplus\n+\n+#include \"c_pal/gballoc_hl.h\"\n+#include \"c_pal/gballoc_hl_redirect.h\"\n+\n+#include \"macro_utils/macro_utils.h\"\n+\n+#include \"c_logging/logger.h\"\n+\n+#include \"c_pal/thandle_ll.h\"\n+\n+#include \"umock_c/umock_c_prod.h\"\n+\n+/*PAGED_SPARSE_ARRAY is backed by a THANDLE build on the structure below*/\n+#define PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T), _TAG)\n+\n+#define PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_STRUCT_, T)\n+\n+/*PAGE_STRUCT holds a single page with elements and allocation bitmap*/\n+#define PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T), _TAG)\n+#define PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_STRUCT_, T)\n+\n+/*PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) introduces the base type that holds the paged sparse array*/\n+#define PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(T)                                                                        \\\n+/*define the page structure first - bitmap is embedded after items[] in the same allocation*/                          \\\n+typedef struct PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T)                                                          \\\n+{                                                                                                                       \\\n+    uint32_t allocated_count;                                                                                           \\\n+    T items[];  /*followed by bitmap bytes at offset page_size * sizeof(T)*/                                            \\\n+} PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T);                                                                              \\\n+/*forward define the typedef of the PAGED_SPARSE_ARRAY struct so that it can be used for a function pointer definition*/\\\n+typedef struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T);                           \\\n+struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T)                                                                       \\\n+{                                                                                                                       \\\n+    uint32_t max_size;                                                                                                  \\\n+    uint32_t page_size;                                                                                                 \\\n+    uint32_t page_count;                                                                                                \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* pages[];                                                                   \\\n+};                                                                                                                      \\\n+\n+/*PAGED_SPARSE_ARRAY is-a THANDLE*/\n+/*given a type \"T\" PAGED_SPARSE_ARRAY_LL(T) expands to the name of the type. */\n+#define PAGED_SPARSE_ARRAY_LL(T) THANDLE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*because PAGED_SPARSE_ARRAY is a THANDLE, all THANDLE's macro APIs are useable with PAGED_SPARSE_ARRAY.*/\n+/*the below are just shortcuts of THANDLE's public ones*/\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE(T) THANDLE_INITIALIZE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_ASSIGN(T) THANDLE_ASSIGN(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_MOVE(T) THANDLE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE_MOVE(T) THANDLE_INITIALIZE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*introduces a new name for a function that returns a PAGED_SPARSE_ARRAY_LL(T)*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_CREATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_CREATE(C) PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C)\n+\n+/*introduces a name for the function that frees a PAGED_SPARSE_ARRAY when its ref count goes to 0*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_FREE_, C)\n+\n+/*introduces a name for the allocate function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C)\n+\n+/*introduces a name for the release function*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_RELEASE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE(C) PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C)\n+\n+/*introduces a name for the allocate_or_get function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C)\n+\n+/*introduces a name for the get function*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_GET(C) PAGED_SPARSE_ARRAY_LL_GET_NAME(C)\n+\n+/*introduces a function declaration for paged_sparse_array_create*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, PAGED_SPARSE_ARRAY_LL(T), PAGED_SPARSE_ARRAY_LL_CREATE(C), uint32_t, max_size, uint32_t, page_size);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_release*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, int, PAGED_SPARSE_ARRAY_LL_RELEASE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate_or_get*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_get*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*helper to compute bitmap size in bytes (1 bit per element, rounded up to nearest byte)*/\n+#define PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size) (((page_size) + 7) / 8)\n+\n+/*helper to get the allocation bitmap from a page - bitmap is stored after items[] in the same allocation*/\n+#define PAGED_SPARSE_ARRAY_GET_BITMAP(page, page_size, T) ((uint8_t*)((page)->items + (page_size)))\n+\n+/*helper to check if an element is allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_IS_ALLOCATED(bitmap, index_in_page) \\\n+    (((bitmap)[(index_in_page) / 8] & (1 << ((index_in_page) % 8))) != 0)\n+\n+/*helper to set an element as allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_SET_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] |= (1 << ((index_in_page) % 8)))\n+\n+/*helper to clear an element as not allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_CLEAR_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] &= ~(1 << ((index_in_page) % 8)))\n+\n+/*introduces a function definition for freeing the allocated resources for a PAGED_SPARSE_ARRAY*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_DEFINE(C, T)                                                                                \\\n+static void PAGED_SPARSE_ARRAY_LL_FREE_NAME(C)(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* paged_sparse_array)                         \\\n+{                                                                                                                              \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_009: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_FREE(T) shall return. ]*/      \\\n+    if (paged_sparse_array == NULL)                                                                                            \\\n+    {                                                                                                                          \\\n+        LogError(\"invalid arguments \" MU_TOSTRING(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)) \"* paged_sparse_array=%p\",               \\\n+            paged_sparse_array);                                                                                               \\\n+    }                                                                                                                          \\\n+    else                                                                                                                       \\\n+    {                                                                                                                          \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_010: [ PAGED_SPARSE_ARRAY_FREE(T) shall free all pages that are non-NULL. ]*/       \\\n+        for (uint32_t i = 0; i < paged_sparse_array->page_count; i++)                                                          \\\n+        {                                                                                                                      \\\n+            if (paged_sparse_array->pages[i] != NULL)                                                                          \\\n+            {                                                                                                                  \\\n+                /* bitmap is embedded in same allocation as page, so only one free needed */                                  \\\n+                free((void*)paged_sparse_array->pages[i]);                                                                     \\\n+            }                                                                                                                  \\\n+        }                                                                                                                      \\\n+    }                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DEFINE(C, T)                                                                                                                         \\\n+PAGED_SPARSE_ARRAY_LL(T) PAGED_SPARSE_ARRAY_LL_CREATE(C)(uint32_t max_size, uint32_t page_size)                                                                           \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* result;                                                                                                                           \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_001: [ If max_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                           \\\n+    if (max_size == 0)                                                                                                                                                    \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t max_size=%\" PRIu32 \"\", max_size);                                                                                           \\\n+    }                                                                                                                                                                     \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_002: [ If page_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                          \\\n+    else if (page_size == 0)                                                                                                                                              \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t page_size=%\" PRIu32 \"\", page_size);                                                                                         \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_003: [ PAGED_SPARSE_ARRAY_CREATE(T) shall compute the number of pages as (max_size + page_size - 1) / page_size. ]*/           \\\n+        uint32_t page_count = (max_size + page_size - 1) / page_size;                                                                                                     \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_004: [ PAGED_SPARSE_ARRAY_CREATE(T) shall call THANDLE_MALLOC_FLEX to allocate memory for the paged sparse array with the number of pages. ]*/ \\\n+        result = THANDLE_MALLOC_FLEX(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(PAGED_SPARSE_ARRAY_LL_FREE_NAME(C), page_count, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)*)); \\\n+        if (result == NULL)                                                                                                                                               \\\n+        {                                                                                                                                                                 \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_007: [ If there are any errors, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                               \\\n+            LogError(\"failure in THANDLE_MALLOC_FLEX page_count=%\" PRIu32 \", sizeof(PAGED_SPARSE_ARRAY_PAGE*)=%zu\", page_count, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)*)); \\\n+        }                                                                                                                                                                 \\\n+        else                                                                                                                                                              \\\n+        {                                                                                                                                                                 \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_006: [ PAGED_SPARSE_ARRAY_CREATE(T) shall store max_size and page_size in the structure. ]*/                               \\\n+            result->max_size = max_size;                                                                                                                                  \\\n+            result->page_size = page_size;                                                                                                                                \\\n+            result->page_count = page_count;                                                                                                                              \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_005: [ PAGED_SPARSE_ARRAY_CREATE(T) shall set all page pointers to NULL. ]*/                                               \\\n+            for (uint32_t i = 0; i < page_count; i++)                                                                                                                     \\\n+            {                                                                                                                                                             \\\n+                result->pages[i] = NULL;                                                                                                                                  \\\n+            }                                                                                                                                                             \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_008: [ PAGED_SPARSE_ARRAY_CREATE(T) shall succeed and return a non-NULL value. ]*/                                         \\\n+            goto all_ok;                                                                                                                                                  \\\n+        }                                                                                                                                                                 \\\n+    }                                                                                                                                                                     \\\n+    result = NULL;                                                                                                                                                        \\\n+all_ok:                                                                                                                                                                   \\\n+    return result;                                                                                                                                                        \\\n+}\n+\n+/*internal helper to allocate a page*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_, C)\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_DEFINE(C, T)                                                                                                         \\\n+static PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(uint32_t page_size)                                                  \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* page;                                                                                                                        \\\n+    /* Allocate page struct + items array + bitmap in a single allocation */                                                                                             \\\n+    size_t bitmap_size = PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size);                                                                                                       \\\n+    size_t items_and_bitmap_size = (size_t)page_size * sizeof(T) + bitmap_size;                                                                                           \\\n+    page = malloc_flex(sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)), items_and_bitmap_size, 1);                                                                        \\\n+    if (page == NULL)                                                                                                                                                     \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"failure in malloc_flex for page, page_size=%\" PRIu32 \", sizeof(\" MU_TOSTRING(T) \")=%zu, bitmap_size=%zu\", page_size, sizeof(T), bitmap_size);          \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        /* Initialize bitmap to all zeros (nothing allocated) - bitmap is at end of items array */                                                                       \\\n+        uint8_t* bitmap = PAGED_SPARSE_ARRAY_GET_BITMAP(page, page_size, T);                                                                                              \\\n+        (void)memset(bitmap, 0, bitmap_size);                                                                                                                             \\\n+        page->allocated_count = 0;                                                                                                                                        \\\n+    }                                                                                                                                                                     \\\n+    return page;                                                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DEFINE(C, T)                                                                                                                        \\\n+T* PAGED_SPARSE_ARRAY_LL_ALLOCATE(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint32_t index)                                                                          \\\n+{                                                                                                                                                                          \\\n+    T* result;                                                                                                                                                             \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_011: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                                \\\n+    if (paged_sparse_array == NULL)                                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: PAGED_SPARSE_ARRAY(\" MU_TOSTRING(T) \") paged_sparse_array=%p\", paged_sparse_array);                                                   \\\n+    }                                                                                                                                                                      \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_012: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                \\\n+    else if (index >= paged_sparse_array->max_size)                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: uint32_t index=%\" PRIu32 \" out of bound, max_size=%\" PRIu32 \"\", index, paged_sparse_array->max_size);                                 \\\n+    }                                                                                                                                                                      \\\n+    else                                                                                                                                                                   \\\n+    {                                                                                                                                                                      \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_013: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall compute the page index as index / page_size. ]*/                                    \\\n+        uint32_t page_index = index / paged_sparse_array->page_size;                                                                                                       \\\n+        uint32_t index_in_page = index % paged_sparse_array->page_size;                                                                                                    \\","path":"inc/c_util/paged_sparse_array_ll.h","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":">uint32_t index_in_page = index % paged_sparse_array->page_size;      [](http://example.com/codeflow?start=8&length=68)\r\n\r\nmod operation can be delayed until it is used.","created_at":"2026-01-12T14:16:55Z","updated_at":"2026-01-12T14:16:55Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682470436","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682470436"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682470436"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682470436/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":237,"original_line":237,"side":"RIGHT","author_association":"MEMBER","original_position":237,"position":237,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682504410","pull_request_review_id":3651034134,"id":2682504410,"node_id":"PRRC_kwDODaUZTc6f48Ta","diff_hunk":"@@ -0,0 +1,414 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#ifndef PAGED_SPARSE_ARRAY_LL_H\n+#define PAGED_SPARSE_ARRAY_LL_H\n+\n+#ifdef __cplusplus\n+#include <cinttypes>\n+#include <cstdlib>\n+#else // __cplusplus\n+#include <inttypes.h>\n+#include <stdlib.h>\n+#endif // __cplusplus\n+\n+#include \"c_pal/gballoc_hl.h\"\n+#include \"c_pal/gballoc_hl_redirect.h\"\n+\n+#include \"macro_utils/macro_utils.h\"\n+\n+#include \"c_logging/logger.h\"\n+\n+#include \"c_pal/thandle_ll.h\"\n+\n+#include \"umock_c/umock_c_prod.h\"\n+\n+/*PAGED_SPARSE_ARRAY is backed by a THANDLE build on the structure below*/\n+#define PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T), _TAG)\n+\n+#define PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_STRUCT_, T)\n+\n+/*PAGE_STRUCT holds a single page with elements and allocation bitmap*/\n+#define PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T), _TAG)\n+#define PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_STRUCT_, T)\n+\n+/*PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) introduces the base type that holds the paged sparse array*/\n+#define PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(T)                                                                        \\\n+/*define the page structure first - bitmap is embedded after items[] in the same allocation*/                          \\\n+typedef struct PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T)                                                          \\\n+{                                                                                                                       \\\n+    uint32_t allocated_count;                                                                                           \\\n+    T items[];  /*followed by bitmap bytes at offset page_size * sizeof(T)*/                                            \\\n+} PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T);                                                                              \\\n+/*forward define the typedef of the PAGED_SPARSE_ARRAY struct so that it can be used for a function pointer definition*/\\\n+typedef struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T);                           \\\n+struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T)                                                                       \\\n+{                                                                                                                       \\\n+    uint32_t max_size;                                                                                                  \\\n+    uint32_t page_size;                                                                                                 \\\n+    uint32_t page_count;                                                                                                \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* pages[];                                                                   \\\n+};                                                                                                                      \\\n+\n+/*PAGED_SPARSE_ARRAY is-a THANDLE*/\n+/*given a type \"T\" PAGED_SPARSE_ARRAY_LL(T) expands to the name of the type. */\n+#define PAGED_SPARSE_ARRAY_LL(T) THANDLE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*because PAGED_SPARSE_ARRAY is a THANDLE, all THANDLE's macro APIs are useable with PAGED_SPARSE_ARRAY.*/\n+/*the below are just shortcuts of THANDLE's public ones*/\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE(T) THANDLE_INITIALIZE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_ASSIGN(T) THANDLE_ASSIGN(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_MOVE(T) THANDLE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE_MOVE(T) THANDLE_INITIALIZE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*introduces a new name for a function that returns a PAGED_SPARSE_ARRAY_LL(T)*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_CREATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_CREATE(C) PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C)\n+\n+/*introduces a name for the function that frees a PAGED_SPARSE_ARRAY when its ref count goes to 0*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_FREE_, C)\n+\n+/*introduces a name for the allocate function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C)\n+\n+/*introduces a name for the release function*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_RELEASE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE(C) PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C)\n+\n+/*introduces a name for the allocate_or_get function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C)\n+\n+/*introduces a name for the get function*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_GET(C) PAGED_SPARSE_ARRAY_LL_GET_NAME(C)\n+\n+/*introduces a function declaration for paged_sparse_array_create*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, PAGED_SPARSE_ARRAY_LL(T), PAGED_SPARSE_ARRAY_LL_CREATE(C), uint32_t, max_size, uint32_t, page_size);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_release*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, int, PAGED_SPARSE_ARRAY_LL_RELEASE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate_or_get*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_get*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*helper to compute bitmap size in bytes (1 bit per element, rounded up to nearest byte)*/\n+#define PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size) (((page_size) + 7) / 8)\n+\n+/*helper to get the allocation bitmap from a page - bitmap is stored after items[] in the same allocation*/\n+#define PAGED_SPARSE_ARRAY_GET_BITMAP(page, page_size, T) ((uint8_t*)((page)->items + (page_size)))\n+\n+/*helper to check if an element is allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_IS_ALLOCATED(bitmap, index_in_page) \\\n+    (((bitmap)[(index_in_page) / 8] & (1 << ((index_in_page) % 8))) != 0)\n+\n+/*helper to set an element as allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_SET_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] |= (1 << ((index_in_page) % 8)))\n+\n+/*helper to clear an element as not allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_CLEAR_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] &= ~(1 << ((index_in_page) % 8)))\n+\n+/*introduces a function definition for freeing the allocated resources for a PAGED_SPARSE_ARRAY*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_DEFINE(C, T)                                                                                \\\n+static void PAGED_SPARSE_ARRAY_LL_FREE_NAME(C)(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* paged_sparse_array)                         \\\n+{                                                                                                                              \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_009: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_FREE(T) shall return. ]*/      \\\n+    if (paged_sparse_array == NULL)                                                                                            \\\n+    {                                                                                                                          \\\n+        LogError(\"invalid arguments \" MU_TOSTRING(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)) \"* paged_sparse_array=%p\",               \\\n+            paged_sparse_array);                                                                                               \\\n+    }                                                                                                                          \\\n+    else                                                                                                                       \\\n+    {                                                                                                                          \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_010: [ PAGED_SPARSE_ARRAY_FREE(T) shall free all pages that are non-NULL. ]*/       \\\n+        for (uint32_t i = 0; i < paged_sparse_array->page_count; i++)                                                          \\\n+        {                                                                                                                      \\\n+            if (paged_sparse_array->pages[i] != NULL)                                                                          \\\n+            {                                                                                                                  \\\n+                /* bitmap is embedded in same allocation as page, so only one free needed */                                  \\\n+                free((void*)paged_sparse_array->pages[i]);                                                                     \\\n+            }                                                                                                                  \\\n+        }                                                                                                                      \\\n+    }                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DEFINE(C, T)                                                                                                                         \\\n+PAGED_SPARSE_ARRAY_LL(T) PAGED_SPARSE_ARRAY_LL_CREATE(C)(uint32_t max_size, uint32_t page_size)                                                                           \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* result;                                                                                                                           \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_001: [ If max_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                           \\\n+    if (max_size == 0)                                                                                                                                                    \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t max_size=%\" PRIu32 \"\", max_size);                                                                                           \\\n+    }                                                                                                                                                                     \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_002: [ If page_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                          \\\n+    else if (page_size == 0)                                                                                                                                              \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t page_size=%\" PRIu32 \"\", page_size);                                                                                         \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_003: [ PAGED_SPARSE_ARRAY_CREATE(T) shall compute the number of pages as (max_size + page_size - 1) / page_size. ]*/           \\\n+        uint32_t page_count = (max_size + page_size - 1) / page_size;                                                                                                     \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_004: [ PAGED_SPARSE_ARRAY_CREATE(T) shall call THANDLE_MALLOC_FLEX to allocate memory for the paged sparse array with the number of pages. ]*/ \\\n+        result = THANDLE_MALLOC_FLEX(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(PAGED_SPARSE_ARRAY_LL_FREE_NAME(C), page_count, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)*)); \\\n+        if (result == NULL)                                                                                                                                               \\\n+        {                                                                                                                                                                 \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_007: [ If there are any errors, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                               \\\n+            LogError(\"failure in THANDLE_MALLOC_FLEX page_count=%\" PRIu32 \", sizeof(PAGED_SPARSE_ARRAY_PAGE*)=%zu\", page_count, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)*)); \\\n+        }                                                                                                                                                                 \\\n+        else                                                                                                                                                              \\\n+        {                                                                                                                                                                 \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_006: [ PAGED_SPARSE_ARRAY_CREATE(T) shall store max_size and page_size in the structure. ]*/                               \\\n+            result->max_size = max_size;                                                                                                                                  \\\n+            result->page_size = page_size;                                                                                                                                \\\n+            result->page_count = page_count;                                                                                                                              \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_005: [ PAGED_SPARSE_ARRAY_CREATE(T) shall set all page pointers to NULL. ]*/                                               \\\n+            for (uint32_t i = 0; i < page_count; i++)                                                                                                                     \\\n+            {                                                                                                                                                             \\\n+                result->pages[i] = NULL;                                                                                                                                  \\\n+            }                                                                                                                                                             \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_008: [ PAGED_SPARSE_ARRAY_CREATE(T) shall succeed and return a non-NULL value. ]*/                                         \\\n+            goto all_ok;                                                                                                                                                  \\\n+        }                                                                                                                                                                 \\\n+    }                                                                                                                                                                     \\\n+    result = NULL;                                                                                                                                                        \\\n+all_ok:                                                                                                                                                                   \\\n+    return result;                                                                                                                                                        \\\n+}\n+\n+/*internal helper to allocate a page*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_, C)\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_DEFINE(C, T)                                                                                                         \\\n+static PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(uint32_t page_size)                                                  \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* page;                                                                                                                        \\\n+    /* Allocate page struct + items array + bitmap in a single allocation */                                                                                             \\\n+    size_t bitmap_size = PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size);                                                                                                       \\\n+    size_t items_and_bitmap_size = (size_t)page_size * sizeof(T) + bitmap_size;                                                                                           \\\n+    page = malloc_flex(sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)), items_and_bitmap_size, 1);                                                                        \\\n+    if (page == NULL)                                                                                                                                                     \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"failure in malloc_flex for page, page_size=%\" PRIu32 \", sizeof(\" MU_TOSTRING(T) \")=%zu, bitmap_size=%zu\", page_size, sizeof(T), bitmap_size);          \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        /* Initialize bitmap to all zeros (nothing allocated) - bitmap is at end of items array */                                                                       \\\n+        uint8_t* bitmap = PAGED_SPARSE_ARRAY_GET_BITMAP(page, page_size, T);                                                                                              \\\n+        (void)memset(bitmap, 0, bitmap_size);                                                                                                                             \\\n+        page->allocated_count = 0;                                                                                                                                        \\\n+    }                                                                                                                                                                     \\\n+    return page;                                                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DEFINE(C, T)                                                                                                                        \\\n+T* PAGED_SPARSE_ARRAY_LL_ALLOCATE(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint32_t index)                                                                          \\\n+{                                                                                                                                                                          \\\n+    T* result;                                                                                                                                                             \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_011: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                                \\\n+    if (paged_sparse_array == NULL)                                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: PAGED_SPARSE_ARRAY(\" MU_TOSTRING(T) \") paged_sparse_array=%p\", paged_sparse_array);                                                   \\\n+    }                                                                                                                                                                      \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_012: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                \\\n+    else if (index >= paged_sparse_array->max_size)                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: uint32_t index=%\" PRIu32 \" out of bound, max_size=%\" PRIu32 \"\", index, paged_sparse_array->max_size);                                 \\\n+    }                                                                                                                                                                      \\\n+    else                                                                                                                                                                   \\\n+    {                                                                                                                                                                      \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_013: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall compute the page index as index / page_size. ]*/                                    \\\n+        uint32_t page_index = index / paged_sparse_array->page_size;                                                                                                       \\\n+        uint32_t index_in_page = index % paged_sparse_array->page_size;                                                                                                    \\\n+        PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* array = THANDLE_GET_T(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(paged_sparse_array);                                                 \\\n+                                                                                                                                                                           \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_014: [ If the page is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall allocate memory for the page containing page_size elements and an allocation bitmap, and initialize all elements as not allocated. ]*/ \\\n+        if (                                                                                                                                                               \\\n+            (array->pages[page_index] == NULL) &&                                                                                                                          \\\n+            ((array->pages[page_index] = PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(paged_sparse_array->page_size)) == NULL)                                     \\\n+            )                                                                                                                                                              \\\n+        {                                                                                                                                                                  \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_018: [ If there are any errors, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                              \\\n+            LogError(\"failure allocating page at page_index=%\" PRIu32 \"\", page_index);                                                                                     \\\n+        }                                                                                                                                                                  \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_015: [ If the element at index is already allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/             \\\n+        else if (PAGED_SPARSE_ARRAY_IS_ALLOCATED(PAGED_SPARSE_ARRAY_GET_BITMAP(array->pages[page_index], paged_sparse_array->page_size, T), index_in_page))                \\\n+        {                                                                                                                                                                  \\\n+            LogError(\"Element at index=%\" PRIu32 \" is already allocated\", index);                                                                                          \\\n+        }                                                                                                                                                                  \\\n+        else                                                                                                                                                               \\\n+        {                                                                                                                                                                  \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_016: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall mark the element at index as allocated. ]*/                                     \\\n+            PAGED_SPARSE_ARRAY_SET_ALLOCATED(PAGED_SPARSE_ARRAY_GET_BITMAP(array->pages[page_index], paged_sparse_array->page_size, T), index_in_page);                                                                  \\\n+            array->pages[page_index]->allocated_count++;                                                                                                                   \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_017: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall return a pointer to the element at index. ]*/                                   \\\n+            result = &array->pages[page_index]->items[index_in_page];                                                                                                      \\\n+            goto all_ok;                                                                                                                                                   \\\n+        }                                                                                                                                                                  \\\n+    }                                                                                                                                                                      \\\n+    result = NULL;                                                                                                                                                         \\\n+all_ok:                                                                                                                                                                    \\\n+    return result;                                                                                                                                                         \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DEFINE(C, T)                                                                                                                          \\\n+int PAGED_SPARSE_ARRAY_LL_RELEASE(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint32_t index)                                                                           \\\n+{                                                                                                                                                                           \\\n+    int result;                                                                                                                                                             \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_019: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/                      \\\n+    if (paged_sparse_array == NULL)                                                                                                                                         \\\n+    {                                                                                                                                                                       \\\n+        LogError(\"Invalid arguments: PAGED_SPARSE_ARRAY(\" MU_TOSTRING(T) \") paged_sparse_array=%p\", paged_sparse_array);                                                    \\\n+        result = MU_FAILURE;                                                                                                                                                \\\n+    }                                                                                                                                                                       \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_020: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/      \\\n+    else if (index >= paged_sparse_array->max_size)                                                                                                                         \\\n+    {                                                                                                                                                                       \\\n+        LogError(\"Invalid arguments: uint32_t index=%\" PRIu32 \" out of bound, max_size=%\" PRIu32 \"\", index, paged_sparse_array->max_size);                                  \\\n+        result = MU_FAILURE;                                                                                                                                                \\\n+    }                                                                                                                                                                       \\\n+    else                                                                                                                                                                    \\\n+    {                                                                                                                                                                       \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_021: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall compute the page index as index / page_size. ]*/                                      \\\n+        uint32_t page_index = index / paged_sparse_array->page_size;                                                                                                        \\\n+        uint32_t index_in_page = index % paged_sparse_array->page_size;                                                                                                     \\\n+        PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* array = THANDLE_GET_T(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(paged_sparse_array);                                                  \\\n+                                                                                                                                                                            \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_022: [ If the page is not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/                   \\\n+        if (array->pages[page_index] == NULL)                                                                                                                               \\\n+        {                                                                                                                                                                   \\\n+            LogError(\"Page at page_index=%\" PRIu32 \" is not allocated\", page_index);                                                                                        \\\n+            result = MU_FAILURE;                                                                                                                                            \\\n+        }                                                                                                                                                                   \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_023: [ If the element at index is not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/       \\\n+        else if (!PAGED_SPARSE_ARRAY_IS_ALLOCATED(PAGED_SPARSE_ARRAY_GET_BITMAP(array->pages[page_index], paged_sparse_array->page_size, T), index_in_page))                \\\n+        {                                                                                                                                                                   \\\n+            LogError(\"Element at index=%\" PRIu32 \" is not allocated\", index);                                                                                               \\\n+            result = MU_FAILURE;                                                                                                                                            \\\n+        }                                                                                                                                                                   \\\n+        else                                                                                                                                                                \\\n+        {                                                                                                                                                                   \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_024: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall mark the element at index as not allocated. ]*/                                   \\\n+            PAGED_SPARSE_ARRAY_CLEAR_ALLOCATED(PAGED_SPARSE_ARRAY_GET_BITMAP(array->pages[page_index], paged_sparse_array->page_size, T), index_in_page);                   \\\n+            array->pages[page_index]->allocated_count--;                                                                                                                    \\\n+                                                                                                                                                                            \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_025: [ If all elements in the page are now not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall free the page and set the page pointer to NULL. ]*/ \\\n+            if (array->pages[page_index]->allocated_count == 0)                                                                                                             \\\n+            {                                                                                                                                                               \\\n+                /* bitmap is embedded in same allocation as page, so only one free needed */                                                                               \\\n+                free((void*)array->pages[page_index]);                                                                                                                      \\\n+                array->pages[page_index] = NULL;                                                                                                                            \\\n+            }                                                                                                                                                               \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_026: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall return zero on success. ]*/                                                       \\\n+            result = 0;                                                                                                                                                     \\\n+        }                                                                                                                                                                   \\\n+    }                                                                                                                                                                       \\\n+    return result;                                                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DEFINE(C, T)                                                                                                                 \\\n+T* PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint32_t index)                                                                   \\\n+{                                                                                                                                                                          \\\n+    T* result;                                                                                                                                                             \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_027: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/                         \\\n+    if (paged_sparse_array == NULL)                                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: PAGED_SPARSE_ARRAY(\" MU_TOSTRING(T) \") paged_sparse_array=%p\", paged_sparse_array);                                                   \\\n+    }                                                                                                                                                                      \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_028: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/         \\\n+    else if (index >= paged_sparse_array->max_size)                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: uint32_t index=%\" PRIu32 \" out of bound, max_size=%\" PRIu32 \"\", index, paged_sparse_array->max_size);                                 \\\n+    }                                                                                                                                                                      \\\n+    else                                                                                                                                                                   \\\n+    {                                                                                                                                                                      \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_029: [ PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall compute the page index as index / page_size. ]*/                             \\\n+        uint32_t page_index = index / paged_sparse_array->page_size;                                                                                                       \\\n+        uint32_t index_in_page = index % paged_sparse_array->page_size;                                                                                                    \\\n+        PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* array = THANDLE_GET_T(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(paged_sparse_array);                                                 \\\n+                                                                                                                                                                           \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_030: [ If the page is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall allocate memory for the page containing page_size elements and an allocation bitmap, and initialize all elements as not allocated. ]*/ \\\n+        if (                                                                                                                                                               \\\n+            (array->pages[page_index] == NULL) &&                                                                                                                          \\\n+            ((array->pages[page_index] = PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(paged_sparse_array->page_size)) == NULL)                                     \\\n+            )                                                                                                                                                              \\\n+        {                                                                                                                                                                  \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_033: [ If there are any errors, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/                       \\\n+            LogError(\"failure allocating page at page_index=%\" PRIu32 \"\", page_index);                                                                                     \\\n+        }                                                                                                                                                                  \\\n+        else                                                                                                                                                               \\","path":"inc/c_util/paged_sparse_array_ll.h","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":">el [](http://example.com/codeflow?start=8&length=2)\r\n\r\n??\r\n\r\nEither I cannot read code anymore (probable) or this is bit weird.\r\n\r\nAssume an newly brand new created sparse_array with page_size=10, max_size = 100.\r\n\r\nAssume the user calls with valid index == 0.\r\n\r\nThen line 347 will evaluate to \"true\" so line 348 will get executed.\r\n\r\nAssume line 348 does indeed allocate. So the whole \"if\" condition is false, we go to else branch.\r\n\r\nQuestion is \"why do we check anything in the else branch\" - we know for a fact that the page has just been allocated.","created_at":"2026-01-12T14:25:30Z","updated_at":"2026-01-12T14:25:40Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682504410","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682504410"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682504410"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682504410/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":354,"original_line":354,"side":"RIGHT","author_association":"MEMBER","original_position":354,"position":354,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682520189","pull_request_review_id":3651053082,"id":2682520189,"node_id":"PRRC_kwDODaUZTc6f5AJ9","diff_hunk":"@@ -0,0 +1,414 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#ifndef PAGED_SPARSE_ARRAY_LL_H\n+#define PAGED_SPARSE_ARRAY_LL_H\n+\n+#ifdef __cplusplus\n+#include <cinttypes>\n+#include <cstdlib>\n+#else // __cplusplus\n+#include <inttypes.h>\n+#include <stdlib.h>\n+#endif // __cplusplus\n+\n+#include \"c_pal/gballoc_hl.h\"\n+#include \"c_pal/gballoc_hl_redirect.h\"\n+\n+#include \"macro_utils/macro_utils.h\"\n+\n+#include \"c_logging/logger.h\"\n+\n+#include \"c_pal/thandle_ll.h\"\n+\n+#include \"umock_c/umock_c_prod.h\"\n+\n+/*PAGED_SPARSE_ARRAY is backed by a THANDLE build on the structure below*/\n+#define PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T), _TAG)\n+\n+#define PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_STRUCT_, T)\n+\n+/*PAGE_STRUCT holds a single page with elements and allocation bitmap*/\n+#define PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T), _TAG)\n+#define PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_STRUCT_, T)\n+\n+/*PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) introduces the base type that holds the paged sparse array*/\n+#define PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(T)                                                                        \\\n+/*define the page structure first - bitmap is embedded after items[] in the same allocation*/                          \\\n+typedef struct PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T)                                                          \\\n+{                                                                                                                       \\\n+    uint32_t allocated_count;                                                                                           \\\n+    T items[];  /*followed by bitmap bytes at offset page_size * sizeof(T)*/                                            \\\n+} PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T);                                                                              \\\n+/*forward define the typedef of the PAGED_SPARSE_ARRAY struct so that it can be used for a function pointer definition*/\\\n+typedef struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T);                           \\\n+struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T)                                                                       \\\n+{                                                                                                                       \\\n+    uint32_t max_size;                                                                                                  \\\n+    uint32_t page_size;                                                                                                 \\\n+    uint32_t page_count;                                                                                                \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* pages[];                                                                   \\\n+};                                                                                                                      \\\n+\n+/*PAGED_SPARSE_ARRAY is-a THANDLE*/\n+/*given a type \"T\" PAGED_SPARSE_ARRAY_LL(T) expands to the name of the type. */\n+#define PAGED_SPARSE_ARRAY_LL(T) THANDLE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*because PAGED_SPARSE_ARRAY is a THANDLE, all THANDLE's macro APIs are useable with PAGED_SPARSE_ARRAY.*/\n+/*the below are just shortcuts of THANDLE's public ones*/\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE(T) THANDLE_INITIALIZE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_ASSIGN(T) THANDLE_ASSIGN(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_MOVE(T) THANDLE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE_MOVE(T) THANDLE_INITIALIZE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*introduces a new name for a function that returns a PAGED_SPARSE_ARRAY_LL(T)*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_CREATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_CREATE(C) PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C)\n+\n+/*introduces a name for the function that frees a PAGED_SPARSE_ARRAY when its ref count goes to 0*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_FREE_, C)\n+\n+/*introduces a name for the allocate function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C)\n+\n+/*introduces a name for the release function*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_RELEASE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE(C) PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C)\n+\n+/*introduces a name for the allocate_or_get function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C)\n+\n+/*introduces a name for the get function*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_GET(C) PAGED_SPARSE_ARRAY_LL_GET_NAME(C)\n+\n+/*introduces a function declaration for paged_sparse_array_create*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, PAGED_SPARSE_ARRAY_LL(T), PAGED_SPARSE_ARRAY_LL_CREATE(C), uint32_t, max_size, uint32_t, page_size);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_release*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, int, PAGED_SPARSE_ARRAY_LL_RELEASE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate_or_get*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_get*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*helper to compute bitmap size in bytes (1 bit per element, rounded up to nearest byte)*/\n+#define PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size) (((page_size) + 7) / 8)\n+\n+/*helper to get the allocation bitmap from a page - bitmap is stored after items[] in the same allocation*/\n+#define PAGED_SPARSE_ARRAY_GET_BITMAP(page, page_size, T) ((uint8_t*)((page)->items + (page_size)))\n+\n+/*helper to check if an element is allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_IS_ALLOCATED(bitmap, index_in_page) \\\n+    (((bitmap)[(index_in_page) / 8] & (1 << ((index_in_page) % 8))) != 0)\n+\n+/*helper to set an element as allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_SET_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] |= (1 << ((index_in_page) % 8)))\n+\n+/*helper to clear an element as not allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_CLEAR_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] &= ~(1 << ((index_in_page) % 8)))\n+\n+/*introduces a function definition for freeing the allocated resources for a PAGED_SPARSE_ARRAY*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_DEFINE(C, T)                                                                                \\\n+static void PAGED_SPARSE_ARRAY_LL_FREE_NAME(C)(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* paged_sparse_array)                         \\\n+{                                                                                                                              \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_009: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_FREE(T) shall return. ]*/      \\\n+    if (paged_sparse_array == NULL)                                                                                            \\\n+    {                                                                                                                          \\\n+        LogError(\"invalid arguments \" MU_TOSTRING(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)) \"* paged_sparse_array=%p\",               \\\n+            paged_sparse_array);                                                                                               \\\n+    }                                                                                                                          \\\n+    else                                                                                                                       \\\n+    {                                                                                                                          \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_010: [ PAGED_SPARSE_ARRAY_FREE(T) shall free all pages that are non-NULL. ]*/       \\\n+        for (uint32_t i = 0; i < paged_sparse_array->page_count; i++)                                                          \\\n+        {                                                                                                                      \\\n+            if (paged_sparse_array->pages[i] != NULL)                                                                          \\\n+            {                                                                                                                  \\\n+                /* bitmap is embedded in same allocation as page, so only one free needed */                                  \\\n+                free((void*)paged_sparse_array->pages[i]);                                                                     \\\n+            }                                                                                                                  \\\n+        }                                                                                                                      \\\n+    }                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DEFINE(C, T)                                                                                                                         \\\n+PAGED_SPARSE_ARRAY_LL(T) PAGED_SPARSE_ARRAY_LL_CREATE(C)(uint32_t max_size, uint32_t page_size)                                                                           \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* result;                                                                                                                           \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_001: [ If max_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                           \\\n+    if (max_size == 0)                                                                                                                                                    \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t max_size=%\" PRIu32 \"\", max_size);                                                                                           \\\n+    }                                                                                                                                                                     \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_002: [ If page_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                          \\\n+    else if (page_size == 0)                                                                                                                                              \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t page_size=%\" PRIu32 \"\", page_size);                                                                                         \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_003: [ PAGED_SPARSE_ARRAY_CREATE(T) shall compute the number of pages as (max_size + page_size - 1) / page_size. ]*/           \\\n+        uint32_t page_count = (max_size + page_size - 1) / page_size;                                                                                                     \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_004: [ PAGED_SPARSE_ARRAY_CREATE(T) shall call THANDLE_MALLOC_FLEX to allocate memory for the paged sparse array with the number of pages. ]*/ \\\n+        result = THANDLE_MALLOC_FLEX(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(PAGED_SPARSE_ARRAY_LL_FREE_NAME(C), page_count, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)*)); \\\n+        if (result == NULL)                                                                                                                                               \\\n+        {                                                                                                                                                                 \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_007: [ If there are any errors, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                               \\\n+            LogError(\"failure in THANDLE_MALLOC_FLEX page_count=%\" PRIu32 \", sizeof(PAGED_SPARSE_ARRAY_PAGE*)=%zu\", page_count, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)*)); \\\n+        }                                                                                                                                                                 \\\n+        else                                                                                                                                                              \\\n+        {                                                                                                                                                                 \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_006: [ PAGED_SPARSE_ARRAY_CREATE(T) shall store max_size and page_size in the structure. ]*/                               \\\n+            result->max_size = max_size;                                                                                                                                  \\\n+            result->page_size = page_size;                                                                                                                                \\\n+            result->page_count = page_count;                                                                                                                              \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_005: [ PAGED_SPARSE_ARRAY_CREATE(T) shall set all page pointers to NULL. ]*/                                               \\\n+            for (uint32_t i = 0; i < page_count; i++)                                                                                                                     \\\n+            {                                                                                                                                                             \\\n+                result->pages[i] = NULL;                                                                                                                                  \\\n+            }                                                                                                                                                             \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_008: [ PAGED_SPARSE_ARRAY_CREATE(T) shall succeed and return a non-NULL value. ]*/                                         \\\n+            goto all_ok;                                                                                                                                                  \\\n+        }                                                                                                                                                                 \\\n+    }                                                                                                                                                                     \\\n+    result = NULL;                                                                                                                                                        \\\n+all_ok:                                                                                                                                                                   \\\n+    return result;                                                                                                                                                        \\\n+}\n+\n+/*internal helper to allocate a page*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_, C)\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_DEFINE(C, T)                                                                                                         \\\n+static PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(uint32_t page_size)                                                  \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* page;                                                                                                                        \\\n+    /* Allocate page struct + items array + bitmap in a single allocation */                                                                                             \\\n+    size_t bitmap_size = PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size);                                                                                                       \\\n+    size_t items_and_bitmap_size = (size_t)page_size * sizeof(T) + bitmap_size;                                                                                           \\\n+    page = malloc_flex(sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)), items_and_bitmap_size, 1);                                                                        \\\n+    if (page == NULL)                                                                                                                                                     \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"failure in malloc_flex for page, page_size=%\" PRIu32 \", sizeof(\" MU_TOSTRING(T) \")=%zu, bitmap_size=%zu\", page_size, sizeof(T), bitmap_size);          \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        /* Initialize bitmap to all zeros (nothing allocated) - bitmap is at end of items array */                                                                       \\\n+        uint8_t* bitmap = PAGED_SPARSE_ARRAY_GET_BITMAP(page, page_size, T);                                                                                              \\\n+        (void)memset(bitmap, 0, bitmap_size);                                                                                                                             \\\n+        page->allocated_count = 0;                                                                                                                                        \\\n+    }                                                                                                                                                                     \\\n+    return page;                                                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DEFINE(C, T)                                                                                                                        \\\n+T* PAGED_SPARSE_ARRAY_LL_ALLOCATE(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint32_t index)                                                                          \\\n+{                                                                                                                                                                          \\\n+    T* result;                                                                                                                                                             \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_011: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                                \\\n+    if (paged_sparse_array == NULL)                                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: PAGED_SPARSE_ARRAY(\" MU_TOSTRING(T) \") paged_sparse_array=%p\", paged_sparse_array);                                                   \\\n+    }                                                                                                                                                                      \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_012: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                \\\n+    else if (index >= paged_sparse_array->max_size)                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: uint32_t index=%\" PRIu32 \" out of bound, max_size=%\" PRIu32 \"\", index, paged_sparse_array->max_size);                                 \\\n+    }                                                                                                                                                                      \\\n+    else                                                                                                                                                                   \\\n+    {                                                                                                                                                                      \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_013: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall compute the page index as index / page_size. ]*/                                    \\\n+        uint32_t page_index = index / paged_sparse_array->page_size;                                                                                                       \\\n+        uint32_t index_in_page = index % paged_sparse_array->page_size;                                                                                                    \\\n+        PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* array = THANDLE_GET_T(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(paged_sparse_array);                                                 \\\n+                                                                                                                                                                           \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_014: [ If the page is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall allocate memory for the page containing page_size elements and an allocation bitmap, and initialize all elements as not allocated. ]*/ \\\n+        if (                                                                                                                                                               \\\n+            (array->pages[page_index] == NULL) &&                                                                                                                          \\\n+            ((array->pages[page_index] = PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(paged_sparse_array->page_size)) == NULL)                                     \\\n+            )                                                                                                                                                              \\\n+        {                                                                                                                                                                  \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_018: [ If there are any errors, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                              \\\n+            LogError(\"failure allocating page at page_index=%\" PRIu32 \"\", page_index);                                                                                     \\\n+        }                                                                                                                                                                  \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_015: [ If the element at index is already allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/             \\\n+        else if (PAGED_SPARSE_ARRAY_IS_ALLOCATED(PAGED_SPARSE_ARRAY_GET_BITMAP(array->pages[page_index], paged_sparse_array->page_size, T), index_in_page))                \\\n+        {                                                                                                                                                                  \\\n+            LogError(\"Element at index=%\" PRIu32 \" is already allocated\", index);                                                                                          \\\n+        }                                                                                                                                                                  \\\n+        else                                                                                                                                                               \\\n+        {                                                                                                                                                                  \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_016: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall mark the element at index as allocated. ]*/                                     \\\n+            PAGED_SPARSE_ARRAY_SET_ALLOCATED(PAGED_SPARSE_ARRAY_GET_BITMAP(array->pages[page_index], paged_sparse_array->page_size, T), index_in_page);                                                                  \\\n+            array->pages[page_index]->allocated_count++;                                                                                                                   \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_017: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall return a pointer to the element at index. ]*/                                   \\\n+            result = &array->pages[page_index]->items[index_in_page];                                                                                                      \\\n+            goto all_ok;                                                                                                                                                   \\\n+        }                                                                                                                                                                  \\\n+    }                                                                                                                                                                      \\\n+    result = NULL;                                                                                                                                                         \\\n+all_ok:                                                                                                                                                                    \\\n+    return result;                                                                                                                                                         \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DEFINE(C, T)                                                                                                                          \\\n+int PAGED_SPARSE_ARRAY_LL_RELEASE(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint32_t index)                                                                           \\\n+{                                                                                                                                                                           \\\n+    int result;                                                                                                                                                             \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_019: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/                      \\\n+    if (paged_sparse_array == NULL)                                                                                                                                         \\\n+    {                                                                                                                                                                       \\\n+        LogError(\"Invalid arguments: PAGED_SPARSE_ARRAY(\" MU_TOSTRING(T) \") paged_sparse_array=%p\", paged_sparse_array);                                                    \\\n+        result = MU_FAILURE;                                                                                                                                                \\\n+    }                                                                                                                                                                       \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_020: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/      \\\n+    else if (index >= paged_sparse_array->max_size)                                                                                                                         \\\n+    {                                                                                                                                                                       \\\n+        LogError(\"Invalid arguments: uint32_t index=%\" PRIu32 \" out of bound, max_size=%\" PRIu32 \"\", index, paged_sparse_array->max_size);                                  \\\n+        result = MU_FAILURE;                                                                                                                                                \\\n+    }                                                                                                                                                                       \\\n+    else                                                                                                                                                                    \\\n+    {                                                                                                                                                                       \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_021: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall compute the page index as index / page_size. ]*/                                      \\\n+        uint32_t page_index = index / paged_sparse_array->page_size;                                                                                                        \\\n+        uint32_t index_in_page = index % paged_sparse_array->page_size;                                                                                                     \\\n+        PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* array = THANDLE_GET_T(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(paged_sparse_array);                                                  \\\n+                                                                                                                                                                            \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_022: [ If the page is not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/                   \\\n+        if (array->pages[page_index] == NULL)                                                                                                                               \\\n+        {                                                                                                                                                                   \\\n+            LogError(\"Page at page_index=%\" PRIu32 \" is not allocated\", page_index);                                                                                        \\\n+            result = MU_FAILURE;                                                                                                                                            \\\n+        }                                                                                                                                                                   \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_023: [ If the element at index is not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/       \\\n+        else if (!PAGED_SPARSE_ARRAY_IS_ALLOCATED(PAGED_SPARSE_ARRAY_GET_BITMAP(array->pages[page_index], paged_sparse_array->page_size, T), index_in_page))                \\\n+        {                                                                                                                                                                   \\\n+            LogError(\"Element at index=%\" PRIu32 \" is not allocated\", index);                                                                                               \\\n+            result = MU_FAILURE;                                                                                                                                            \\\n+        }                                                                                                                                                                   \\\n+        else                                                                                                                                                                \\\n+        {                                                                                                                                                                   \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_024: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall mark the element at index as not allocated. ]*/                                   \\\n+            PAGED_SPARSE_ARRAY_CLEAR_ALLOCATED(PAGED_SPARSE_ARRAY_GET_BITMAP(array->pages[page_index], paged_sparse_array->page_size, T), index_in_page);                   \\\n+            array->pages[page_index]->allocated_count--;                                                                                                                    \\\n+                                                                                                                                                                            \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_025: [ If all elements in the page are now not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall free the page and set the page pointer to NULL. ]*/ \\\n+            if (array->pages[page_index]->allocated_count == 0)                                                                                                             \\\n+            {                                                                                                                                                               \\\n+                /* bitmap is embedded in same allocation as page, so only one free needed */                                                                               \\\n+                free((void*)array->pages[page_index]);                                                                                                                      \\\n+                array->pages[page_index] = NULL;                                                                                                                            \\\n+            }                                                                                                                                                               \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_026: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall return zero on success. ]*/                                                       \\\n+            result = 0;                                                                                                                                                     \\\n+        }                                                                                                                                                                   \\\n+    }                                                                                                                                                                       \\\n+    return result;                                                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DEFINE(C, T)                                                                                                                 \\\n+T* PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint32_t index)                                                                   \\\n+{                                                                                                                                                                          \\\n+    T* result;                                                                                                                                                             \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_027: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/                         \\\n+    if (paged_sparse_array == NULL)                                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: PAGED_SPARSE_ARRAY(\" MU_TOSTRING(T) \") paged_sparse_array=%p\", paged_sparse_array);                                                   \\\n+    }                                                                                                                                                                      \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_028: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/         \\\n+    else if (index >= paged_sparse_array->max_size)                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: uint32_t index=%\" PRIu32 \" out of bound, max_size=%\" PRIu32 \"\", index, paged_sparse_array->max_size);                                 \\\n+    }                                                                                                                                                                      \\\n+    else                                                                                                                                                                   \\\n+    {                                                                                                                                                                      \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_029: [ PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall compute the page index as index / page_size. ]*/                             \\\n+        uint32_t page_index = index / paged_sparse_array->page_size;                                                                                                       \\\n+        uint32_t index_in_page = index % paged_sparse_array->page_size;                                                                                                    \\\n+        PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* array = THANDLE_GET_T(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(paged_sparse_array);                                                 \\\n+                                                                                                                                                                           \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_030: [ If the page is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall allocate memory for the page containing page_size elements and an allocation bitmap, and initialize all elements as not allocated. ]*/ \\\n+        if (                                                                                                                                                               \\\n+            (array->pages[page_index] == NULL) &&                                                                                                                          \\\n+            ((array->pages[page_index] = PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(paged_sparse_array->page_size)) == NULL)                                     \\\n+            )                                                                                                                                                              \\\n+        {                                                                                                                                                                  \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_033: [ If there are any errors, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/                       \\\n+            LogError(\"failure allocating page at page_index=%\" PRIu32 \"\", page_index);                                                                                     \\\n+        }                                                                                                                                                                  \\\n+        else                                                                                                                                                               \\\n+        {                                                                                                                                                                  \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_031: [ If the element at index is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall mark it as allocated. ]*/      \\\n+            if (!PAGED_SPARSE_ARRAY_IS_ALLOCATED(PAGED_SPARSE_ARRAY_GET_BITMAP(array->pages[page_index], paged_sparse_array->page_size, T), index_in_page))                \\\n+            {                                                                                                                                                              \\\n+                PAGED_SPARSE_ARRAY_SET_ALLOCATED(PAGED_SPARSE_ARRAY_GET_BITMAP(array->pages[page_index], paged_sparse_array->page_size, T), index_in_page);                \\","path":"inc/c_util/paged_sparse_array_ll.h","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I am wondering is !IS_ALLOCATED + SET_ALLOCATED which sounds a bit like \"SET_ALLOCATED_IF_NOT_ALLOCATED_ALREADY\" could be combined in 1 operation which would return the \"previous value\".\r\n\r\nJust saying seeing as interlockedbittestandset exists or similar (if memory helps).","created_at":"2026-01-12T14:29:19Z","updated_at":"2026-01-12T14:29:19Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682520189","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682520189"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682520189"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682520189/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":359,"original_line":359,"side":"RIGHT","author_association":"MEMBER","original_position":359,"position":359,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682522359","pull_request_review_id":3651056045,"id":2682522359,"node_id":"PRRC_kwDODaUZTc6f5Ar3","diff_hunk":"@@ -0,0 +1,414 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#ifndef PAGED_SPARSE_ARRAY_LL_H\n+#define PAGED_SPARSE_ARRAY_LL_H\n+\n+#ifdef __cplusplus\n+#include <cinttypes>\n+#include <cstdlib>\n+#else // __cplusplus\n+#include <inttypes.h>\n+#include <stdlib.h>\n+#endif // __cplusplus\n+\n+#include \"c_pal/gballoc_hl.h\"\n+#include \"c_pal/gballoc_hl_redirect.h\"\n+\n+#include \"macro_utils/macro_utils.h\"\n+\n+#include \"c_logging/logger.h\"\n+\n+#include \"c_pal/thandle_ll.h\"\n+\n+#include \"umock_c/umock_c_prod.h\"\n+\n+/*PAGED_SPARSE_ARRAY is backed by a THANDLE build on the structure below*/\n+#define PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T), _TAG)\n+\n+#define PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_STRUCT_, T)\n+\n+/*PAGE_STRUCT holds a single page with elements and allocation bitmap*/\n+#define PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T), _TAG)\n+#define PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_STRUCT_, T)\n+\n+/*PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) introduces the base type that holds the paged sparse array*/\n+#define PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(T)                                                                        \\\n+/*define the page structure first - bitmap is embedded after items[] in the same allocation*/                          \\\n+typedef struct PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T)                                                          \\\n+{                                                                                                                       \\\n+    uint32_t allocated_count;                                                                                           \\\n+    T items[];  /*followed by bitmap bytes at offset page_size * sizeof(T)*/                                            \\\n+} PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T);                                                                              \\\n+/*forward define the typedef of the PAGED_SPARSE_ARRAY struct so that it can be used for a function pointer definition*/\\\n+typedef struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T);                           \\\n+struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T)                                                                       \\\n+{                                                                                                                       \\\n+    uint32_t max_size;                                                                                                  \\\n+    uint32_t page_size;                                                                                                 \\\n+    uint32_t page_count;                                                                                                \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* pages[];                                                                   \\\n+};                                                                                                                      \\\n+\n+/*PAGED_SPARSE_ARRAY is-a THANDLE*/\n+/*given a type \"T\" PAGED_SPARSE_ARRAY_LL(T) expands to the name of the type. */\n+#define PAGED_SPARSE_ARRAY_LL(T) THANDLE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*because PAGED_SPARSE_ARRAY is a THANDLE, all THANDLE's macro APIs are useable with PAGED_SPARSE_ARRAY.*/\n+/*the below are just shortcuts of THANDLE's public ones*/\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE(T) THANDLE_INITIALIZE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_ASSIGN(T) THANDLE_ASSIGN(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_MOVE(T) THANDLE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE_MOVE(T) THANDLE_INITIALIZE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*introduces a new name for a function that returns a PAGED_SPARSE_ARRAY_LL(T)*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_CREATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_CREATE(C) PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C)\n+\n+/*introduces a name for the function that frees a PAGED_SPARSE_ARRAY when its ref count goes to 0*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_FREE_, C)\n+\n+/*introduces a name for the allocate function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C)\n+\n+/*introduces a name for the release function*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_RELEASE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE(C) PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C)\n+\n+/*introduces a name for the allocate_or_get function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C)\n+\n+/*introduces a name for the get function*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_GET(C) PAGED_SPARSE_ARRAY_LL_GET_NAME(C)\n+\n+/*introduces a function declaration for paged_sparse_array_create*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, PAGED_SPARSE_ARRAY_LL(T), PAGED_SPARSE_ARRAY_LL_CREATE(C), uint32_t, max_size, uint32_t, page_size);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_release*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, int, PAGED_SPARSE_ARRAY_LL_RELEASE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate_or_get*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_get*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*helper to compute bitmap size in bytes (1 bit per element, rounded up to nearest byte)*/\n+#define PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size) (((page_size) + 7) / 8)\n+\n+/*helper to get the allocation bitmap from a page - bitmap is stored after items[] in the same allocation*/\n+#define PAGED_SPARSE_ARRAY_GET_BITMAP(page, page_size, T) ((uint8_t*)((page)->items + (page_size)))\n+\n+/*helper to check if an element is allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_IS_ALLOCATED(bitmap, index_in_page) \\\n+    (((bitmap)[(index_in_page) / 8] & (1 << ((index_in_page) % 8))) != 0)\n+\n+/*helper to set an element as allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_SET_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] |= (1 << ((index_in_page) % 8)))\n+\n+/*helper to clear an element as not allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_CLEAR_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] &= ~(1 << ((index_in_page) % 8)))\n+\n+/*introduces a function definition for freeing the allocated resources for a PAGED_SPARSE_ARRAY*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_DEFINE(C, T)                                                                                \\\n+static void PAGED_SPARSE_ARRAY_LL_FREE_NAME(C)(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* paged_sparse_array)                         \\\n+{                                                                                                                              \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_009: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_FREE(T) shall return. ]*/      \\\n+    if (paged_sparse_array == NULL)                                                                                            \\\n+    {                                                                                                                          \\\n+        LogError(\"invalid arguments \" MU_TOSTRING(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)) \"* paged_sparse_array=%p\",               \\\n+            paged_sparse_array);                                                                                               \\\n+    }                                                                                                                          \\\n+    else                                                                                                                       \\\n+    {                                                                                                                          \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_010: [ PAGED_SPARSE_ARRAY_FREE(T) shall free all pages that are non-NULL. ]*/       \\\n+        for (uint32_t i = 0; i < paged_sparse_array->page_count; i++)                                                          \\\n+        {                                                                                                                      \\\n+            if (paged_sparse_array->pages[i] != NULL)                                                                          \\\n+            {                                                                                                                  \\\n+                /* bitmap is embedded in same allocation as page, so only one free needed */                                  \\\n+                free((void*)paged_sparse_array->pages[i]);                                                                     \\\n+            }                                                                                                                  \\\n+        }                                                                                                                      \\\n+    }                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DEFINE(C, T)                                                                                                                         \\\n+PAGED_SPARSE_ARRAY_LL(T) PAGED_SPARSE_ARRAY_LL_CREATE(C)(uint32_t max_size, uint32_t page_size)                                                                           \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* result;                                                                                                                           \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_001: [ If max_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                           \\\n+    if (max_size == 0)                                                                                                                                                    \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t max_size=%\" PRIu32 \"\", max_size);                                                                                           \\\n+    }                                                                                                                                                                     \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_002: [ If page_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                          \\\n+    else if (page_size == 0)                                                                                                                                              \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t page_size=%\" PRIu32 \"\", page_size);                                                                                         \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_003: [ PAGED_SPARSE_ARRAY_CREATE(T) shall compute the number of pages as (max_size + page_size - 1) / page_size. ]*/           \\\n+        uint32_t page_count = (max_size + page_size - 1) / page_size;                                                                                                     \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_004: [ PAGED_SPARSE_ARRAY_CREATE(T) shall call THANDLE_MALLOC_FLEX to allocate memory for the paged sparse array with the number of pages. ]*/ \\\n+        result = THANDLE_MALLOC_FLEX(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(PAGED_SPARSE_ARRAY_LL_FREE_NAME(C), page_count, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)*)); \\\n+        if (result == NULL)                                                                                                                                               \\\n+        {                                                                                                                                                                 \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_007: [ If there are any errors, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                               \\\n+            LogError(\"failure in THANDLE_MALLOC_FLEX page_count=%\" PRIu32 \", sizeof(PAGED_SPARSE_ARRAY_PAGE*)=%zu\", page_count, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)*)); \\\n+        }                                                                                                                                                                 \\\n+        else                                                                                                                                                              \\\n+        {                                                                                                                                                                 \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_006: [ PAGED_SPARSE_ARRAY_CREATE(T) shall store max_size and page_size in the structure. ]*/                               \\\n+            result->max_size = max_size;                                                                                                                                  \\\n+            result->page_size = page_size;                                                                                                                                \\\n+            result->page_count = page_count;                                                                                                                              \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_005: [ PAGED_SPARSE_ARRAY_CREATE(T) shall set all page pointers to NULL. ]*/                                               \\\n+            for (uint32_t i = 0; i < page_count; i++)                                                                                                                     \\\n+            {                                                                                                                                                             \\\n+                result->pages[i] = NULL;                                                                                                                                  \\\n+            }                                                                                                                                                             \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_008: [ PAGED_SPARSE_ARRAY_CREATE(T) shall succeed and return a non-NULL value. ]*/                                         \\\n+            goto all_ok;                                                                                                                                                  \\\n+        }                                                                                                                                                                 \\\n+    }                                                                                                                                                                     \\\n+    result = NULL;                                                                                                                                                        \\\n+all_ok:                                                                                                                                                                   \\\n+    return result;                                                                                                                                                        \\\n+}\n+\n+/*internal helper to allocate a page*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_, C)\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_DEFINE(C, T)                                                                                                         \\\n+static PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(uint32_t page_size)                                                  \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* page;                                                                                                                        \\\n+    /* Allocate page struct + items array + bitmap in a single allocation */                                                                                             \\\n+    size_t bitmap_size = PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size);                                                                                                       \\\n+    size_t items_and_bitmap_size = (size_t)page_size * sizeof(T) + bitmap_size;                                                                                           \\\n+    page = malloc_flex(sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)), items_and_bitmap_size, 1);                                                                        \\\n+    if (page == NULL)                                                                                                                                                     \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"failure in malloc_flex for page, page_size=%\" PRIu32 \", sizeof(\" MU_TOSTRING(T) \")=%zu, bitmap_size=%zu\", page_size, sizeof(T), bitmap_size);          \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        /* Initialize bitmap to all zeros (nothing allocated) - bitmap is at end of items array */                                                                       \\\n+        uint8_t* bitmap = PAGED_SPARSE_ARRAY_GET_BITMAP(page, page_size, T);                                                                                              \\\n+        (void)memset(bitmap, 0, bitmap_size);                                                                                                                             \\\n+        page->allocated_count = 0;                                                                                                                                        \\\n+    }                                                                                                                                                                     \\\n+    return page;                                                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DEFINE(C, T)                                                                                                                        \\\n+T* PAGED_SPARSE_ARRAY_LL_ALLOCATE(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint32_t index)                                                                          \\\n+{                                                                                                                                                                          \\\n+    T* result;                                                                                                                                                             \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_011: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                                \\\n+    if (paged_sparse_array == NULL)                                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: PAGED_SPARSE_ARRAY(\" MU_TOSTRING(T) \") paged_sparse_array=%p\", paged_sparse_array);                                                   \\\n+    }                                                                                                                                                                      \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_012: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                \\\n+    else if (index >= paged_sparse_array->max_size)                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: uint32_t index=%\" PRIu32 \" out of bound, max_size=%\" PRIu32 \"\", index, paged_sparse_array->max_size);                                 \\\n+    }                                                                                                                                                                      \\\n+    else                                                                                                                                                                   \\\n+    {                                                                                                                                                                      \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_013: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall compute the page index as index / page_size. ]*/                                    \\\n+        uint32_t page_index = index / paged_sparse_array->page_size;                                                                                                       \\\n+        uint32_t index_in_page = index % paged_sparse_array->page_size;                                                                                                    \\\n+        PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* array = THANDLE_GET_T(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(paged_sparse_array);                                                 \\\n+                                                                                                                                                                           \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_014: [ If the page is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall allocate memory for the page containing page_size elements and an allocation bitmap, and initialize all elements as not allocated. ]*/ \\\n+        if (                                                                                                                                                               \\\n+            (array->pages[page_index] == NULL) &&                                                                                                                          \\\n+            ((array->pages[page_index] = PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(paged_sparse_array->page_size)) == NULL)                                     \\\n+            )                                                                                                                                                              \\\n+        {                                                                                                                                                                  \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_018: [ If there are any errors, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                              \\\n+            LogError(\"failure allocating page at page_index=%\" PRIu32 \"\", page_index);                                                                                     \\\n+        }                                                                                                                                                                  \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_015: [ If the element at index is already allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/             \\\n+        else if (PAGED_SPARSE_ARRAY_IS_ALLOCATED(PAGED_SPARSE_ARRAY_GET_BITMAP(array->pages[page_index], paged_sparse_array->page_size, T), index_in_page))                \\\n+        {                                                                                                                                                                  \\\n+            LogError(\"Element at index=%\" PRIu32 \" is already allocated\", index);                                                                                          \\\n+        }                                                                                                                                                                  \\\n+        else                                                                                                                                                               \\\n+        {                                                                                                                                                                  \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_016: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall mark the element at index as allocated. ]*/                                     \\\n+            PAGED_SPARSE_ARRAY_SET_ALLOCATED(PAGED_SPARSE_ARRAY_GET_BITMAP(array->pages[page_index], paged_sparse_array->page_size, T), index_in_page);                                                                  \\\n+            array->pages[page_index]->allocated_count++;                                                                                                                   \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_017: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall return a pointer to the element at index. ]*/                                   \\\n+            result = &array->pages[page_index]->items[index_in_page];                                                                                                      \\\n+            goto all_ok;                                                                                                                                                   \\\n+        }                                                                                                                                                                  \\\n+    }                                                                                                                                                                      \\\n+    result = NULL;                                                                                                                                                         \\\n+all_ok:                                                                                                                                                                    \\\n+    return result;                                                                                                                                                         \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DEFINE(C, T)                                                                                                                          \\\n+int PAGED_SPARSE_ARRAY_LL_RELEASE(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint32_t index)                                                                           \\\n+{                                                                                                                                                                           \\\n+    int result;                                                                                                                                                             \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_019: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/                      \\\n+    if (paged_sparse_array == NULL)                                                                                                                                         \\\n+    {                                                                                                                                                                       \\\n+        LogError(\"Invalid arguments: PAGED_SPARSE_ARRAY(\" MU_TOSTRING(T) \") paged_sparse_array=%p\", paged_sparse_array);                                                    \\\n+        result = MU_FAILURE;                                                                                                                                                \\\n+    }                                                                                                                                                                       \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_020: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/      \\\n+    else if (index >= paged_sparse_array->max_size)                                                                                                                         \\\n+    {                                                                                                                                                                       \\\n+        LogError(\"Invalid arguments: uint32_t index=%\" PRIu32 \" out of bound, max_size=%\" PRIu32 \"\", index, paged_sparse_array->max_size);                                  \\\n+        result = MU_FAILURE;                                                                                                                                                \\\n+    }                                                                                                                                                                       \\\n+    else                                                                                                                                                                    \\\n+    {                                                                                                                                                                       \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_021: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall compute the page index as index / page_size. ]*/                                      \\\n+        uint32_t page_index = index / paged_sparse_array->page_size;                                                                                                        \\\n+        uint32_t index_in_page = index % paged_sparse_array->page_size;                                                                                                     \\\n+        PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* array = THANDLE_GET_T(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(paged_sparse_array);                                                  \\\n+                                                                                                                                                                            \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_022: [ If the page is not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/                   \\\n+        if (array->pages[page_index] == NULL)                                                                                                                               \\\n+        {                                                                                                                                                                   \\\n+            LogError(\"Page at page_index=%\" PRIu32 \" is not allocated\", page_index);                                                                                        \\\n+            result = MU_FAILURE;                                                                                                                                            \\\n+        }                                                                                                                                                                   \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_023: [ If the element at index is not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/       \\\n+        else if (!PAGED_SPARSE_ARRAY_IS_ALLOCATED(PAGED_SPARSE_ARRAY_GET_BITMAP(array->pages[page_index], paged_sparse_array->page_size, T), index_in_page))                \\\n+        {                                                                                                                                                                   \\\n+            LogError(\"Element at index=%\" PRIu32 \" is not allocated\", index);                                                                                               \\\n+            result = MU_FAILURE;                                                                                                                                            \\\n+        }                                                                                                                                                                   \\\n+        else                                                                                                                                                                \\\n+        {                                                                                                                                                                   \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_024: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall mark the element at index as not allocated. ]*/                                   \\\n+            PAGED_SPARSE_ARRAY_CLEAR_ALLOCATED(PAGED_SPARSE_ARRAY_GET_BITMAP(array->pages[page_index], paged_sparse_array->page_size, T), index_in_page);                   \\\n+            array->pages[page_index]->allocated_count--;                                                                                                                    \\\n+                                                                                                                                                                            \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_025: [ If all elements in the page are now not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall free the page and set the page pointer to NULL. ]*/ \\\n+            if (array->pages[page_index]->allocated_count == 0)                                                                                                             \\\n+            {                                                                                                                                                               \\\n+                /* bitmap is embedded in same allocation as page, so only one free needed */                                                                               \\\n+                free((void*)array->pages[page_index]);                                                                                                                      \\\n+                array->pages[page_index] = NULL;                                                                                                                            \\\n+            }                                                                                                                                                               \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_026: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall return zero on success. ]*/                                                       \\\n+            result = 0;                                                                                                                                                     \\\n+        }                                                                                                                                                                   \\\n+    }                                                                                                                                                                       \\\n+    return result;                                                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DEFINE(C, T)                                                                                                                 \\\n+T* PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint32_t index)                                                                   \\\n+{                                                                                                                                                                          \\\n+    T* result;                                                                                                                                                             \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_027: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/                         \\\n+    if (paged_sparse_array == NULL)                                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: PAGED_SPARSE_ARRAY(\" MU_TOSTRING(T) \") paged_sparse_array=%p\", paged_sparse_array);                                                   \\\n+    }                                                                                                                                                                      \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_028: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/         \\\n+    else if (index >= paged_sparse_array->max_size)                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: uint32_t index=%\" PRIu32 \" out of bound, max_size=%\" PRIu32 \"\", index, paged_sparse_array->max_size);                                 \\\n+    }                                                                                                                                                                      \\\n+    else                                                                                                                                                                   \\\n+    {                                                                                                                                                                      \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_029: [ PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall compute the page index as index / page_size. ]*/                             \\\n+        uint32_t page_index = index / paged_sparse_array->page_size;                                                                                                       \\\n+        uint32_t index_in_page = index % paged_sparse_array->page_size;                                                                                                    \\\n+        PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* array = THANDLE_GET_T(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(paged_sparse_array);                                                 \\\n+                                                                                                                                                                           \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_030: [ If the page is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall allocate memory for the page containing page_size elements and an allocation bitmap, and initialize all elements as not allocated. ]*/ \\\n+        if (                                                                                                                                                               \\\n+            (array->pages[page_index] == NULL) &&                                                                                                                          \\\n+            ((array->pages[page_index] = PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(paged_sparse_array->page_size)) == NULL)                                     \\\n+            )                                                                                                                                                              \\\n+        {                                                                                                                                                                  \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_033: [ If there are any errors, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall fail and return NULL. ]*/                       \\\n+            LogError(\"failure allocating page at page_index=%\" PRIu32 \"\", page_index);                                                                                     \\\n+        }                                                                                                                                                                  \\\n+        else                                                                                                                                                               \\\n+        {                                                                                                                                                                  \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_031: [ If the element at index is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T) shall mark it as allocated. ]*/      \\\n+            if (!PAGED_SPARSE_ARRAY_IS_ALLOCATED(PAGED_SPARSE_ARRAY_GET_BITMAP(array->pages[page_index], paged_sparse_array->page_size, T), index_in_page))                \\\n+            {                                                                                                                                                              \\\n+                PAGED_SPARSE_ARRAY_SET_ALLOCATED(PAGED_SPARSE_ARRAY_GET_BITMAP(array->pages[page_index], paged_sparse_array->page_size, T), index_in_page);                \\","path":"inc/c_util/paged_sparse_array_ll.h","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"errr... this is the function I am talking about: \r\n\r\n[https://learn.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-_interlockedbittestandset](https://learn.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-_interlockedbittestandset)","created_at":"2026-01-12T14:29:47Z","updated_at":"2026-01-12T14:29:47Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682522359","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682522359"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682522359"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682522359/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":359,"original_line":359,"side":"RIGHT","in_reply_to_id":2682520189,"author_association":"MEMBER","original_position":359,"position":359,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682525583","pull_request_review_id":3651060535,"id":2682525583,"node_id":"PRRC_kwDODaUZTc6f5BeP","diff_hunk":"@@ -0,0 +1,414 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#ifndef PAGED_SPARSE_ARRAY_LL_H\n+#define PAGED_SPARSE_ARRAY_LL_H\n+\n+#ifdef __cplusplus\n+#include <cinttypes>\n+#include <cstdlib>\n+#else // __cplusplus\n+#include <inttypes.h>\n+#include <stdlib.h>\n+#endif // __cplusplus\n+\n+#include \"c_pal/gballoc_hl.h\"\n+#include \"c_pal/gballoc_hl_redirect.h\"\n+\n+#include \"macro_utils/macro_utils.h\"\n+\n+#include \"c_logging/logger.h\"\n+\n+#include \"c_pal/thandle_ll.h\"\n+\n+#include \"umock_c/umock_c_prod.h\"\n+\n+/*PAGED_SPARSE_ARRAY is backed by a THANDLE build on the structure below*/\n+#define PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T), _TAG)\n+\n+#define PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_STRUCT_, T)\n+\n+/*PAGE_STRUCT holds a single page with elements and allocation bitmap*/\n+#define PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T), _TAG)\n+#define PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_STRUCT_, T)\n+\n+/*PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) introduces the base type that holds the paged sparse array*/\n+#define PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(T)                                                                        \\\n+/*define the page structure first - bitmap is embedded after items[] in the same allocation*/                          \\\n+typedef struct PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T)                                                          \\\n+{                                                                                                                       \\\n+    uint32_t allocated_count;                                                                                           \\\n+    T items[];  /*followed by bitmap bytes at offset page_size * sizeof(T)*/                                            \\\n+} PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T);                                                                              \\\n+/*forward define the typedef of the PAGED_SPARSE_ARRAY struct so that it can be used for a function pointer definition*/\\\n+typedef struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T);                           \\\n+struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T)                                                                       \\\n+{                                                                                                                       \\\n+    uint32_t max_size;                                                                                                  \\\n+    uint32_t page_size;                                                                                                 \\\n+    uint32_t page_count;                                                                                                \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* pages[];                                                                   \\\n+};                                                                                                                      \\\n+\n+/*PAGED_SPARSE_ARRAY is-a THANDLE*/\n+/*given a type \"T\" PAGED_SPARSE_ARRAY_LL(T) expands to the name of the type. */\n+#define PAGED_SPARSE_ARRAY_LL(T) THANDLE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*because PAGED_SPARSE_ARRAY is a THANDLE, all THANDLE's macro APIs are useable with PAGED_SPARSE_ARRAY.*/\n+/*the below are just shortcuts of THANDLE's public ones*/\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE(T) THANDLE_INITIALIZE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_ASSIGN(T) THANDLE_ASSIGN(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_MOVE(T) THANDLE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE_MOVE(T) THANDLE_INITIALIZE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*introduces a new name for a function that returns a PAGED_SPARSE_ARRAY_LL(T)*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_CREATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_CREATE(C) PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C)\n+\n+/*introduces a name for the function that frees a PAGED_SPARSE_ARRAY when its ref count goes to 0*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_FREE_, C)\n+\n+/*introduces a name for the allocate function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C)\n+\n+/*introduces a name for the release function*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_RELEASE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE(C) PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C)\n+\n+/*introduces a name for the allocate_or_get function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C)\n+\n+/*introduces a name for the get function*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_GET(C) PAGED_SPARSE_ARRAY_LL_GET_NAME(C)\n+\n+/*introduces a function declaration for paged_sparse_array_create*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, PAGED_SPARSE_ARRAY_LL(T), PAGED_SPARSE_ARRAY_LL_CREATE(C), uint32_t, max_size, uint32_t, page_size);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_release*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, int, PAGED_SPARSE_ARRAY_LL_RELEASE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate_or_get*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_get*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*helper to compute bitmap size in bytes (1 bit per element, rounded up to nearest byte)*/\n+#define PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size) (((page_size) + 7) / 8)\n+\n+/*helper to get the allocation bitmap from a page - bitmap is stored after items[] in the same allocation*/\n+#define PAGED_SPARSE_ARRAY_GET_BITMAP(page, page_size, T) ((uint8_t*)((page)->items + (page_size)))\n+\n+/*helper to check if an element is allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_IS_ALLOCATED(bitmap, index_in_page) \\\n+    (((bitmap)[(index_in_page) / 8] & (1 << ((index_in_page) % 8))) != 0)\n+\n+/*helper to set an element as allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_SET_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] |= (1 << ((index_in_page) % 8)))\n+\n+/*helper to clear an element as not allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_CLEAR_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] &= ~(1 << ((index_in_page) % 8)))\n+\n+/*introduces a function definition for freeing the allocated resources for a PAGED_SPARSE_ARRAY*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_DEFINE(C, T)                                                                                \\\n+static void PAGED_SPARSE_ARRAY_LL_FREE_NAME(C)(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* paged_sparse_array)                         \\\n+{                                                                                                                              \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_009: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_FREE(T) shall return. ]*/      \\\n+    if (paged_sparse_array == NULL)                                                                                            \\\n+    {                                                                                                                          \\\n+        LogError(\"invalid arguments \" MU_TOSTRING(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)) \"* paged_sparse_array=%p\",               \\\n+            paged_sparse_array);                                                                                               \\\n+    }                                                                                                                          \\\n+    else                                                                                                                       \\\n+    {                                                                                                                          \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_010: [ PAGED_SPARSE_ARRAY_FREE(T) shall free all pages that are non-NULL. ]*/       \\\n+        for (uint32_t i = 0; i < paged_sparse_array->page_count; i++)                                                          \\\n+        {                                                                                                                      \\\n+            if (paged_sparse_array->pages[i] != NULL)                                                                          \\\n+            {                                                                                                                  \\\n+                /* bitmap is embedded in same allocation as page, so only one free needed */                                  \\\n+                free((void*)paged_sparse_array->pages[i]);                                                                     \\\n+            }                                                                                                                  \\\n+        }                                                                                                                      \\\n+    }                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DEFINE(C, T)                                                                                                                         \\\n+PAGED_SPARSE_ARRAY_LL(T) PAGED_SPARSE_ARRAY_LL_CREATE(C)(uint32_t max_size, uint32_t page_size)                                                                           \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* result;                                                                                                                           \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_001: [ If max_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                           \\\n+    if (max_size == 0)                                                                                                                                                    \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t max_size=%\" PRIu32 \"\", max_size);                                                                                           \\\n+    }                                                                                                                                                                     \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_002: [ If page_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                          \\\n+    else if (page_size == 0)                                                                                                                                              \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t page_size=%\" PRIu32 \"\", page_size);                                                                                         \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_003: [ PAGED_SPARSE_ARRAY_CREATE(T) shall compute the number of pages as (max_size + page_size - 1) / page_size. ]*/           \\\n+        uint32_t page_count = (max_size + page_size - 1) / page_size;                                                                                                     \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_004: [ PAGED_SPARSE_ARRAY_CREATE(T) shall call THANDLE_MALLOC_FLEX to allocate memory for the paged sparse array with the number of pages. ]*/ \\\n+        result = THANDLE_MALLOC_FLEX(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(PAGED_SPARSE_ARRAY_LL_FREE_NAME(C), page_count, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)*)); \\\n+        if (result == NULL)                                                                                                                                               \\\n+        {                                                                                                                                                                 \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_007: [ If there are any errors, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                               \\\n+            LogError(\"failure in THANDLE_MALLOC_FLEX page_count=%\" PRIu32 \", sizeof(PAGED_SPARSE_ARRAY_PAGE*)=%zu\", page_count, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)*)); \\\n+        }                                                                                                                                                                 \\\n+        else                                                                                                                                                              \\\n+        {                                                                                                                                                                 \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_006: [ PAGED_SPARSE_ARRAY_CREATE(T) shall store max_size and page_size in the structure. ]*/                               \\\n+            result->max_size = max_size;                                                                                                                                  \\\n+            result->page_size = page_size;                                                                                                                                \\\n+            result->page_count = page_count;                                                                                                                              \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_005: [ PAGED_SPARSE_ARRAY_CREATE(T) shall set all page pointers to NULL. ]*/                                               \\\n+            for (uint32_t i = 0; i < page_count; i++)                                                                                                                     \\\n+            {                                                                                                                                                             \\\n+                result->pages[i] = NULL;                                                                                                                                  \\\n+            }                                                                                                                                                             \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_008: [ PAGED_SPARSE_ARRAY_CREATE(T) shall succeed and return a non-NULL value. ]*/                                         \\\n+            goto all_ok;                                                                                                                                                  \\\n+        }                                                                                                                                                                 \\\n+    }                                                                                                                                                                     \\\n+    result = NULL;                                                                                                                                                        \\\n+all_ok:                                                                                                                                                                   \\\n+    return result;                                                                                                                                                        \\\n+}\n+\n+/*internal helper to allocate a page*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_, C)\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_DEFINE(C, T)                                                                                                         \\\n+static PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(uint32_t page_size)                                                  \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* page;                                                                                                                        \\\n+    /* Allocate page struct + items array + bitmap in a single allocation */                                                                                             \\\n+    size_t bitmap_size = PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size);                                                                                                       \\\n+    size_t items_and_bitmap_size = (size_t)page_size * sizeof(T) + bitmap_size;                                                                                           \\\n+    page = malloc_flex(sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)), items_and_bitmap_size, 1);                                                                        \\\n+    if (page == NULL)                                                                                                                                                     \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"failure in malloc_flex for page, page_size=%\" PRIu32 \", sizeof(\" MU_TOSTRING(T) \")=%zu, bitmap_size=%zu\", page_size, sizeof(T), bitmap_size);          \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        /* Initialize bitmap to all zeros (nothing allocated) - bitmap is at end of items array */                                                                       \\\n+        uint8_t* bitmap = PAGED_SPARSE_ARRAY_GET_BITMAP(page, page_size, T);                                                                                              \\\n+        (void)memset(bitmap, 0, bitmap_size);                                                                                                                             \\\n+        page->allocated_count = 0;                                                                                                                                        \\\n+    }                                                                                                                                                                     \\\n+    return page;                                                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DEFINE(C, T)                                                                                                                        \\\n+T* PAGED_SPARSE_ARRAY_LL_ALLOCATE(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint32_t index)                                                                          \\\n+{                                                                                                                                                                          \\\n+    T* result;                                                                                                                                                             \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_011: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                                \\\n+    if (paged_sparse_array == NULL)                                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: PAGED_SPARSE_ARRAY(\" MU_TOSTRING(T) \") paged_sparse_array=%p\", paged_sparse_array);                                                   \\\n+    }                                                                                                                                                                      \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_012: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                \\\n+    else if (index >= paged_sparse_array->max_size)                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: uint32_t index=%\" PRIu32 \" out of bound, max_size=%\" PRIu32 \"\", index, paged_sparse_array->max_size);                                 \\\n+    }                                                                                                                                                                      \\\n+    else                                                                                                                                                                   \\\n+    {                                                                                                                                                                      \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_013: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall compute the page index as index / page_size. ]*/                                    \\\n+        uint32_t page_index = index / paged_sparse_array->page_size;                                                                                                       \\\n+        uint32_t index_in_page = index % paged_sparse_array->page_size;                                                                                                    \\","path":"inc/c_util/paged_sparse_array_ll.h","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"seems like a here and everywhere comment...","created_at":"2026-01-12T14:30:34Z","updated_at":"2026-01-12T14:30:34Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682525583","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682525583"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682525583"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682525583/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":237,"original_line":237,"side":"RIGHT","in_reply_to_id":2682470436,"author_association":"MEMBER","original_position":237,"position":237,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682532355","pull_request_review_id":3651068853,"id":2682532355,"node_id":"PRRC_kwDODaUZTc6f5DID","diff_hunk":"@@ -0,0 +1,414 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#ifndef PAGED_SPARSE_ARRAY_LL_H\n+#define PAGED_SPARSE_ARRAY_LL_H\n+\n+#ifdef __cplusplus\n+#include <cinttypes>\n+#include <cstdlib>\n+#else // __cplusplus\n+#include <inttypes.h>\n+#include <stdlib.h>\n+#endif // __cplusplus\n+\n+#include \"c_pal/gballoc_hl.h\"\n+#include \"c_pal/gballoc_hl_redirect.h\"\n+\n+#include \"macro_utils/macro_utils.h\"\n+\n+#include \"c_logging/logger.h\"\n+\n+#include \"c_pal/thandle_ll.h\"\n+\n+#include \"umock_c/umock_c_prod.h\"\n+\n+/*PAGED_SPARSE_ARRAY is backed by a THANDLE build on the structure below*/\n+#define PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T), _TAG)\n+\n+#define PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_STRUCT_, T)\n+\n+/*PAGE_STRUCT holds a single page with elements and allocation bitmap*/\n+#define PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T), _TAG)\n+#define PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T) MU_C2(PAGED_SPARSE_ARRAY_PAGE_STRUCT_, T)\n+\n+/*PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T) introduces the base type that holds the paged sparse array*/\n+#define PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(T)                                                                        \\\n+/*define the page structure first - bitmap is embedded after items[] in the same allocation*/                          \\\n+typedef struct PAGED_SPARSE_ARRAY_PAGE_STRUCT_TYPE_NAME_TAG(T)                                                          \\\n+{                                                                                                                       \\\n+    uint32_t allocated_count;                                                                                           \\\n+    T items[];  /*followed by bitmap bytes at offset page_size * sizeof(T)*/                                            \\\n+} PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T);                                                                              \\\n+/*forward define the typedef of the PAGED_SPARSE_ARRAY struct so that it can be used for a function pointer definition*/\\\n+typedef struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T) PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T);                           \\\n+struct PAGED_SPARSE_ARRAY_STRUCT_TYPE_NAME_TAG(T)                                                                       \\\n+{                                                                                                                       \\\n+    uint32_t max_size;                                                                                                  \\\n+    uint32_t page_size;                                                                                                 \\\n+    uint32_t page_count;                                                                                                \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* pages[];                                                                   \\\n+};                                                                                                                      \\\n+\n+/*PAGED_SPARSE_ARRAY is-a THANDLE*/\n+/*given a type \"T\" PAGED_SPARSE_ARRAY_LL(T) expands to the name of the type. */\n+#define PAGED_SPARSE_ARRAY_LL(T) THANDLE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*because PAGED_SPARSE_ARRAY is a THANDLE, all THANDLE's macro APIs are useable with PAGED_SPARSE_ARRAY.*/\n+/*the below are just shortcuts of THANDLE's public ones*/\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE(T) THANDLE_INITIALIZE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_ASSIGN(T) THANDLE_ASSIGN(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_MOVE(T) THANDLE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+#define PAGED_SPARSE_ARRAY_LL_INITIALIZE_MOVE(T) THANDLE_INITIALIZE_MOVE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T))\n+\n+/*introduces a new name for a function that returns a PAGED_SPARSE_ARRAY_LL(T)*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_CREATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_CREATE(C) PAGED_SPARSE_ARRAY_LL_CREATE_NAME(C)\n+\n+/*introduces a name for the function that frees a PAGED_SPARSE_ARRAY when its ref count goes to 0*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_FREE_, C)\n+\n+/*introduces a name for the allocate function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_NAME(C)\n+\n+/*introduces a name for the release function*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_RELEASE_, C)\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE(C) PAGED_SPARSE_ARRAY_LL_RELEASE_NAME(C)\n+\n+/*introduces a name for the allocate_or_get function*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C) PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_NAME(C)\n+\n+/*introduces a name for the get function*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_GET_, C)\n+#define PAGED_SPARSE_ARRAY_LL_GET(C) PAGED_SPARSE_ARRAY_LL_GET_NAME(C)\n+\n+/*introduces a function declaration for paged_sparse_array_create*/\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, PAGED_SPARSE_ARRAY_LL(T), PAGED_SPARSE_ARRAY_LL_CREATE(C), uint32_t, max_size, uint32_t, page_size);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_release*/\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, int, PAGED_SPARSE_ARRAY_LL_RELEASE(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_allocate_or_get*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*introduces a function declaration for paged_sparse_array_get*/\n+#define PAGED_SPARSE_ARRAY_LL_GET_DECLARE(C, T) \\\n+    MOCKABLE_FUNCTION(, T*, PAGED_SPARSE_ARRAY_LL_GET(C), PAGED_SPARSE_ARRAY_LL(T), paged_sparse_array, uint32_t, index);\n+\n+/*helper to compute bitmap size in bytes (1 bit per element, rounded up to nearest byte)*/\n+#define PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size) (((page_size) + 7) / 8)\n+\n+/*helper to get the allocation bitmap from a page - bitmap is stored after items[] in the same allocation*/\n+#define PAGED_SPARSE_ARRAY_GET_BITMAP(page, page_size, T) ((uint8_t*)((page)->items + (page_size)))\n+\n+/*helper to check if an element is allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_IS_ALLOCATED(bitmap, index_in_page) \\\n+    (((bitmap)[(index_in_page) / 8] & (1 << ((index_in_page) % 8))) != 0)\n+\n+/*helper to set an element as allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_SET_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] |= (1 << ((index_in_page) % 8)))\n+\n+/*helper to clear an element as not allocated in the bitmap*/\n+#define PAGED_SPARSE_ARRAY_CLEAR_ALLOCATED(bitmap, index_in_page) \\\n+    ((bitmap)[(index_in_page) / 8] &= ~(1 << ((index_in_page) % 8)))\n+\n+/*introduces a function definition for freeing the allocated resources for a PAGED_SPARSE_ARRAY*/\n+#define PAGED_SPARSE_ARRAY_LL_FREE_DEFINE(C, T)                                                                                \\\n+static void PAGED_SPARSE_ARRAY_LL_FREE_NAME(C)(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* paged_sparse_array)                         \\\n+{                                                                                                                              \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_009: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_FREE(T) shall return. ]*/      \\\n+    if (paged_sparse_array == NULL)                                                                                            \\\n+    {                                                                                                                          \\\n+        LogError(\"invalid arguments \" MU_TOSTRING(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)) \"* paged_sparse_array=%p\",               \\\n+            paged_sparse_array);                                                                                               \\\n+    }                                                                                                                          \\\n+    else                                                                                                                       \\\n+    {                                                                                                                          \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_010: [ PAGED_SPARSE_ARRAY_FREE(T) shall free all pages that are non-NULL. ]*/       \\\n+        for (uint32_t i = 0; i < paged_sparse_array->page_count; i++)                                                          \\\n+        {                                                                                                                      \\\n+            if (paged_sparse_array->pages[i] != NULL)                                                                          \\\n+            {                                                                                                                  \\\n+                /* bitmap is embedded in same allocation as page, so only one free needed */                                  \\\n+                free((void*)paged_sparse_array->pages[i]);                                                                     \\\n+            }                                                                                                                  \\\n+        }                                                                                                                      \\\n+    }                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_CREATE_DEFINE(C, T)                                                                                                                         \\\n+PAGED_SPARSE_ARRAY_LL(T) PAGED_SPARSE_ARRAY_LL_CREATE(C)(uint32_t max_size, uint32_t page_size)                                                                           \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* result;                                                                                                                           \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_001: [ If max_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                           \\\n+    if (max_size == 0)                                                                                                                                                    \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t max_size=%\" PRIu32 \"\", max_size);                                                                                           \\\n+    }                                                                                                                                                                     \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_002: [ If page_size is zero, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                                          \\\n+    else if (page_size == 0)                                                                                                                                              \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"Invalid arguments: uint32_t page_size=%\" PRIu32 \"\", page_size);                                                                                         \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_003: [ PAGED_SPARSE_ARRAY_CREATE(T) shall compute the number of pages as (max_size + page_size - 1) / page_size. ]*/           \\\n+        uint32_t page_count = (max_size + page_size - 1) / page_size;                                                                                                     \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_004: [ PAGED_SPARSE_ARRAY_CREATE(T) shall call THANDLE_MALLOC_FLEX to allocate memory for the paged sparse array with the number of pages. ]*/ \\\n+        result = THANDLE_MALLOC_FLEX(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(PAGED_SPARSE_ARRAY_LL_FREE_NAME(C), page_count, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)*)); \\\n+        if (result == NULL)                                                                                                                                               \\\n+        {                                                                                                                                                                 \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_007: [ If there are any errors, PAGED_SPARSE_ARRAY_CREATE(T) shall fail and return NULL. ]*/                               \\\n+            LogError(\"failure in THANDLE_MALLOC_FLEX page_count=%\" PRIu32 \", sizeof(PAGED_SPARSE_ARRAY_PAGE*)=%zu\", page_count, sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)*)); \\\n+        }                                                                                                                                                                 \\\n+        else                                                                                                                                                              \\\n+        {                                                                                                                                                                 \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_006: [ PAGED_SPARSE_ARRAY_CREATE(T) shall store max_size and page_size in the structure. ]*/                               \\\n+            result->max_size = max_size;                                                                                                                                  \\\n+            result->page_size = page_size;                                                                                                                                \\\n+            result->page_count = page_count;                                                                                                                              \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_005: [ PAGED_SPARSE_ARRAY_CREATE(T) shall set all page pointers to NULL. ]*/                                               \\\n+            for (uint32_t i = 0; i < page_count; i++)                                                                                                                     \\\n+            {                                                                                                                                                             \\\n+                result->pages[i] = NULL;                                                                                                                                  \\\n+            }                                                                                                                                                             \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_008: [ PAGED_SPARSE_ARRAY_CREATE(T) shall succeed and return a non-NULL value. ]*/                                         \\\n+            goto all_ok;                                                                                                                                                  \\\n+        }                                                                                                                                                                 \\\n+    }                                                                                                                                                                     \\\n+    result = NULL;                                                                                                                                                        \\\n+all_ok:                                                                                                                                                                   \\\n+    return result;                                                                                                                                                        \\\n+}\n+\n+/*internal helper to allocate a page*/\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C) MU_C2(PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_, C)\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_DEFINE(C, T)                                                                                                         \\\n+static PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(uint32_t page_size)                                                  \\\n+{                                                                                                                                                                         \\\n+    PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)* page;                                                                                                                        \\\n+    /* Allocate page struct + items array + bitmap in a single allocation */                                                                                             \\\n+    size_t bitmap_size = PAGED_SPARSE_ARRAY_BITMAP_SIZE(page_size);                                                                                                       \\\n+    size_t items_and_bitmap_size = (size_t)page_size * sizeof(T) + bitmap_size;                                                                                           \\\n+    page = malloc_flex(sizeof(PAGED_SPARSE_ARRAY_PAGE_TYPEDEF_NAME(T)), items_and_bitmap_size, 1);                                                                        \\\n+    if (page == NULL)                                                                                                                                                     \\\n+    {                                                                                                                                                                     \\\n+        LogError(\"failure in malloc_flex for page, page_size=%\" PRIu32 \", sizeof(\" MU_TOSTRING(T) \")=%zu, bitmap_size=%zu\", page_size, sizeof(T), bitmap_size);          \\\n+    }                                                                                                                                                                     \\\n+    else                                                                                                                                                                  \\\n+    {                                                                                                                                                                     \\\n+        /* Initialize bitmap to all zeros (nothing allocated) - bitmap is at end of items array */                                                                       \\\n+        uint8_t* bitmap = PAGED_SPARSE_ARRAY_GET_BITMAP(page, page_size, T);                                                                                              \\\n+        (void)memset(bitmap, 0, bitmap_size);                                                                                                                             \\\n+        page->allocated_count = 0;                                                                                                                                        \\\n+    }                                                                                                                                                                     \\\n+    return page;                                                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_DEFINE(C, T)                                                                                                                        \\\n+T* PAGED_SPARSE_ARRAY_LL_ALLOCATE(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint32_t index)                                                                          \\\n+{                                                                                                                                                                          \\\n+    T* result;                                                                                                                                                             \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_011: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                                \\\n+    if (paged_sparse_array == NULL)                                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: PAGED_SPARSE_ARRAY(\" MU_TOSTRING(T) \") paged_sparse_array=%p\", paged_sparse_array);                                                   \\\n+    }                                                                                                                                                                      \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_012: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                \\\n+    else if (index >= paged_sparse_array->max_size)                                                                                                                        \\\n+    {                                                                                                                                                                      \\\n+        LogError(\"Invalid arguments: uint32_t index=%\" PRIu32 \" out of bound, max_size=%\" PRIu32 \"\", index, paged_sparse_array->max_size);                                 \\\n+    }                                                                                                                                                                      \\\n+    else                                                                                                                                                                   \\\n+    {                                                                                                                                                                      \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_013: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall compute the page index as index / page_size. ]*/                                    \\\n+        uint32_t page_index = index / paged_sparse_array->page_size;                                                                                                       \\\n+        uint32_t index_in_page = index % paged_sparse_array->page_size;                                                                                                    \\\n+        PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* array = THANDLE_GET_T(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(paged_sparse_array);                                                 \\\n+                                                                                                                                                                           \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_014: [ If the page is not allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall allocate memory for the page containing page_size elements and an allocation bitmap, and initialize all elements as not allocated. ]*/ \\\n+        if (                                                                                                                                                               \\\n+            (array->pages[page_index] == NULL) &&                                                                                                                          \\\n+            ((array->pages[page_index] = PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(paged_sparse_array->page_size)) == NULL)                                     \\\n+            )                                                                                                                                                              \\\n+        {                                                                                                                                                                  \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_018: [ If there are any errors, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/                              \\\n+            LogError(\"failure allocating page at page_index=%\" PRIu32 \"\", page_index);                                                                                     \\\n+        }                                                                                                                                                                  \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_015: [ If the element at index is already allocated, PAGED_SPARSE_ARRAY_ALLOCATE(T) shall fail and return NULL. ]*/             \\\n+        else if (PAGED_SPARSE_ARRAY_IS_ALLOCATED(PAGED_SPARSE_ARRAY_GET_BITMAP(array->pages[page_index], paged_sparse_array->page_size, T), index_in_page))                \\\n+        {                                                                                                                                                                  \\\n+            LogError(\"Element at index=%\" PRIu32 \" is already allocated\", index);                                                                                          \\\n+        }                                                                                                                                                                  \\\n+        else                                                                                                                                                               \\\n+        {                                                                                                                                                                  \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_016: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall mark the element at index as allocated. ]*/                                     \\\n+            PAGED_SPARSE_ARRAY_SET_ALLOCATED(PAGED_SPARSE_ARRAY_GET_BITMAP(array->pages[page_index], paged_sparse_array->page_size, T), index_in_page);                                                                  \\\n+            array->pages[page_index]->allocated_count++;                                                                                                                   \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_017: [ PAGED_SPARSE_ARRAY_ALLOCATE(T) shall return a pointer to the element at index. ]*/                                   \\\n+            result = &array->pages[page_index]->items[index_in_page];                                                                                                      \\\n+            goto all_ok;                                                                                                                                                   \\\n+        }                                                                                                                                                                  \\\n+    }                                                                                                                                                                      \\\n+    result = NULL;                                                                                                                                                         \\\n+all_ok:                                                                                                                                                                    \\\n+    return result;                                                                                                                                                         \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_RELEASE_DEFINE(C, T)                                                                                                                          \\\n+int PAGED_SPARSE_ARRAY_LL_RELEASE(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint32_t index)                                                                           \\\n+{                                                                                                                                                                           \\\n+    int result;                                                                                                                                                             \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_019: [ If paged_sparse_array is NULL, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/                      \\\n+    if (paged_sparse_array == NULL)                                                                                                                                         \\\n+    {                                                                                                                                                                       \\\n+        LogError(\"Invalid arguments: PAGED_SPARSE_ARRAY(\" MU_TOSTRING(T) \") paged_sparse_array=%p\", paged_sparse_array);                                                    \\\n+        result = MU_FAILURE;                                                                                                                                                \\\n+    }                                                                                                                                                                       \\\n+    /* Codes_SRS_PAGED_SPARSE_ARRAY_88_020: [ If index is greater than or equal to max_size, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/      \\\n+    else if (index >= paged_sparse_array->max_size)                                                                                                                         \\\n+    {                                                                                                                                                                       \\\n+        LogError(\"Invalid arguments: uint32_t index=%\" PRIu32 \" out of bound, max_size=%\" PRIu32 \"\", index, paged_sparse_array->max_size);                                  \\\n+        result = MU_FAILURE;                                                                                                                                                \\\n+    }                                                                                                                                                                       \\\n+    else                                                                                                                                                                    \\\n+    {                                                                                                                                                                       \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_021: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall compute the page index as index / page_size. ]*/                                      \\\n+        uint32_t page_index = index / paged_sparse_array->page_size;                                                                                                        \\\n+        uint32_t index_in_page = index % paged_sparse_array->page_size;                                                                                                     \\\n+        PAGED_SPARSE_ARRAY_TYPEDEF_NAME(T)* array = THANDLE_GET_T(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(C))(paged_sparse_array);                                                  \\\n+                                                                                                                                                                            \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_022: [ If the page is not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/                   \\\n+        if (array->pages[page_index] == NULL)                                                                                                                               \\\n+        {                                                                                                                                                                   \\\n+            LogError(\"Page at page_index=%\" PRIu32 \" is not allocated\", page_index);                                                                                        \\\n+            result = MU_FAILURE;                                                                                                                                            \\\n+        }                                                                                                                                                                   \\\n+        /* Codes_SRS_PAGED_SPARSE_ARRAY_88_023: [ If the element at index is not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall fail and return a non-zero value. ]*/       \\\n+        else if (!PAGED_SPARSE_ARRAY_IS_ALLOCATED(PAGED_SPARSE_ARRAY_GET_BITMAP(array->pages[page_index], paged_sparse_array->page_size, T), index_in_page))                \\\n+        {                                                                                                                                                                   \\\n+            LogError(\"Element at index=%\" PRIu32 \" is not allocated\", index);                                                                                               \\\n+            result = MU_FAILURE;                                                                                                                                            \\\n+        }                                                                                                                                                                   \\\n+        else                                                                                                                                                                \\\n+        {                                                                                                                                                                   \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_024: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall mark the element at index as not allocated. ]*/                                   \\\n+            PAGED_SPARSE_ARRAY_CLEAR_ALLOCATED(PAGED_SPARSE_ARRAY_GET_BITMAP(array->pages[page_index], paged_sparse_array->page_size, T), index_in_page);                   \\\n+            array->pages[page_index]->allocated_count--;                                                                                                                    \\\n+                                                                                                                                                                            \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_025: [ If all elements in the page are now not allocated, PAGED_SPARSE_ARRAY_RELEASE(T) shall free the page and set the page pointer to NULL. ]*/ \\\n+            if (array->pages[page_index]->allocated_count == 0)                                                                                                             \\\n+            {                                                                                                                                                               \\\n+                /* bitmap is embedded in same allocation as page, so only one free needed */                                                                               \\\n+                free((void*)array->pages[page_index]);                                                                                                                      \\\n+                array->pages[page_index] = NULL;                                                                                                                            \\\n+            }                                                                                                                                                               \\\n+            /* Codes_SRS_PAGED_SPARSE_ARRAY_88_026: [ PAGED_SPARSE_ARRAY_RELEASE(T) shall return zero on success. ]*/                                                       \\\n+            result = 0;                                                                                                                                                     \\\n+        }                                                                                                                                                                   \\\n+    }                                                                                                                                                                       \\\n+    return result;                                                                                                                                                          \\\n+}\n+\n+#define PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET_DEFINE(C, T)                                                                                                                 \\\n+T* PAGED_SPARSE_ARRAY_LL_ALLOCATE_OR_GET(C)(PAGED_SPARSE_ARRAY_LL(T) paged_sparse_array, uint32_t index)                                                                   \\","path":"inc/c_util/paged_sparse_array_ll.h","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":">ALLOCATE_OR_GET [](http://example.com/codeflow?start=25&length=15)\r\n\r\nI still maintain that allocate_or_get is weird because it requires extra synchronization with the user.","created_at":"2026-01-12T14:32:13Z","updated_at":"2026-01-12T14:32:14Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682532355","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682532355"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682532355"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682532355/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":325,"original_line":325,"side":"RIGHT","author_association":"MEMBER","original_position":325,"position":325,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682539562","pull_request_review_id":3651077920,"id":2682539562,"node_id":"PRRC_kwDODaUZTc6f5E4q","diff_hunk":"@@ -0,0 +1,367 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#include <stdlib.h>\n+#include <stdbool.h>\n+#include <inttypes.h>\n+#include <time.h>","path":"tests/paged_sparse_array_int/paged_sparse_array_int.c","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"time???","created_at":"2026-01-12T14:34:01Z","updated_at":"2026-01-12T14:34:01Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682539562","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682539562"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682539562"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682539562/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":7,"original_line":7,"side":"RIGHT","author_association":"MEMBER","original_position":7,"position":7,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682541359","pull_request_review_id":3651080215,"id":2682541359,"node_id":"PRRC_kwDODaUZTc6f5FUv","diff_hunk":"@@ -0,0 +1,367 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#include <stdlib.h>\n+#include <stdbool.h>\n+#include <inttypes.h>\n+#include <time.h>","path":"tests/paged_sparse_array_int/paged_sparse_array_int.c","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"oh, now I see why.","created_at":"2026-01-12T14:34:28Z","updated_at":"2026-01-12T14:34:28Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682541359","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682541359"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682541359"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682541359/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":7,"original_line":7,"side":"RIGHT","in_reply_to_id":2682539562,"author_association":"MEMBER","original_position":7,"position":7,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682544261","pull_request_review_id":3651083628,"id":2682544261,"node_id":"PRRC_kwDODaUZTc6f5GCF","diff_hunk":"@@ -0,0 +1,367 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#include <stdlib.h>\n+#include <stdbool.h>\n+#include <inttypes.h>\n+#include <time.h>\n+\n+#include \"macro_utils/macro_utils.h\"\n+#include \"testrunnerswitcher.h\"\n+\n+#include \"c_pal/gballoc_hl.h\"\n+#include \"c_pal/gballoc_hl_redirect.h\"\n+\n+#include \"c_pal/interlocked.h\"\n+#include \"c_pal/thandle.h\"\n+#include \"c_pal/threadapi.h\"\n+\n+#include \"c_util/paged_sparse_array.h\"\n+\n+typedef struct TEST_ELEMENT_TAG\n+{\n+    int64_t value;\n+} TEST_ELEMENT;\n+\n+PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(TEST_ELEMENT);\n+THANDLE_TYPE_DECLARE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(TEST_ELEMENT));\n+THANDLE_TYPE_DEFINE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(TEST_ELEMENT));\n+\n+PAGED_SPARSE_ARRAY_TYPE_DECLARE(TEST_ELEMENT);\n+PAGED_SPARSE_ARRAY_TYPE_DEFINE(TEST_ELEMENT);\n+\n+#define CHAOS_TEST_ACTION_VALUES \\\n+    CHAOS_TEST_ACTION_ALLOCATE, \\\n+    CHAOS_TEST_ACTION_RELEASE, \\\n+    CHAOS_TEST_ACTION_ALLOCATE_OR_GET, \\\n+    CHAOS_TEST_ACTION_GET\n+\n+MU_DEFINE_ENUM(CHAOS_TEST_ACTION, CHAOS_TEST_ACTION_VALUES)\n+MU_DEFINE_ENUM_STRINGS(CHAOS_TEST_ACTION, CHAOS_TEST_ACTION_VALUES)\n+\n+BEGIN_TEST_SUITE(TEST_SUITE_NAME_FROM_CMAKE)\n+\n+TEST_SUITE_INITIALIZE(suite_init)\n+{\n+    time_t seed = time(NULL);\n+    LogInfo(\"Test using random seed=%u\", (unsigned int)seed);\n+    srand((unsigned int)seed);\n+}\n+\n+TEST_SUITE_CLEANUP(suite_cleanup)\n+{\n+}\n+\n+TEST_FUNCTION_INITIALIZE(method_init)\n+{\n+}\n+\n+TEST_FUNCTION_CLEANUP(method_cleanup)\n+{\n+}\n+\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_CREATE_succeeds)\n+{\n+    //arrange\n+\n+    //act\n+    PAGED_SPARSE_ARRAY(TEST_ELEMENT) psa = PAGED_SPARSE_ARRAY_CREATE(TEST_ELEMENT)(1000, 64);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(psa);\n+\n+    //cleanup\n+    PAGED_SPARSE_ARRAY_ASSIGN(TEST_ELEMENT)(&psa, NULL);\n+}\n+\n+#define MAX_SIZE 1000\n+#define PAGE_SIZE 64","path":"tests/paged_sparse_array_int/paged_sparse_array_int.c","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"are these intended to be used by `PAGED_SPARSE_ARRAY_CREATE_succeeds` too?","created_at":"2026-01-12T14:35:04Z","updated_at":"2026-01-12T14:35:04Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682544261","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682544261"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682544261"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682544261/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":78,"original_line":78,"side":"RIGHT","author_association":"MEMBER","original_position":78,"position":78,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682549585","pull_request_review_id":3651090052,"id":2682549585,"node_id":"PRRC_kwDODaUZTc6f5HVR","diff_hunk":"@@ -0,0 +1,367 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#include <stdlib.h>\n+#include <stdbool.h>\n+#include <inttypes.h>\n+#include <time.h>\n+\n+#include \"macro_utils/macro_utils.h\"\n+#include \"testrunnerswitcher.h\"\n+\n+#include \"c_pal/gballoc_hl.h\"\n+#include \"c_pal/gballoc_hl_redirect.h\"\n+\n+#include \"c_pal/interlocked.h\"\n+#include \"c_pal/thandle.h\"\n+#include \"c_pal/threadapi.h\"\n+\n+#include \"c_util/paged_sparse_array.h\"\n+\n+typedef struct TEST_ELEMENT_TAG\n+{\n+    int64_t value;\n+} TEST_ELEMENT;\n+\n+PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(TEST_ELEMENT);\n+THANDLE_TYPE_DECLARE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(TEST_ELEMENT));\n+THANDLE_TYPE_DEFINE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(TEST_ELEMENT));\n+\n+PAGED_SPARSE_ARRAY_TYPE_DECLARE(TEST_ELEMENT);\n+PAGED_SPARSE_ARRAY_TYPE_DEFINE(TEST_ELEMENT);\n+\n+#define CHAOS_TEST_ACTION_VALUES \\\n+    CHAOS_TEST_ACTION_ALLOCATE, \\\n+    CHAOS_TEST_ACTION_RELEASE, \\\n+    CHAOS_TEST_ACTION_ALLOCATE_OR_GET, \\\n+    CHAOS_TEST_ACTION_GET\n+\n+MU_DEFINE_ENUM(CHAOS_TEST_ACTION, CHAOS_TEST_ACTION_VALUES)\n+MU_DEFINE_ENUM_STRINGS(CHAOS_TEST_ACTION, CHAOS_TEST_ACTION_VALUES)\n+\n+BEGIN_TEST_SUITE(TEST_SUITE_NAME_FROM_CMAKE)\n+\n+TEST_SUITE_INITIALIZE(suite_init)\n+{\n+    time_t seed = time(NULL);\n+    LogInfo(\"Test using random seed=%u\", (unsigned int)seed);\n+    srand((unsigned int)seed);\n+}\n+\n+TEST_SUITE_CLEANUP(suite_cleanup)\n+{\n+}\n+\n+TEST_FUNCTION_INITIALIZE(method_init)\n+{\n+}\n+\n+TEST_FUNCTION_CLEANUP(method_cleanup)\n+{\n+}\n+\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_CREATE_succeeds)\n+{\n+    //arrange\n+\n+    //act\n+    PAGED_SPARSE_ARRAY(TEST_ELEMENT) psa = PAGED_SPARSE_ARRAY_CREATE(TEST_ELEMENT)(1000, 64);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(psa);\n+\n+    //cleanup\n+    PAGED_SPARSE_ARRAY_ASSIGN(TEST_ELEMENT)(&psa, NULL);\n+}\n+\n+#define MAX_SIZE 1000\n+#define PAGE_SIZE 64\n+\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_allocate_all_elements_succeeds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(TEST_ELEMENT) psa = PAGED_SPARSE_ARRAY_CREATE(TEST_ELEMENT)(MAX_SIZE, PAGE_SIZE);\n+    ASSERT_IS_NOT_NULL(psa);\n+\n+    //act\n+    for (uint32_t i = 0; i < MAX_SIZE; i++)\n+    {\n+        TEST_ELEMENT* elem = PAGED_SPARSE_ARRAY_ALLOCATE(TEST_ELEMENT)(psa, i);\n+        ASSERT_IS_NOT_NULL(elem);\n+        elem->value = (int64_t)i;\n+    }\n+\n+    //assert\n+    for (uint32_t i = 0; i < MAX_SIZE; i++)\n+    {\n+        TEST_ELEMENT* elem = PAGED_SPARSE_ARRAY_GET(TEST_ELEMENT)(psa, i);\n+        ASSERT_IS_NOT_NULL(elem);\n+        ASSERT_ARE_EQUAL(int64_t, (int64_t)i, elem->value);\n+    }\n+\n+    //cleanup\n+    PAGED_SPARSE_ARRAY_ASSIGN(TEST_ELEMENT)(&psa, NULL);\n+}\n+\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_allocate_and_release_all_elements_succeeds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(TEST_ELEMENT) psa = PAGED_SPARSE_ARRAY_CREATE(TEST_ELEMENT)(MAX_SIZE, PAGE_SIZE);\n+    ASSERT_IS_NOT_NULL(psa);\n+\n+    // Allocate all elements\n+    for (uint32_t i = 0; i < MAX_SIZE; i++)\n+    {\n+        TEST_ELEMENT* elem = PAGED_SPARSE_ARRAY_ALLOCATE(TEST_ELEMENT)(psa, i);\n+        ASSERT_IS_NOT_NULL(elem);\n+        elem->value = (int64_t)i;\n+    }\n+\n+    //act - release all elements\n+    for (uint32_t i = 0; i < MAX_SIZE; i++)\n+    {\n+        int result = PAGED_SPARSE_ARRAY_RELEASE(TEST_ELEMENT)(psa, i);\n+        ASSERT_ARE_EQUAL(int, 0, result);\n+    }\n+\n+    //assert - all pages should be freed, all gets should fail\n+    for (uint32_t i = 0; i < MAX_SIZE; i++)\n+    {\n+        TEST_ELEMENT* elem = PAGED_SPARSE_ARRAY_GET(TEST_ELEMENT)(psa, i);\n+        ASSERT_IS_NULL(elem);\n+    }\n+\n+    // All pages should be NULL\n+    for (uint32_t i = 0; i < psa->page_count; i++)\n+    {\n+        ASSERT_IS_NULL(psa->pages[i]);\n+    }","path":"tests/paged_sparse_array_int/paged_sparse_array_int.c","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"tiny wee bit of cheating here.\r\n\r\nI assume if any page would de non-`NULL` at this point then vld should catch it.","created_at":"2026-01-12T14:36:23Z","updated_at":"2026-01-12T14:36:23Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682549585","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682549585"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682549585"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682549585/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":138,"original_line":138,"side":"RIGHT","author_association":"MEMBER","original_position":138,"position":138,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682554627","pull_request_review_id":3651096533,"id":2682554627,"node_id":"PRRC_kwDODaUZTc6f5IkD","diff_hunk":"@@ -0,0 +1,367 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#include <stdlib.h>\n+#include <stdbool.h>\n+#include <inttypes.h>\n+#include <time.h>\n+\n+#include \"macro_utils/macro_utils.h\"\n+#include \"testrunnerswitcher.h\"\n+\n+#include \"c_pal/gballoc_hl.h\"\n+#include \"c_pal/gballoc_hl_redirect.h\"\n+\n+#include \"c_pal/interlocked.h\"\n+#include \"c_pal/thandle.h\"\n+#include \"c_pal/threadapi.h\"\n+\n+#include \"c_util/paged_sparse_array.h\"\n+\n+typedef struct TEST_ELEMENT_TAG\n+{\n+    int64_t value;\n+} TEST_ELEMENT;\n+\n+PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(TEST_ELEMENT);\n+THANDLE_TYPE_DECLARE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(TEST_ELEMENT));\n+THANDLE_TYPE_DEFINE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(TEST_ELEMENT));\n+\n+PAGED_SPARSE_ARRAY_TYPE_DECLARE(TEST_ELEMENT);\n+PAGED_SPARSE_ARRAY_TYPE_DEFINE(TEST_ELEMENT);\n+\n+#define CHAOS_TEST_ACTION_VALUES \\\n+    CHAOS_TEST_ACTION_ALLOCATE, \\\n+    CHAOS_TEST_ACTION_RELEASE, \\\n+    CHAOS_TEST_ACTION_ALLOCATE_OR_GET, \\\n+    CHAOS_TEST_ACTION_GET\n+\n+MU_DEFINE_ENUM(CHAOS_TEST_ACTION, CHAOS_TEST_ACTION_VALUES)\n+MU_DEFINE_ENUM_STRINGS(CHAOS_TEST_ACTION, CHAOS_TEST_ACTION_VALUES)\n+\n+BEGIN_TEST_SUITE(TEST_SUITE_NAME_FROM_CMAKE)\n+\n+TEST_SUITE_INITIALIZE(suite_init)\n+{\n+    time_t seed = time(NULL);\n+    LogInfo(\"Test using random seed=%u\", (unsigned int)seed);\n+    srand((unsigned int)seed);\n+}\n+\n+TEST_SUITE_CLEANUP(suite_cleanup)\n+{\n+}\n+\n+TEST_FUNCTION_INITIALIZE(method_init)\n+{\n+}\n+\n+TEST_FUNCTION_CLEANUP(method_cleanup)\n+{\n+}\n+\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_CREATE_succeeds)\n+{\n+    //arrange\n+\n+    //act\n+    PAGED_SPARSE_ARRAY(TEST_ELEMENT) psa = PAGED_SPARSE_ARRAY_CREATE(TEST_ELEMENT)(1000, 64);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(psa);\n+\n+    //cleanup\n+    PAGED_SPARSE_ARRAY_ASSIGN(TEST_ELEMENT)(&psa, NULL);\n+}\n+\n+#define MAX_SIZE 1000\n+#define PAGE_SIZE 64\n+\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_allocate_all_elements_succeeds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(TEST_ELEMENT) psa = PAGED_SPARSE_ARRAY_CREATE(TEST_ELEMENT)(MAX_SIZE, PAGE_SIZE);\n+    ASSERT_IS_NOT_NULL(psa);\n+\n+    //act\n+    for (uint32_t i = 0; i < MAX_SIZE; i++)\n+    {\n+        TEST_ELEMENT* elem = PAGED_SPARSE_ARRAY_ALLOCATE(TEST_ELEMENT)(psa, i);\n+        ASSERT_IS_NOT_NULL(elem);\n+        elem->value = (int64_t)i;\n+    }\n+\n+    //assert\n+    for (uint32_t i = 0; i < MAX_SIZE; i++)\n+    {\n+        TEST_ELEMENT* elem = PAGED_SPARSE_ARRAY_GET(TEST_ELEMENT)(psa, i);\n+        ASSERT_IS_NOT_NULL(elem);\n+        ASSERT_ARE_EQUAL(int64_t, (int64_t)i, elem->value);\n+    }\n+\n+    //cleanup\n+    PAGED_SPARSE_ARRAY_ASSIGN(TEST_ELEMENT)(&psa, NULL);\n+}\n+\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_allocate_and_release_all_elements_succeeds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(TEST_ELEMENT) psa = PAGED_SPARSE_ARRAY_CREATE(TEST_ELEMENT)(MAX_SIZE, PAGE_SIZE);\n+    ASSERT_IS_NOT_NULL(psa);\n+\n+    // Allocate all elements\n+    for (uint32_t i = 0; i < MAX_SIZE; i++)\n+    {\n+        TEST_ELEMENT* elem = PAGED_SPARSE_ARRAY_ALLOCATE(TEST_ELEMENT)(psa, i);\n+        ASSERT_IS_NOT_NULL(elem);\n+        elem->value = (int64_t)i;\n+    }\n+\n+    //act - release all elements\n+    for (uint32_t i = 0; i < MAX_SIZE; i++)\n+    {\n+        int result = PAGED_SPARSE_ARRAY_RELEASE(TEST_ELEMENT)(psa, i);\n+        ASSERT_ARE_EQUAL(int, 0, result);\n+    }\n+\n+    //assert - all pages should be freed, all gets should fail\n+    for (uint32_t i = 0; i < MAX_SIZE; i++)\n+    {\n+        TEST_ELEMENT* elem = PAGED_SPARSE_ARRAY_GET(TEST_ELEMENT)(psa, i);\n+        ASSERT_IS_NULL(elem);\n+    }\n+\n+    // All pages should be NULL\n+    for (uint32_t i = 0; i < psa->page_count; i++)\n+    {\n+        ASSERT_IS_NULL(psa->pages[i]);\n+    }\n+\n+    //cleanup\n+    PAGED_SPARSE_ARRAY_ASSIGN(TEST_ELEMENT)(&psa, NULL);\n+}\n+\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_sparse_allocation_succeeds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(TEST_ELEMENT) psa = PAGED_SPARSE_ARRAY_CREATE(TEST_ELEMENT)(MAX_SIZE, PAGE_SIZE);\n+    ASSERT_IS_NOT_NULL(psa);\n+\n+    // Allocate only every 100th element (sparse)\n+    for (uint32_t i = 0; i < MAX_SIZE; i += 100)\n+    {\n+        TEST_ELEMENT* elem = PAGED_SPARSE_ARRAY_ALLOCATE(TEST_ELEMENT)(psa, i);\n+        ASSERT_IS_NOT_NULL(elem);\n+        elem->value = (int64_t)i * 10;","path":"tests/paged_sparse_array_int/paged_sparse_array_int.c","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":">(int64_t) [](http://example.com/codeflow?start=22&length=9)\r\n\r\nwhy is this cast needed?","created_at":"2026-01-12T14:37:33Z","updated_at":"2026-01-12T14:37:33Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682554627","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682554627"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682554627"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682554627/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":155,"original_line":155,"side":"RIGHT","author_association":"MEMBER","original_position":155,"position":155,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682555343","pull_request_review_id":3651097316,"id":2682555343,"node_id":"PRRC_kwDODaUZTc6f5IvP","diff_hunk":"@@ -0,0 +1,367 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#include <stdlib.h>\n+#include <stdbool.h>\n+#include <inttypes.h>\n+#include <time.h>\n+\n+#include \"macro_utils/macro_utils.h\"\n+#include \"testrunnerswitcher.h\"\n+\n+#include \"c_pal/gballoc_hl.h\"\n+#include \"c_pal/gballoc_hl_redirect.h\"\n+\n+#include \"c_pal/interlocked.h\"\n+#include \"c_pal/thandle.h\"\n+#include \"c_pal/threadapi.h\"\n+\n+#include \"c_util/paged_sparse_array.h\"\n+\n+typedef struct TEST_ELEMENT_TAG\n+{\n+    int64_t value;\n+} TEST_ELEMENT;\n+\n+PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(TEST_ELEMENT);\n+THANDLE_TYPE_DECLARE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(TEST_ELEMENT));\n+THANDLE_TYPE_DEFINE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(TEST_ELEMENT));\n+\n+PAGED_SPARSE_ARRAY_TYPE_DECLARE(TEST_ELEMENT);\n+PAGED_SPARSE_ARRAY_TYPE_DEFINE(TEST_ELEMENT);\n+\n+#define CHAOS_TEST_ACTION_VALUES \\\n+    CHAOS_TEST_ACTION_ALLOCATE, \\\n+    CHAOS_TEST_ACTION_RELEASE, \\\n+    CHAOS_TEST_ACTION_ALLOCATE_OR_GET, \\\n+    CHAOS_TEST_ACTION_GET\n+\n+MU_DEFINE_ENUM(CHAOS_TEST_ACTION, CHAOS_TEST_ACTION_VALUES)\n+MU_DEFINE_ENUM_STRINGS(CHAOS_TEST_ACTION, CHAOS_TEST_ACTION_VALUES)\n+\n+BEGIN_TEST_SUITE(TEST_SUITE_NAME_FROM_CMAKE)\n+\n+TEST_SUITE_INITIALIZE(suite_init)\n+{\n+    time_t seed = time(NULL);\n+    LogInfo(\"Test using random seed=%u\", (unsigned int)seed);\n+    srand((unsigned int)seed);\n+}\n+\n+TEST_SUITE_CLEANUP(suite_cleanup)\n+{\n+}\n+\n+TEST_FUNCTION_INITIALIZE(method_init)\n+{\n+}\n+\n+TEST_FUNCTION_CLEANUP(method_cleanup)\n+{\n+}\n+\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_CREATE_succeeds)\n+{\n+    //arrange\n+\n+    //act\n+    PAGED_SPARSE_ARRAY(TEST_ELEMENT) psa = PAGED_SPARSE_ARRAY_CREATE(TEST_ELEMENT)(1000, 64);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(psa);\n+\n+    //cleanup\n+    PAGED_SPARSE_ARRAY_ASSIGN(TEST_ELEMENT)(&psa, NULL);\n+}\n+\n+#define MAX_SIZE 1000\n+#define PAGE_SIZE 64\n+\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_allocate_all_elements_succeeds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(TEST_ELEMENT) psa = PAGED_SPARSE_ARRAY_CREATE(TEST_ELEMENT)(MAX_SIZE, PAGE_SIZE);\n+    ASSERT_IS_NOT_NULL(psa);\n+\n+    //act\n+    for (uint32_t i = 0; i < MAX_SIZE; i++)\n+    {\n+        TEST_ELEMENT* elem = PAGED_SPARSE_ARRAY_ALLOCATE(TEST_ELEMENT)(psa, i);\n+        ASSERT_IS_NOT_NULL(elem);\n+        elem->value = (int64_t)i;\n+    }\n+\n+    //assert\n+    for (uint32_t i = 0; i < MAX_SIZE; i++)\n+    {\n+        TEST_ELEMENT* elem = PAGED_SPARSE_ARRAY_GET(TEST_ELEMENT)(psa, i);\n+        ASSERT_IS_NOT_NULL(elem);\n+        ASSERT_ARE_EQUAL(int64_t, (int64_t)i, elem->value);\n+    }\n+\n+    //cleanup\n+    PAGED_SPARSE_ARRAY_ASSIGN(TEST_ELEMENT)(&psa, NULL);\n+}\n+\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_allocate_and_release_all_elements_succeeds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(TEST_ELEMENT) psa = PAGED_SPARSE_ARRAY_CREATE(TEST_ELEMENT)(MAX_SIZE, PAGE_SIZE);\n+    ASSERT_IS_NOT_NULL(psa);\n+\n+    // Allocate all elements\n+    for (uint32_t i = 0; i < MAX_SIZE; i++)\n+    {\n+        TEST_ELEMENT* elem = PAGED_SPARSE_ARRAY_ALLOCATE(TEST_ELEMENT)(psa, i);\n+        ASSERT_IS_NOT_NULL(elem);\n+        elem->value = (int64_t)i;\n+    }\n+\n+    //act - release all elements\n+    for (uint32_t i = 0; i < MAX_SIZE; i++)\n+    {\n+        int result = PAGED_SPARSE_ARRAY_RELEASE(TEST_ELEMENT)(psa, i);\n+        ASSERT_ARE_EQUAL(int, 0, result);\n+    }\n+\n+    //assert - all pages should be freed, all gets should fail\n+    for (uint32_t i = 0; i < MAX_SIZE; i++)\n+    {\n+        TEST_ELEMENT* elem = PAGED_SPARSE_ARRAY_GET(TEST_ELEMENT)(psa, i);\n+        ASSERT_IS_NULL(elem);\n+    }\n+\n+    // All pages should be NULL\n+    for (uint32_t i = 0; i < psa->page_count; i++)\n+    {\n+        ASSERT_IS_NULL(psa->pages[i]);\n+    }\n+\n+    //cleanup\n+    PAGED_SPARSE_ARRAY_ASSIGN(TEST_ELEMENT)(&psa, NULL);\n+}\n+\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_sparse_allocation_succeeds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(TEST_ELEMENT) psa = PAGED_SPARSE_ARRAY_CREATE(TEST_ELEMENT)(MAX_SIZE, PAGE_SIZE);\n+    ASSERT_IS_NOT_NULL(psa);\n+\n+    // Allocate only every 100th element (sparse)\n+    for (uint32_t i = 0; i < MAX_SIZE; i += 100)\n+    {\n+        TEST_ELEMENT* elem = PAGED_SPARSE_ARRAY_ALLOCATE(TEST_ELEMENT)(psa, i);\n+        ASSERT_IS_NOT_NULL(elem);\n+        elem->value = (int64_t)i * 10;","path":"tests/paged_sparse_array_int/paged_sparse_array_int.c","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"soft of here and everywhere","created_at":"2026-01-12T14:37:43Z","updated_at":"2026-01-12T14:37:44Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682555343","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682555343"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682555343"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682555343/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":155,"original_line":155,"side":"RIGHT","in_reply_to_id":2682554627,"author_association":"MEMBER","original_position":155,"position":155,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682571137","pull_request_review_id":3651116194,"id":2682571137,"node_id":"PRRC_kwDODaUZTc6f5MmB","diff_hunk":"@@ -0,0 +1,367 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#include <stdlib.h>\n+#include <stdbool.h>\n+#include <inttypes.h>\n+#include <time.h>\n+\n+#include \"macro_utils/macro_utils.h\"\n+#include \"testrunnerswitcher.h\"\n+\n+#include \"c_pal/gballoc_hl.h\"\n+#include \"c_pal/gballoc_hl_redirect.h\"\n+\n+#include \"c_pal/interlocked.h\"\n+#include \"c_pal/thandle.h\"\n+#include \"c_pal/threadapi.h\"\n+\n+#include \"c_util/paged_sparse_array.h\"\n+\n+typedef struct TEST_ELEMENT_TAG\n+{\n+    int64_t value;\n+} TEST_ELEMENT;\n+\n+PAGED_SPARSE_ARRAY_DEFINE_STRUCT_TYPE(TEST_ELEMENT);\n+THANDLE_TYPE_DECLARE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(TEST_ELEMENT));\n+THANDLE_TYPE_DEFINE(PAGED_SPARSE_ARRAY_TYPEDEF_NAME(TEST_ELEMENT));\n+\n+PAGED_SPARSE_ARRAY_TYPE_DECLARE(TEST_ELEMENT);\n+PAGED_SPARSE_ARRAY_TYPE_DEFINE(TEST_ELEMENT);\n+\n+#define CHAOS_TEST_ACTION_VALUES \\\n+    CHAOS_TEST_ACTION_ALLOCATE, \\\n+    CHAOS_TEST_ACTION_RELEASE, \\\n+    CHAOS_TEST_ACTION_ALLOCATE_OR_GET, \\\n+    CHAOS_TEST_ACTION_GET\n+\n+MU_DEFINE_ENUM(CHAOS_TEST_ACTION, CHAOS_TEST_ACTION_VALUES)\n+MU_DEFINE_ENUM_STRINGS(CHAOS_TEST_ACTION, CHAOS_TEST_ACTION_VALUES)\n+\n+BEGIN_TEST_SUITE(TEST_SUITE_NAME_FROM_CMAKE)\n+\n+TEST_SUITE_INITIALIZE(suite_init)\n+{\n+    time_t seed = time(NULL);\n+    LogInfo(\"Test using random seed=%u\", (unsigned int)seed);\n+    srand((unsigned int)seed);\n+}\n+\n+TEST_SUITE_CLEANUP(suite_cleanup)\n+{\n+}\n+\n+TEST_FUNCTION_INITIALIZE(method_init)\n+{\n+}\n+\n+TEST_FUNCTION_CLEANUP(method_cleanup)\n+{\n+}\n+\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_CREATE_succeeds)\n+{\n+    //arrange\n+\n+    //act\n+    PAGED_SPARSE_ARRAY(TEST_ELEMENT) psa = PAGED_SPARSE_ARRAY_CREATE(TEST_ELEMENT)(1000, 64);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(psa);\n+\n+    //cleanup\n+    PAGED_SPARSE_ARRAY_ASSIGN(TEST_ELEMENT)(&psa, NULL);\n+}\n+\n+#define MAX_SIZE 1000\n+#define PAGE_SIZE 64\n+\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_allocate_all_elements_succeeds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(TEST_ELEMENT) psa = PAGED_SPARSE_ARRAY_CREATE(TEST_ELEMENT)(MAX_SIZE, PAGE_SIZE);\n+    ASSERT_IS_NOT_NULL(psa);\n+\n+    //act\n+    for (uint32_t i = 0; i < MAX_SIZE; i++)\n+    {\n+        TEST_ELEMENT* elem = PAGED_SPARSE_ARRAY_ALLOCATE(TEST_ELEMENT)(psa, i);\n+        ASSERT_IS_NOT_NULL(elem);\n+        elem->value = (int64_t)i;\n+    }\n+\n+    //assert\n+    for (uint32_t i = 0; i < MAX_SIZE; i++)\n+    {\n+        TEST_ELEMENT* elem = PAGED_SPARSE_ARRAY_GET(TEST_ELEMENT)(psa, i);\n+        ASSERT_IS_NOT_NULL(elem);\n+        ASSERT_ARE_EQUAL(int64_t, (int64_t)i, elem->value);\n+    }\n+\n+    //cleanup\n+    PAGED_SPARSE_ARRAY_ASSIGN(TEST_ELEMENT)(&psa, NULL);\n+}\n+\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_allocate_and_release_all_elements_succeeds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(TEST_ELEMENT) psa = PAGED_SPARSE_ARRAY_CREATE(TEST_ELEMENT)(MAX_SIZE, PAGE_SIZE);\n+    ASSERT_IS_NOT_NULL(psa);\n+\n+    // Allocate all elements\n+    for (uint32_t i = 0; i < MAX_SIZE; i++)\n+    {\n+        TEST_ELEMENT* elem = PAGED_SPARSE_ARRAY_ALLOCATE(TEST_ELEMENT)(psa, i);\n+        ASSERT_IS_NOT_NULL(elem);\n+        elem->value = (int64_t)i;\n+    }\n+\n+    //act - release all elements\n+    for (uint32_t i = 0; i < MAX_SIZE; i++)\n+    {\n+        int result = PAGED_SPARSE_ARRAY_RELEASE(TEST_ELEMENT)(psa, i);\n+        ASSERT_ARE_EQUAL(int, 0, result);\n+    }\n+\n+    //assert - all pages should be freed, all gets should fail\n+    for (uint32_t i = 0; i < MAX_SIZE; i++)\n+    {\n+        TEST_ELEMENT* elem = PAGED_SPARSE_ARRAY_GET(TEST_ELEMENT)(psa, i);\n+        ASSERT_IS_NULL(elem);\n+    }\n+\n+    // All pages should be NULL\n+    for (uint32_t i = 0; i < psa->page_count; i++)\n+    {\n+        ASSERT_IS_NULL(psa->pages[i]);\n+    }\n+\n+    //cleanup\n+    PAGED_SPARSE_ARRAY_ASSIGN(TEST_ELEMENT)(&psa, NULL);\n+}\n+\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_sparse_allocation_succeeds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(TEST_ELEMENT) psa = PAGED_SPARSE_ARRAY_CREATE(TEST_ELEMENT)(MAX_SIZE, PAGE_SIZE);\n+    ASSERT_IS_NOT_NULL(psa);\n+\n+    // Allocate only every 100th element (sparse)\n+    for (uint32_t i = 0; i < MAX_SIZE; i += 100)\n+    {\n+        TEST_ELEMENT* elem = PAGED_SPARSE_ARRAY_ALLOCATE(TEST_ELEMENT)(psa, i);\n+        ASSERT_IS_NOT_NULL(elem);\n+        elem->value = (int64_t)i * 10;\n+    }\n+\n+    //act & assert - verify only allocated elements are accessible\n+    for (uint32_t i = 0; i < MAX_SIZE; i++)\n+    {\n+        TEST_ELEMENT* elem = PAGED_SPARSE_ARRAY_GET(TEST_ELEMENT)(psa, i);\n+        if (i % 100 == 0)\n+        {\n+            ASSERT_IS_NOT_NULL(elem);\n+            ASSERT_ARE_EQUAL(int64_t, (int64_t)i * 10, elem->value);\n+        }\n+        else\n+        {\n+            // Element not allocated - either page is NULL or element not marked as allocated\n+            // GET should return NULL\n+            ASSERT_IS_NULL(elem);\n+        }\n+    }\n+\n+    //cleanup\n+    PAGED_SPARSE_ARRAY_ASSIGN(TEST_ELEMENT)(&psa, NULL);\n+}\n+\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_allocate_already_allocated_fails)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(TEST_ELEMENT) psa = PAGED_SPARSE_ARRAY_CREATE(TEST_ELEMENT)(MAX_SIZE, PAGE_SIZE);\n+    ASSERT_IS_NOT_NULL(psa);\n+    TEST_ELEMENT* elem1 = PAGED_SPARSE_ARRAY_ALLOCATE(TEST_ELEMENT)(psa, 42);\n+    ASSERT_IS_NOT_NULL(elem1);\n+\n+    //act\n+    TEST_ELEMENT* elem2 = PAGED_SPARSE_ARRAY_ALLOCATE(TEST_ELEMENT)(psa, 42);\n+\n+    //assert\n+    ASSERT_IS_NULL(elem2);\n+\n+    //cleanup\n+    PAGED_SPARSE_ARRAY_ASSIGN(TEST_ELEMENT)(&psa, NULL);\n+}\n+\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_allocate_or_get_returns_same_element)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(TEST_ELEMENT) psa = PAGED_SPARSE_ARRAY_CREATE(TEST_ELEMENT)(MAX_SIZE, PAGE_SIZE);\n+    ASSERT_IS_NOT_NULL(psa);\n+    TEST_ELEMENT* elem1 = PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(TEST_ELEMENT)(psa, 42);\n+    ASSERT_IS_NOT_NULL(elem1);\n+    elem1->value = 12345;\n+\n+    //act\n+    TEST_ELEMENT* elem2 = PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(TEST_ELEMENT)(psa, 42);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(elem2);\n+    ASSERT_ARE_EQUAL(void_ptr, elem1, elem2);\n+    ASSERT_ARE_EQUAL(int64_t, 12345, elem2->value);\n+\n+    //cleanup\n+    PAGED_SPARSE_ARRAY_ASSIGN(TEST_ELEMENT)(&psa, NULL);\n+}\n+\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_release_and_reallocate_succeeds)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(TEST_ELEMENT) psa = PAGED_SPARSE_ARRAY_CREATE(TEST_ELEMENT)(MAX_SIZE, PAGE_SIZE);\n+    ASSERT_IS_NOT_NULL(psa);\n+    TEST_ELEMENT* elem1 = PAGED_SPARSE_ARRAY_ALLOCATE(TEST_ELEMENT)(psa, 42);\n+    ASSERT_IS_NOT_NULL(elem1);\n+    elem1->value = 100;\n+\n+    //act\n+    int release_result = PAGED_SPARSE_ARRAY_RELEASE(TEST_ELEMENT)(psa, 42);\n+    ASSERT_ARE_EQUAL(int, 0, release_result);\n+\n+    TEST_ELEMENT* elem2 = PAGED_SPARSE_ARRAY_ALLOCATE(TEST_ELEMENT)(psa, 42);\n+\n+    //assert\n+    ASSERT_IS_NOT_NULL(elem2);\n+    // Value should be indeterminate after reallocation, but element should be accessible\n+\n+    //cleanup\n+    PAGED_SPARSE_ARRAY_ASSIGN(TEST_ELEMENT)(&psa, NULL);\n+}\n+\n+TEST_FUNCTION(PAGED_SPARSE_ARRAY_page_freed_when_all_elements_released)\n+{\n+    //arrange\n+    PAGED_SPARSE_ARRAY(TEST_ELEMENT) psa = PAGED_SPARSE_ARRAY_CREATE(TEST_ELEMENT)(MAX_SIZE, PAGE_SIZE);\n+    ASSERT_IS_NOT_NULL(psa);\n+    \n+    // Allocate all elements in first page\n+    for (uint32_t i = 0; i < PAGE_SIZE; i++)\n+    {\n+        TEST_ELEMENT* elem = PAGED_SPARSE_ARRAY_ALLOCATE(TEST_ELEMENT)(psa, i);\n+        ASSERT_IS_NOT_NULL(elem);\n+    }\n+    ASSERT_IS_NOT_NULL(psa->pages[0]);\n+\n+    //act - release all elements in first page\n+    for (uint32_t i = 0; i < PAGE_SIZE; i++)\n+    {\n+        int result = PAGED_SPARSE_ARRAY_RELEASE(TEST_ELEMENT)(psa, i);\n+        ASSERT_ARE_EQUAL(int, 0, result);\n+    }\n+\n+    //assert - page should be freed\n+    ASSERT_IS_NULL(psa->pages[0]);","path":"tests/paged_sparse_array_int/paged_sparse_array_int.c","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"anporumb","id":9283365,"node_id":"MDQ6VXNlcjkyODMzNjU=","avatar_url":"https://avatars.githubusercontent.com/u/9283365?v=4","gravatar_id":"","url":"https://api.github.com/users/anporumb","html_url":"https://github.com/anporumb","followers_url":"https://api.github.com/users/anporumb/followers","following_url":"https://api.github.com/users/anporumb/following{/other_user}","gists_url":"https://api.github.com/users/anporumb/gists{/gist_id}","starred_url":"https://api.github.com/users/anporumb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anporumb/subscriptions","organizations_url":"https://api.github.com/users/anporumb/orgs","repos_url":"https://api.github.com/users/anporumb/repos","events_url":"https://api.github.com/users/anporumb/events{/privacy}","received_events_url":"https://api.github.com/users/anporumb/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"if it is not... vld should catch it probably?","created_at":"2026-01-12T14:41:26Z","updated_at":"2026-01-12T14:41:26Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2682571137","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682571137"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2682571137"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2682571137/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":263,"original_line":263,"side":"RIGHT","author_association":"MEMBER","original_position":263,"position":263,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2683314444","pull_request_review_id":3652004721,"id":2683314444,"node_id":"PRRC_kwDODaUZTc6f8CEM","diff_hunk":"@@ -0,0 +1,209 @@\n+# `paged_sparse_array` requirements\n+\n+## Overview\n+\n+`PAGED_SPARSE_ARRAY` is a module that provides a templatized paged sparse array data structure. The array has a maximum size and allocates memory in pages (groups of elements) on demand. When all elements in a page are released, the page is automatically freed.\n+\n+`PAGED_SPARSE_ARRAY` is a kind of `THANDLE`, all of the `THANDLE`'s API apply to `PAGED_SPARSE_ARRAY`. The following macros are provided with the same semantics as those of `THANDLE`'s:\n+- `PAGED_SPARSE_ARRAY_INITIALIZE(T)`\n+- `PAGED_SPARSE_ARRAY_ASSIGN(T)`\n+- `PAGED_SPARSE_ARRAY_MOVE(T)`\n+- `PAGED_SPARSE_ARRAY_INITIALIZE_MOVE(T)`\n+\n+## Design\n+\n+The array is organized into pages. Each page contains `page_size` elements. The total number of elements that can be stored is `max_size`. Pages are allocated lazily when an element is first allocated within that page. When all elements in a page are released, the page is automatically freed.\n+\n+Each element has an allocation state (allocated or not allocated). The user can:\n+- Allocate an index for usage (fails if already allocated)\n+- Release an index (when all indexes in a page are released, the page is freed)\n+- Allocate or get an index (allocates if not exists, gets if exists)\n+- Get an index (fails if not allocated)\n+\n+## Exposed API\n+\n+```c\n+/*to be used as the type of handle that wraps T*/\n+#define PAGED_SPARSE_ARRAY(T)\n+\n+/*to be used in a header file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+\n+/*to be used in a .c file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+```\n+\n+The macros expand to these useful APIs:\n+\n+```c\n+PAGED_SPARSE_ARRAY(T) PAGED_SPARSE_ARRAY_CREATE(T)(uint32_t max_size, uint32_t page_size);\n+void PAGED_SPARSE_ARRAY_FREE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array);\n+T* PAGED_SPARSE_ARRAY_ALLOCATE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+int PAGED_SPARSE_ARRAY_RELEASE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);\n+T* PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array, uint32_t index);","path":"devdoc/paged_sparse_array_requirements.md","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"mattdurak","id":12548298,"node_id":"MDQ6VXNlcjEyNTQ4Mjk4","avatar_url":"https://avatars.githubusercontent.com/u/12548298?v=4","gravatar_id":"","url":"https://api.github.com/users/mattdurak","html_url":"https://github.com/mattdurak","followers_url":"https://api.github.com/users/mattdurak/followers","following_url":"https://api.github.com/users/mattdurak/following{/other_user}","gists_url":"https://api.github.com/users/mattdurak/gists{/gist_id}","starred_url":"https://api.github.com/users/mattdurak/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mattdurak/subscriptions","organizations_url":"https://api.github.com/users/mattdurak/orgs","repos_url":"https://api.github.com/users/mattdurak/repos","events_url":"https://api.github.com/users/mattdurak/events{/privacy}","received_events_url":"https://api.github.com/users/mattdurak/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"yeah I think the allocation needs some initialization callback for this to work","created_at":"2026-01-12T17:58:56Z","updated_at":"2026-01-12T17:58:56Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2683314444","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2683314444"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2683314444"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2683314444/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":43,"original_line":43,"side":"RIGHT","in_reply_to_id":2682219494,"author_association":"MEMBER","original_position":43,"position":43,"subject_type":"line"},{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2683636199","pull_request_review_id":3652426845,"id":2683636199,"node_id":"PRRC_kwDODaUZTc6f9Qnn","diff_hunk":"@@ -0,0 +1,209 @@\n+# `paged_sparse_array` requirements\n+\n+## Overview\n+\n+`PAGED_SPARSE_ARRAY` is a module that provides a templatized paged sparse array data structure. The array has a maximum size and allocates memory in pages (groups of elements) on demand. When all elements in a page are released, the page is automatically freed.\n+\n+`PAGED_SPARSE_ARRAY` is a kind of `THANDLE`, all of the `THANDLE`'s API apply to `PAGED_SPARSE_ARRAY`. The following macros are provided with the same semantics as those of `THANDLE`'s:\n+- `PAGED_SPARSE_ARRAY_INITIALIZE(T)`\n+- `PAGED_SPARSE_ARRAY_ASSIGN(T)`\n+- `PAGED_SPARSE_ARRAY_MOVE(T)`\n+- `PAGED_SPARSE_ARRAY_INITIALIZE_MOVE(T)`\n+\n+## Design\n+\n+The array is organized into pages. Each page contains `page_size` elements. The total number of elements that can be stored is `max_size`. Pages are allocated lazily when an element is first allocated within that page. When all elements in a page are released, the page is automatically freed.\n+\n+Each element has an allocation state (allocated or not allocated). The user can:\n+- Allocate an index for usage (fails if already allocated)\n+- Release an index (when all indexes in a page are released, the page is freed)\n+- Allocate or get an index (allocates if not exists, gets if exists)\n+- Get an index (fails if not allocated)\n+\n+## Exposed API\n+\n+```c\n+/*to be used as the type of handle that wraps T*/\n+#define PAGED_SPARSE_ARRAY(T)\n+\n+/*to be used in a header file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DECLARE(T)\n+\n+/*to be used in a .c file*/\n+#define PAGED_SPARSE_ARRAY_TYPE_DEFINE(T)\n+```\n+\n+The macros expand to these useful APIs:\n+\n+```c\n+PAGED_SPARSE_ARRAY(T) PAGED_SPARSE_ARRAY_CREATE(T)(uint32_t max_size, uint32_t page_size);\n+void PAGED_SPARSE_ARRAY_FREE(T)(PAGED_SPARSE_ARRAY(T) paged_sparse_array);","path":"devdoc/paged_sparse_array_requirements.md","commit_id":"0746d0b747afb9460fbc405132017d9886729514","original_commit_id":"0746d0b747afb9460fbc405132017d9886729514","user":{"login":"dcristoloveanu","id":8507399,"node_id":"MDQ6VXNlcjg1MDczOTk=","avatar_url":"https://avatars.githubusercontent.com/u/8507399?v=4","gravatar_id":"","url":"https://api.github.com/users/dcristoloveanu","html_url":"https://github.com/dcristoloveanu","followers_url":"https://api.github.com/users/dcristoloveanu/followers","following_url":"https://api.github.com/users/dcristoloveanu/following{/other_user}","gists_url":"https://api.github.com/users/dcristoloveanu/gists{/gist_id}","starred_url":"https://api.github.com/users/dcristoloveanu/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dcristoloveanu/subscriptions","organizations_url":"https://api.github.com/users/dcristoloveanu/orgs","repos_url":"https://api.github.com/users/dcristoloveanu/repos","events_url":"https://api.github.com/users/dcristoloveanu/events{/privacy}","received_events_url":"https://api.github.com/users/dcristoloveanu/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Bot removed it and renamed to DISPOSE.","created_at":"2026-01-12T19:38:28Z","updated_at":"2026-01-12T19:38:28Z","html_url":"https://github.com/Azure/c-util/pull/565#discussion_r2683636199","pull_request_url":"https://api.github.com/repos/Azure/c-util/pulls/565","_links":{"self":{"href":"https://api.github.com/repos/Azure/c-util/pulls/comments/2683636199"},"html":{"href":"https://github.com/Azure/c-util/pull/565#discussion_r2683636199"},"pull_request":{"href":"https://api.github.com/repos/Azure/c-util/pulls/565"}},"reactions":{"url":"https://api.github.com/repos/Azure/c-util/pulls/comments/2683636199/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":40,"original_line":40,"side":"RIGHT","in_reply_to_id":2682210310,"author_association":"MEMBER","original_position":40,"position":40,"subject_type":"line"}]

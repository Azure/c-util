{"data":{"repository":{"pullRequest":{"reviewThreads":{"nodes":[{"isResolved":true,"path":"tests/paged_sparse_array_ut/paged_sparse_array_ut.c","line":792,"comments":{"nodes":[{"body":"We should have a Tests tagged here as this is a unit test. #Resolved"}]}},{"isResolved":true,"path":"tests/paged_sparse_array_ut/paged_sparse_array_ut.c","line":764,"comments":{"nodes":[{"body":"We should have a Tests tagged here as this is a unit test. #Resolved"}]}},{"isResolved":true,"path":"tests/paged_sparse_array_ut/paged_sparse_array_ut.c","line":null,"comments":{"nodes":[{"body":"This is called to be an integration test, check that an equivalent test exists in the int test suite. If it does this test can be removed. #Resolved"}]}},{"isResolved":true,"path":"inc/c_util/paged_sparse_array_ll.h","line":null,"comments":{"nodes":[{"body":">uint64_t [](http://example.com/codeflow?start=77&length=8)\r\n\r\nI think the indexes should be uint32_t. In all APIs #Resolved"}]}},{"isResolved":true,"path":"inc/c_util/paged_sparse_array_ll.h","line":null,"comments":{"nodes":[{"body":"Can we refactor to avoid the error: label?\r\nSomethng like \r\nif ((array->pages[page_index] == NULL) &&\r\n    ((array->pages[page_index] = PAGED_SPARSE_ARRAY_LL_ALLOCATE_PAGE_INTERNAL_NAME(C)(paged_sparse_array->page_size) == NULL))\r\n{\r\n} else\r\n{\r\n ...\r\n} #Resolved"}]}},{"isResolved":true,"path":"inc/c_util/paged_sparse_array_ll.h","line":null,"comments":{"nodes":[{"body":"> \\ [](http://example.com/codeflow?start=171&length=2)\r\n\r\nCan we have the \\ aligned at the same column (except if the line text is longer)? #Resolved"}]}},{"isResolved":false,"path":"devdoc/paged_sparse_array_requirements.md","line":40,"comments":{"nodes":[{"body":">PAGED_SPARSE_ARRAY_FREE [](http://example.com/codeflow?start=5&length=23)\r\n\r\nwhy do we need a FREE if `PAGED_SPARSE_ARRAY` is a `THANDLE`? Shouldn't an assign NULL be sufficient? #Resolved"}]}},{"isResolved":false,"path":"devdoc/paged_sparse_array_requirements.md","line":43,"comments":{"nodes":[{"body":">PAGED_SPARSE_ARRAY_ALLOCATE_OR_GET [](http://example.com/codeflow?start=3&length=34)\r\n\r\nHmmm... weird how this works.\r\n\r\nI am thinking - if I am the user and I have no knowledge about what's at `index` (whether it is allocated or not) ... \r\n\r\nand I get some non-NULL pointer as result - can I dereference that pointer and use the memory content there? How can I tell apart \"this is non-written yet memory\" versus \"this memory has already been initialized\".\r\n"}]}},{"isResolved":false,"path":"devdoc/paged_sparse_array_requirements.md","line":42,"comments":{"nodes":[{"body":">PAGED_SPARSE_ARRAY_RELEASE [](http://example.com/codeflow?start=4&length=26)\r\n\r\nwhy does \"release\" return an `int`? What is the user going to do with it... I think at this time the user already decided he doesn't need that memory anymore. \r\n\r\n`free` is `void`. #Resolved"}]}},{"isResolved":false,"path":"devdoc/paged_sparse_array_requirements.md","line":68,"comments":{"nodes":[{"body":">int32_t [](http://example.com/codeflow?start=32&length=7)\r\n\r\nwhat's the meaning of this int32_t?\r\n\r\nAll he previous int types were uint32_t (lines 39-44) #Closed"}]}},{"isResolved":false,"path":"devdoc/paged_sparse_array_requirements.md","line":13,"comments":{"nodes":[{"body":">Design [](http://example.com/codeflow?start=3&length=6)\r\n\r\nDesign should mention what is the target threading model here.\r\n\r\nWe know (PAGED_SPARSE_ARRAY) is a THANDLE - so ownership of the array is multithreaded.\r\n\r\nBut what about the data inside the array? What are the access patterns and target threading model over the data hosted in the array?"}]}},{"isResolved":false,"path":"devdoc/paged_sparse_array_requirements.md","line":13,"comments":{"nodes":[{"body":">Design [](http://example.com/codeflow?start=3&length=6)\r\n\r\nI am going to say that a nice ascii graphic that would show the array with the pages of the array and the pointers? in different stages of allocation wouild be greatly appreciated here "}]}},{"isResolved":false,"path":"devdoc/paged_sparse_array_requirements.md","line":112,"comments":{"nodes":[{"body":">void [](http://example.com/codeflow?start=0&length=4)\r\n\r\naaaah. looks like it should be static."}]}},{"isResolved":false,"path":"devdoc/paged_sparse_array_requirements.md","line":135,"comments":{"nodes":[{"body":">If the page is not allocated, `PAGED_SPARSE_ARRAY_ALLOCATE(T)` shall allocate memory for the page containing `page_size` elements and an allocation bitmap, and initialize all elements as not allocated. [](http://example.com/codeflow?start=37&length=201)\r\n\r\nmyeah, seeing here that there's no locks taken or other elements of threading involved, Iam going to assume that the data itself is non-threaded. Only ownership is threaded. Interesting."}]}},{"isResolved":false,"path":"devdoc/paged_sparse_array_requirements.md","line":135,"comments":{"nodes":[{"body":"> and an allocation bitmap [](http://example.com/codeflow?start=166&length=25)\r\n\r\nThis is a bit mysterious and it is mentioned here the 2nd time - what is this bitmap? Would be nice to know by this time.\r\n\r\nIs is a bit-array? byte array? some other structure?"}]}},{"isResolved":false,"path":"devdoc/paged_sparse_array_requirements.md","line":135,"comments":{"nodes":[{"body":">shall allocate memory [](http://example.com/codeflow?start=100&length=21)\r\n\r\nwould be nice to know about how much memory is going to allocate and by which memory call function.\r\n\r\nNotice how line 99 for example lists the memory API that is used... "}]}},{"isResolved":false,"path":"devdoc/paged_sparse_array_requirements.md","line":137,"comments":{"nodes":[{"body":">shall fail and return `NULL` [](http://example.com/codeflow?start=118&length=28)\r\n\r\nthis and line 143 are a bit conflating different root causes under the same umbrella of `something went wrong`.\r\n\r\nBut the causes are different.\r\n\r\ncause 1 is \"not enough memory\"\r\ncause 2 is \"probably user error and the array already has the element\""}]}},{"isResolved":false,"path":"devdoc/paged_sparse_array_requirements.md","line":13,"comments":{"nodes":[{"body":">Design [](http://example.com/codeflow?start=3&length=6)\r\n\r\nprobably design should mention if regular pointer arithmetic will not work/will not work with this data structure.\r\n\r\nFor example:\r\n\r\nT* first_element = PAGED_SPARSE_ARRAY_GET(T)(0);\r\nT* second_element = PAGED_SPARSE_ARRAY_GET(T)(1);\r\n\r\nMight not satisfy first_element+1 == second_element."}]}},{"isResolved":false,"path":"devdoc/paged_sparse_array_requirements.md","line":167,"comments":{"nodes":[{"body":">zero [](http://example.com/codeflow?start=82&length=4)\r\n\r\nAs a user, I still don't know what to do with this value."}]}},{"isResolved":false,"path":"devdoc/paged_sparse_array_requirements.md","line":175,"comments":{"nodes":[{"body":">if not already allocated, or gets it if it exists. [](http://example.com/codeflow?start=85&length=50)\r\n\r\nwhat's the use case here? As a user I feel that I might use this when I don't care about what was stored before in the index and overwrite it? So this is intended to be write-only element?\r\n\r\nI am very much on the side of deterministic access"}]}},{"isResolved":false,"path":"devdoc/paged_sparse_array_requirements.md","line":21,"comments":{"nodes":[{"body":"This does have some similarities with a hash table, with the hasing function set to index/page_size => page_number.\r\n\r\nAnd inside the page (bucket) it goes to index%page_size.\r\n\r\nbuckets are either empty/non-empty. \r\n\r\nbut I like this more than the hash table"}]}},{"isResolved":false,"path":"inc/c_util/paged_sparse_array_ll.h","line":111,"comments":{"nodes":[{"body":">T [](http://example.com/codeflow?start=55&length=1)\r\n\r\nweird, why is `T` not used in the macro expansion?"}]}},{"isResolved":false,"path":"inc/c_util/paged_sparse_array_ll.h","line":115,"comments":{"nodes":[{"body":">!= 0 [](http://example.com/codeflow?start=68&length=4)\r\n\r\nwhat happens is you remove this comparison?"}]}},{"isResolved":false,"path":"inc/c_util/paged_sparse_array_ll.h","line":162,"comments":{"nodes":[{"body":"we regularly just have 1x `if` statement that dumps all arguments with their values. \r\n\r\nI do see some extra value here, where explicitly the wrong parameter is spelled out, as opposed to \"dump all and then let the user analyze\". That was not a problem in the last X years.\r\n\r\nAlso it is nice to see all arguments. Just because sometimes the other arguments are interesting too. Maybe a correlation_id here and there."}]}},{"isResolved":false,"path":"inc/c_util/paged_sparse_array_ll.h","line":166,"comments":{"nodes":[{"body":">max_size + page_size [](http://example.com/codeflow?start=31&length=20)\r\n\r\nprobably a mischievous user can easily concoct some arguments that would overflow here."}]}},{"isResolved":false,"path":"inc/c_util/paged_sparse_array_ll.h","line":166,"comments":{"nodes":[{"body":">page_count [](http://example.com/codeflow?start=17&length=10)\r\n\r\npage_count cannot result in UINT32_MAX. #WontFix"}]}},{"isResolved":false,"path":"inc/c_util/paged_sparse_array_ll.h","line":212,"comments":{"nodes":[{"body":">PAGED_SPARSE_ARRAY_GET_BITMAP [](http://example.com/codeflow?start=26&length=29)\r\n\r\nhmmmm"}]}},{"isResolved":false,"path":"inc/c_util/paged_sparse_array_ll.h","line":237,"comments":{"nodes":[{"body":">uint32_t index_in_page = index % paged_sparse_array->page_size;      [](http://example.com/codeflow?start=8&length=68)\r\n\r\nmod operation can be delayed until it is used. #Resolved"}]}},{"isResolved":false,"path":"inc/c_util/paged_sparse_array_ll.h","line":354,"comments":{"nodes":[{"body":">el [](http://example.com/codeflow?start=8&length=2)\r\n\r\n??\r\n\r\nEither I cannot read code anymore (probable) or this is bit weird.\r\n\r\nAssume an newly brand new created sparse_array with page_size=10, max_size = 100.\r\n\r\nAssume the user calls with valid index == 0.\r\n\r\nThen line 347 will evaluate to \"true\" so line 348 will get executed.\r\n\r\nAssume line 348 does indeed allocate. So the whole \"if\" condition is false, we go to else branch.\r\n\r\nQuestion is \"why do we check anything in the else branch\" - we know for a fact that the page has just been allocated."}]}},{"isResolved":false,"path":"inc/c_util/paged_sparse_array_ll.h","line":359,"comments":{"nodes":[{"body":"I am wondering is !IS_ALLOCATED + SET_ALLOCATED which sounds a bit like \"SET_ALLOCATED_IF_NOT_ALLOCATED_ALREADY\" could be combined in 1 operation which would return the \"previous value\".\r\n\r\nJust saying seeing as interlockedbittestandset exists or similar (if memory helps)."}]}},{"isResolved":false,"path":"inc/c_util/paged_sparse_array_ll.h","line":325,"comments":{"nodes":[{"body":">ALLOCATE_OR_GET [](http://example.com/codeflow?start=25&length=15)\r\n\r\nI still maintain that allocate_or_get is weird because it requires extra synchronization with the user."}]}},{"isResolved":false,"path":"tests/paged_sparse_array_int/paged_sparse_array_int.c","line":7,"comments":{"nodes":[{"body":"time???"}]}},{"isResolved":false,"path":"tests/paged_sparse_array_int/paged_sparse_array_int.c","line":78,"comments":{"nodes":[{"body":"are these intended to be used by `PAGED_SPARSE_ARRAY_CREATE_succeeds` too? #Resolved"}]}},{"isResolved":false,"path":"tests/paged_sparse_array_int/paged_sparse_array_int.c","line":138,"comments":{"nodes":[{"body":"tiny wee bit of cheating here.\r\n\r\nI assume if any page would de non-`NULL` at this point then vld should catch it."}]}},{"isResolved":false,"path":"tests/paged_sparse_array_int/paged_sparse_array_int.c","line":155,"comments":{"nodes":[{"body":">(int64_t) [](http://example.com/codeflow?start=22&length=9)\r\n\r\nwhy is this cast needed?"}]}},{"isResolved":false,"path":"tests/paged_sparse_array_int/paged_sparse_array_int.c","line":263,"comments":{"nodes":[{"body":"if it is not... vld should catch it probably?"}]}}]}}}}}
